
<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">	
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="Linux," />
  

  
    <meta name="description" content="Linux笔记" />
  
  
  
  <link rel="icon" type="image/x-icon" href="/images/logo.png">
  
  <meta name="baidu-site-verification" content="codeva-g8ZVM1XNws" />
  <title>Linux笔记</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Helloeuler</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/categories" class="pure-menu-link">分类</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
      
  </ul>
   
</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        Linux笔记
      </h1>
      <span>
        
        <time class="time" datetime="2017-12-31T16:00:00.000Z">
        2018-01-01
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 611 分钟</span>
    </header>

    <div class="post-content">
      <h1 id="第-1-章-Linux管理"><a href="#第-1-章-Linux管理" class="headerlink" title="第 1 章 Linux管理"></a>第 1 章 <a href="">Linux管理</a></h1><h2 id="1-1-Linux基本指令"><a href="#1-1-Linux基本指令" class="headerlink" title="1.1 Linux基本指令"></a>1.1 <a href="">Linux基本指令</a></h2><h3 id="1-1-1-addr2line"><a href="#1-1-1-addr2line" class="headerlink" title="1.1.1 addr2line"></a>1.1.1 addr2line</h3><p>addr2line –e pgw 0Xfffff</p>
<p>另外：dmesg |grep pgw</p>
<p>注意：编译pgw需添加-g选项才可以找到所在行</p>
<h3 id="1-1-2-alias"><a href="#1-1-2-alias" class="headerlink" title="1.1.2 alias"></a>1.1.2 alias</h3><p>重命名:  alias killim&#x3D;”kill $(ps –A | awk ‘&#x2F;im_test&#x2F;{print $1}’)”</p>
<h3 id="1-1-3-ar"><a href="#1-1-3-ar" class="headerlink" title="1.1.3 ar"></a>1.1.3 ar</h3><p>　ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。</p>
<p>下面是ar命令的格式：</p>
<p>ar [-]{dmpqrtx}[abcfilNoPsSuvV] [membername] [count] archive files…</p>
<p>例如我们可以用<strong>ar rv libtest.a hello.o hello1.o</strong>来生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-‘字符，也可以没有。下面我们来看看命令的操作选项和任选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。</p>
<p>{dmpqrtx}中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下：</p>
<p>l d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。 </p>
<p>l m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用’a’，’b’，或’I’任选项移动到指定的位置。 </p>
<p>l p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。 </p>
<p>l q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。’a’，’b’，或’I’任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用’ar s’或ranlib来更新库的符号表索引。 </p>
<p>l r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 </p>
<p>l t：显示库的模块表清单。一般只显示模块名。 </p>
<p>l x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。 </p>
<p>下面在看看可与操作选项结合使用的任选项：</p>
<p>l a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。 </p>
<p>l b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。 </p>
<p>l c：创建一个库。不管库是否存在，都将创建。 </p>
<p>l f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。 </p>
<p>l i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。 </p>
<p>l l：暂未使用 </p>
<p>l N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。 </p>
<p>l o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。 </p>
<p>l P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。 </p>
<p>l s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。 </p>
<p>l S：不创建目标文件索引，这在创建较大的库时能加快时间。 </p>
<p>l u：一般说来，命令ar r…插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。 </p>
<p>l v：该选项用来显示执行操作选项的附加信息。 </p>
<p>l V：显示ar的版本。 </p>
<h3 id="1-1-4-Arp"><a href="#1-1-4-Arp" class="headerlink" title="1.1.4 Arp"></a>1.1.4 Arp</h3><p>Arp –a </p>
<p>显示所有ARP</p>
<h3 id="1-1-5-arping"><a href="#1-1-5-arping" class="headerlink" title="1.1.5 arping"></a>1.1.5 arping</h3><p>Linux arping命令测试IP地址冲突</p>
<p>arping命令可以用来测试局域网各个主机之间的连通性，测试局域网中某个特定的IP地址是否已经被占用，进而可以有效检测局域网内的IP地址冲突问题。</p>
<p>如下图示例：arping -c 3 -f -D <em>.</em>.<em>.<em>（</em>.</em>.*.*为IP地址）</p>
<p>192.168.2.222返回空，说明这个IP地址没有被局域网占用。</p>
<p>192.168.2.106返回1，说明这个IP地址已经被占用，并且收到回复可以看到绑定该IP的终端的mac地址。 </p>
<p>arping命令详细介绍：</p>
<p>用法：arping [-fqbDUAV] [-c count] [-w timeout] [-I device] [-s source]  ip地址</p>
<p>参数：</p>
<p>-A ARP回复模式，更新邻居</p>
<p>-b 保持广播</p>
<p>-D 复制地址检测模式</p>
<p>-f 得到第一个回复就 退出</p>
<p>-q 不显示警告信息</p>
<p>-U 主动的ARP模式，更新邻居</p>
<p>-c&lt;数据包的数目&gt; 发送的数据包的数目</p>
<p>-w&lt;超时时间&gt; 设置超时时间</p>
<p>-I&lt;网卡&gt; 使用指定的以太网设备，默认情况下使用eth0</p>
<p>-s 指定源IP地址</p>
<p>-h 显示帮助信息</p>
<p>-V 显示版本信息</p>
<h3 id="1-1-6-awk"><a href="#1-1-6-awk" class="headerlink" title="1.1.6 awk"></a>1.1.6 awk</h3><p>ls –l |awk ‘{print $1}’ 输出打印第一列结果</p>
<p>将得到的结果赋值给变量，如：</p>
<p>a&#x3D;$(ps –a|awk ‘&#x2F;tcpdump&#x2F;{print $1}’)</p>
<p>ó a&#x3D;$(ps –a|grep tcpdump |awk ‘{print $1}’)</p>
<h3 id="1-1-7-basename"><a href="#1-1-7-basename" class="headerlink" title="1.1.7 basename"></a>1.1.7 basename</h3><p>打印目录或文件的基本名称</p>
<h3 id="1-1-8-cat"><a href="#1-1-8-cat" class="headerlink" title="1.1.8 cat"></a>1.1.8 cat</h3><p>显示指定的一个或多个文件内容</p>
<p>如，cat  –n 	hello.c  a.c …</p>
<p>​	 -n  由1开始对所有输出的行进行编号</p>
<p>​	 -b   空白行不编号</p>
<p><strong>tac</strong>**	**	从最后一行开始显示文件内容</p>
<p>more 分页显示文本文件内容</p>
<p>less</p>
<p>head 显示文件首部内容</p>
<p>tail</p>
<p>e.g.		head 	-2	a.txt		显示当前目录下的a.txt的前两行</p>
<p>​		tail		-3	a.txt		显示当前目录下的a.txt的最后3行</p>
<h3 id="1-1-9-cd"><a href="#1-1-9-cd" class="headerlink" title="1.1.9 cd"></a>1.1.9 cd</h3><p>cd -		回到前次工作目录</p>
<p>cd ..   回到上级目录</p>
<p>cd ~	当前用户的家目录</p>
<p>e.g.		cd  ~jaky	切换到jaky的家目录</p>
<h3 id="1-1-10-chown-x2F-chgrp-x2F-chmod"><a href="#1-1-10-chown-x2F-chgrp-x2F-chmod" class="headerlink" title="1.1.10 chown&#x2F;chgrp&#x2F;chmod"></a>1.1.10 chown&#x2F;chgrp&#x2F;chmod</h3><p>chown		修改文件所有组和组别</p>
<p>chgrp		修改文件组所有权</p>
<p>chmod		修改文件访问权限</p>
<p>e.g.   chown	-R	root		a.tar     修改a.tar文件的所有者为root用户</p>
<p>chmod		u&#x3D;rwx,g&#x3D;rx,o&#x3D;x	house&#x2F;		修改house目录权限</p>
<p>-R 表示包括其子目录也同时修改</p>
<h3 id="1-1-11-chroot"><a href="#1-1-11-chroot" class="headerlink" title="1.1.11 chroot"></a>1.1.11 chroot</h3><p>改变根目录，即将某个目录作为&#x2F;</p>
<h3 id="1-1-12-cp"><a href="#1-1-12-cp" class="headerlink" title="1.1.12 cp"></a>1.1.12 cp</h3><p>复制文件或目录</p>
<p>-r 		递归复制，复制目录和目录下的所有文件</p>
<p>-v   	输出文字说明</p>
<p>格式：cp		原文件或目录		目标文件或目录</p>
<p>e．g．		cp		&#x2F;root&#x2F;*.docx		&#x2F;root&#x2F;doc	将&#x2F;root目录下所有以”.docx”结尾的文件复制到&#x2F;root&#x2F;doc目录下</p>
<p>复制时覆盖原有文件：</p>
<ol>
<li><p>修改&#x2F;root&#x2F;.bashrc下的alias</p>
</li>
<li><p>\cp A B</p>
</li>
</ol>
<h3 id="1-1-13-cut"><a href="#1-1-13-cut" class="headerlink" title="1.1.13 cut"></a>1.1.13 cut</h3><p>-d 指定分隔符</p>
<p>-f 指定域</p>
<p>cat &#x2F;etc&#x2F;redhat-release|cut –d ”.” –f  1   取出“.”右边的内容</p>
<p>示例：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps3.png" alt="img"></p>
<h3 id="1-1-14-df和du"><a href="#1-1-14-df和du" class="headerlink" title="1.1.14 df和du"></a>1.1.14 df和du</h3><p>df可以查询系统中各个存储设备的使用情况</p>
<p>-h：使用单位显示存储空间大小</p>
<p>du可以查询文件所占用的磁盘空间大小</p>
<p>-c	最后再输出所有文件占用空间的总和</p>
<p>查看磁盘剩余空间  df  -k</p>
<p>查看当前目录大小  du  -sh</p>
<p>查看当前目录所在分区大小 du  -h</p>
<p>存储情况</p>
<h3 id="1-1-15-dos2unix"><a href="#1-1-15-dos2unix" class="headerlink" title="1.1.15 dos2unix"></a>1.1.15 dos2unix</h3><p><a href="">sudo </a>find &#x2F;home   -name “*.c”|xargs  dos2unix</p>
<h3 id="1-1-16-echo"><a href="#1-1-16-echo" class="headerlink" title="1.1.16 echo"></a>1.1.16 echo</h3><p>显示打印</p>
<p>echo  hello			显示hello</p>
<p>​	 不换行： echo –n hello</p>
<p>   显示多行 echo –e “xxx  \n”</p>
<h3 id="1-1-17-env"><a href="#1-1-17-env" class="headerlink" title="1.1.17 env"></a>1.1.17 env</h3><p>查看当前环境变量</p>
<p>常用环境变量PATH</p>
<p>添加环境变量   &#x2F;home&#x2F;share   $PATH&#x3D;$PATH:&#x2F;home&#x2F;share </p>
<p>使环境变量生效    source	&#x2F;etc&#x2F;profile		</p>
<p>export		设置一个环境变量，当前shell的所有子进程都可以访问这个环境变量</p>
<h4 id="1-1-17-1-各环境变量意义"><a href="#1-1-17-1-各环境变量意义" class="headerlink" title="1.1.17.1 各环境变量意义"></a>1.1.17.1 各环境变量意义</h4><p>PATH: 可执行文件的目录</p>
<p>LIBRARY_PATH:静态库文件目录</p>
<p>LD_LIBRARY_PATH:动态库文件目录</p>
<p>gcc默认的include目录C_INCLUDE_PATH  </p>
<p>g++默认的include目录CPLUS_INCLUDE_PATH  </p>
<h3 id="1-1-18-ethtool"><a href="#1-1-18-ethtool" class="headerlink" title="1.1.18 ethtool"></a>1.1.18 ethtool</h3><p>获取、修改以太网卡配置信息</p>
<h3 id="1-1-19-file"><a href="#1-1-19-file" class="headerlink" title="1.1.19 file"></a>1.1.19 file</h3><p>显示指定文件的类型</p>
<h3 id="1-1-20-fdisk-l"><a href="#1-1-20-fdisk-l" class="headerlink" title="1.1.20 fdisk -l"></a>1.1.20 fdisk -l</h3><p>查看u盘分区</p>
<h3 id="1-1-21-find"><a href="#1-1-21-find" class="headerlink" title="1.1.21 find"></a>1.1.21 find</h3><p>e.g.		find		.&#x2F;		-name	hello*.c</p>
<p>​		find		&#x2F;boot	-size	-10K		查找boot目录下小于10k的文件</p>
<p>查找某目录下含内容test</p>
<p>find .&#x2F; |xargs grep “test”</p>
<h3 id="1-1-22-free"><a href="#1-1-22-free" class="headerlink" title="1.1.22 free"></a>1.1.22 free</h3><p>查询系统当前的内存使用情况</p>
<p>-b  以字节为单位显示</p>
<p>-k		KB</p>
<p>-m		MB</p>
<p>-g		GB</p>
<p>-s  delay  每隔delay秒刷新一次</p>
<h3 id="1-1-23-fuser"><a href="#1-1-23-fuser" class="headerlink" title="1.1.23 fuser"></a>1.1.23 fuser</h3><p>  fuser find files or sockets’ user</p>
<h3 id="1-1-24-getconf"><a href="#1-1-24-getconf" class="headerlink" title="1.1.24 getconf"></a>1.1.24 getconf</h3><p>getconf LONG_BIT  得到主机的位数</p>
<h3 id="1-1-25-gzip"><a href="#1-1-25-gzip" class="headerlink" title="1.1.25 gzip"></a>1.1.25 gzip</h3><p>gzip	a  压缩a文件为gzip格式</p>
<p>gzip	-d	a.gz		解压</p>
<h3 id="1-1-26-grep"><a href="#1-1-26-grep" class="headerlink" title="1.1.26 grep"></a>1.1.26 grep</h3><p>指定文件中搜索特定的内容，并将这些内容的行标准输出</p>
<p>-I  忽略大小写</p>
<p>-r	递归搜索，如果是目录，则搜索目录下的所有文件。</p>
<p>-c 统计</p>
<p>e.g.		grep	“hello” &#x2F;  -r  </p>
<p>grep	pattern1|pattern2	files		显示匹配pattern1或pattern2的行</p>
<p>grep	pattern1 files	|	grep	pattern2	files		..与..</p>
<p>grep –c “&#x2F;usr&#x2F;sbin&#x2F;logrotate &#x2F;etc&#x2F;logrotateim.conf” &#x2F;etc&#x2F;crontab</p>
<p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 </p>
<h4 id="1-1-26-1-选项"><a href="#1-1-26-1-选项" class="headerlink" title="1.1.26.1 选项"></a>1.1.26.1 选项</h4><p>-a 不要忽略二进制数据。</p>
<p>-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</p>
<p>-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。</p>
<p>-c 计算符合范本样式的列数。</p>
<p>-C&lt;显示列数&gt;或-&lt;显示列数&gt;  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</p>
<p>-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。</p>
<p>-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。</p>
<p>-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</p>
<p>-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。</p>
<p>-F 将范本样式视为固定字符串的列表。</p>
<p>-G 将范本样式视为普通的表示法来使用。</p>
<p>-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</p>
<p>-H 在显示符合范本样式的那一列之前，标示该列的文件名称。</p>
<p>-i 胡列字符大小写的差别。</p>
<p>-l 列出文件内容符合指定的范本样式的文件名称。</p>
<p>-L 列出文件内容不符合指定的范本样式的文件名称。</p>
<p>-n 在显示符合范本样式的那一列之前，标示出该列的编号。</p>
<p>-q 不显示任何信息。</p>
<p>-R&#x2F;-r 此参数的效果和指定“-d recurse”参数相同。</p>
<p>-s 不显示错误信息。</p>
<p>-v 反转查找。</p>
<p>-w 只显示全字符合的列。</p>
<p>-x 只显示全列符合的列。</p>
<p>-y 此参数效果跟“-i”相同。</p>
<p>-o 只输出文件中匹配到的部分。</p>
<h4 id="1-1-26-2-grep命令常见用法"><a href="#1-1-26-2-grep命令常见用法" class="headerlink" title="1.1.26.2 grep命令常见用法"></a>1.1.26.2 grep命令常见用法</h4><p>在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行： </p>
<p>grep match_pattern file_name</p>
<p>grep “match_pattern” file_name</p>
<p>在多个文件中查找： </p>
<p>grep “match_pattern” file_1 file_2 file_3 …</p>
<p>输出除之外的所有行 -v 选项： </p>
<p>grep -v “match_pattern” file_name</p>
<p>标记匹配颜色 –color&#x3D;auto 选项： </p>
<p>grep “match_pattern” file_name –color&#x3D;auto</p>
<p>使用正则表达式 -E 选项： </p>
<p>grep -E “[1-9]+”</p>
<p>或</p>
<p>egrep “[1-9]+”</p>
<p>只输出文件中匹配到的部分 -o 选项： </p>
<p>echo this is a test line. | grep -o -E “[a-z]+.“</p>
<p>line.</p>
<p>echo this is a test line. | egrep -o “[a-z]+.“</p>
<p>line.</p>
<p>统计文件或者文本中包含匹配字符串的行数 -c 选项： </p>
<p>grep -c “text” file_name</p>
<p>输出包含匹配字符串的行数 -n 选项： </p>
<p>grep “text” -n file_name</p>
<p>或</p>
<p>cat file_name | grep “text” -n</p>
<p>#多个文件</p>
<p>grep “text” -n file_1 file_2</p>
<p>打印样式匹配所位于的字符或字节偏移： </p>
<p>echo gun is not unix | grep -b -o “not”</p>
<p>7:not</p>
<p>#一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为0。选项 -b -o 一般总是配合使用。</p>
<p>搜索多个文件并查找匹配文本在哪些文件中： </p>
<p>grep -l “text” file1 file2 file3…</p>
<p>grep递归搜索文件</p>
<p>在多级目录中对文本进行递归搜索： </p>
<p>grep “text” . -r -n</p>
<p># .表示当前目录。</p>
<p>忽略匹配样式中的字符大小写： </p>
<p>echo “hello world” | grep -i “HELLO”</p>
<p>hello</p>
<p>选项 -e 制动多个匹配样式： </p>
<p>echo this is a text line | grep -e “is” -e “line” -o</p>
<p>is</p>
<p>line</p>
<p>#也可以使用-f选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。</p>
<p>cat patfile</p>
<p>aaa</p>
<p>bbb</p>
<p>echo aaa bbb ccc ddd eee | grep -f patfile -o</p>
<p>在grep搜索结果中包括或者排除指定文件： </p>
<p>#只在目录中所有的.php和.html文件中递归搜索字符”main()”</p>
<p>grep “main()” . -r –include *.{php,html}</p>
<p>#在搜索结果中排除所有README文件</p>
<p>grep “main()” . -r –exclude “README”</p>
<p>#在搜索结果中排除filelist文件列表里的文件</p>
<p>grep “main()” . -r –exclude-from filelist</p>
<p>使用0值字节后缀的grep与xargs： </p>
<p>#测试文件：</p>
<p>echo “aaa” &gt; file1</p>
<p>echo “bbb” &gt; file2</p>
<p>echo “aaa” &gt; file3</p>
<p>grep “aaa” file* -lZ | xargs -0 rm</p>
<p>#执行后会删除file1和file3，grep输出用-Z选项来指定以0值字节作为终结符文件名（\0），xargs -0 读取输入并用0值字节终结符分隔文件名，然后删除匹配文件，-Z通常和-l结合使用。</p>
<p>grep静默输出： </p>
<p>grep -q “test” filename</p>
<p>#不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</p>
<p>打印出匹配文本之前或者之后的行： </p>
<p>#显示匹配某个结果之后的3行，使用 -A 选项：</p>
<p>seq 10 | grep “5” -A 3</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>#显示匹配某个结果之前的3行，使用 -B 选项：</p>
<p>seq 10 | grep “5” -B 3</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>#显示匹配某个结果的前三行和后三行，使用 -C 选项：</p>
<p>seq 10 | grep “5” -C 3</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>#如果匹配结果有多个，会用“–”作为各匹配结果之间的分隔符：</p>
<p>echo -e “a\nb\nc\na\nb\nc” | grep a -A 1</p>
<p>a</p>
<p>b</p>
<p>--</p>
<p>a</p>
<p>b</p>
<h3 id="1-1-27-head"><a href="#1-1-27-head" class="headerlink" title="1.1.27 head"></a>1.1.27 head</h3><p>head –n 3 test.log</p>
<p>显示test.log的前3行，不指定的情况显示10行，如：head test.log</p>
<h3 id="1-1-28-help"><a href="#1-1-28-help" class="headerlink" title="1.1.28 help"></a>1.1.28 help</h3><p>帮助命令</p>
<h3 id="1-1-29-id"><a href="#1-1-29-id" class="headerlink" title="1.1.29 id"></a>1.1.29 id</h3><p>id –u &#x3D;&#x3D; 0   root用户</p>
<h3 id="1-1-30-ifconfig"><a href="#1-1-30-ifconfig" class="headerlink" title="1.1.30 ifconfig"></a>1.1.30 ifconfig</h3><p>显示ip地址</p>
<h3 id="1-1-31-ifstat"><a href="#1-1-31-ifstat" class="headerlink" title="1.1.31 ifstat"></a>1.1.31 ifstat</h3><p>统计网络接口活动状态工具</p>
<h3 id="1-1-32-iostat"><a href="#1-1-32-iostat" class="headerlink" title="1.1.32 iostat"></a>1.1.32 iostat</h3><p>监视系统输入输出设备和cpu的使用情况</p>
<h3 id="1-1-33-iotop"><a href="#1-1-33-iotop" class="headerlink" title="1.1.33 iotop"></a>1.1.33 iotop</h3><p>监视磁盘IO使用情况的top类工具</p>
<h3 id="1-1-34-ip"><a href="#1-1-34-ip" class="headerlink" title="1.1.34 ip"></a>1.1.34 ip</h3><p>ip addr 显示地址</p>
<h3 id="1-1-35-iptraf"><a href="#1-1-35-iptraf" class="headerlink" title="1.1.35 iptraf"></a>1.1.35 iptraf</h3><p>实时查看网卡流量，可以生成网络协议数据包信息、以太网信息等</p>
<h3 id="1-1-36-ipcs"><a href="#1-1-36-ipcs" class="headerlink" title="1.1.36 ipcs"></a>1.1.36 ipcs</h3><p>分析消息队列、共享内存和信号量</p>
<h3 id="1-1-37-iptables"><a href="#1-1-37-iptables" class="headerlink" title="1.1.37 iptables"></a>1.1.37 iptables</h3><p>iptables -F        清除预设表filter中的所有规则链的规则</p>
<h3 id="1-1-38-init"><a href="#1-1-38-init" class="headerlink" title="1.1.38 init"></a>1.1.38 init</h3><p>init  0、1、6</p>
<p>0  切换到运行级别0，代表关机</p>
<p>1  代表单用户模式</p>
<p>6  代表重新启动</p>
<p>  init 0 关机</p>
<p>  init 3  纯命令行模式</p>
<p>  init 5  图形界面形式</p>
<p>  init 6  重启</p>
<h3 id="1-1-39-kill"><a href="#1-1-39-kill" class="headerlink" title="1.1.39 kill"></a>1.1.39 kill</h3><p>向进程发送信号</p>
<h3 id="1-1-40-ldd"><a href="#1-1-40-ldd" class="headerlink" title="1.1.40 ldd"></a>1.1.40 ldd</h3><p>打印程序或库文件所依赖的共享库列表</p>
<h3 id="1-1-41-ln"><a href="#1-1-41-ln" class="headerlink" title="1.1.41 ln"></a>1.1.41 ln</h3><p>链接文件或目录</p>
<p>ln	-s	&#x2F;abc		&#x2F;root&#x2F;f			abc创建快捷方式名为f，存放于root文件夹下</p>
<h3 id="1-1-42-locate"><a href="#1-1-42-locate" class="headerlink" title="1.1.42 locate"></a>1.1.42 locate</h3><p>locate  grab	查找名为grab的文件或目录</p>
<p>查找文件</p>
<p>find &#x2F; -name   <em>filename</em>,这个很费时间，直接找的整个硬盘<br>locate   <em>filename</em><br>whereis  *filename   *这个好像能找到以前删除的，有几次看到了删除的都能找到</p>
<h3 id="1-1-43-logger"><a href="#1-1-43-logger" class="headerlink" title="1.1.43 logger"></a>1.1.43 logger</h3><p>logger [options] [messages]</p>
<h4 id="1-1-43-1-options-选项"><a href="#1-1-43-1-options-选项" class="headerlink" title="1.1.43.1 options (选项)"></a>1.1.43.1 options (选项)</h4><p>Ø -d, –udp </p>
<p>使用数据报(UDP)而不是使用默认的流连接(TCP)</p>
<p>Ø -i, –id</p>
<p>逐行记录每一次logger的进程ID</p>
<p>Ø -f, –file file_name</p>
<p>记录特定的文件</p>
<p>Ø -h, –help </p>
<p>显示帮助文本并退出</p>
<p>Ø -n， –server </p>
<p>写入指定的远程syslog服务器，使用UDP代替内装式syslog的例程</p>
<p>Ø -P， –port port_num</p>
<p>使用指定的UDP端口。默认的端口号是514</p>
<p>Ø -p， –priority priority_level</p>
<p>指定输入消息的优先级，优先级可以是数字或者指定为 “ facility.level” 的格式。比如：” -p local3.info “ local3 这个设备的消息级别为 info。默认级别是 “user.notice”</p>
<p>Ø -s， –stderr</p>
<p>输出标准错误到系统日志。</p>
<p>Ø -t， –tag tag</p>
<p>指定标记记录</p>
<p>Ø -u， –socket socket</p>
<p>写入指定的socket，而不是到内置系统日志例程。</p>
<p>Ø -V, –version</p>
<p>现实版本信息并退出</p>
<h4 id="1-1-43-2-messages"><a href="#1-1-43-2-messages" class="headerlink" title="1.1.43.2 messages"></a>1.1.43.2 messages</h4><p>写入log文件的内容消息，可以与-f配合使用。</p>
<p>logger 以0退出表示成功，大于0表示失败。</p>
<h4 id="1-1-43-3-日志级别"><a href="#1-1-43-3-日志级别" class="headerlink" title="1.1.43.3 日志级别"></a>1.1.43.3 日志级别</h4><p>facility：</p>
<p>​    auth：             用户授权</p>
<p>​    authpriv：          授权和安全</p>
<p>​    cron：             计划任务</p>
<p>​    daemon：           系统守护进程</p>
<p>​    kern：             与内核有关的信息</p>
<p>​    lpr                与打印服务有关的信息</p>
<p>​    mail               与电子邮件有关的信息</p>
<p>​    news               来自新闻服务器的信息</p>
<p>​    syslog             由syslog生成的信息</p>
<p>​    user               用户的程序生成的信息，默认</p>
<p>​    uucp               由uucp生成的信息</p>
<p>​    local0~7            用来定义本地策略</p>
<p>level：</p>
<p>​    alert          需要立即采取动作</p>
<p>​    crit           临界状态</p>
<p>​    debug          调试</p>
<p>​    emerg          系统不可用</p>
<p>​    err            错误状态</p>
<p>​    error          错误状态</p>
<p>​    info           正常消息</p>
<p>​    notice         正常但是要注意</p>
<h3 id="1-1-44-logsave"><a href="#1-1-44-logsave" class="headerlink" title="1.1.44 logsave"></a>1.1.44 logsave</h3><p>将命令的输出保存到指定的日志文件中</p>
<p>logsave –a log.txt tree</p>
<h3 id="1-1-45-ls"><a href="#1-1-45-ls" class="headerlink" title="1.1.45 ls"></a>1.1.45 ls</h3><p>ls	–l (ll)		显示文件属性，文件权限</p>
<p>ls	-a			显示包括隐藏文件的所有文件及目录</p>
<p>ls  -lh   		以人类可读方式显示文件大小</p>
<h3 id="1-1-46-lsof-grep-deleted"><a href="#1-1-46-lsof-grep-deleted" class="headerlink" title="1.1.46 lsof|grep deleted"></a>1.1.46 lsof|grep deleted</h3><p>当删掉某个文件后，硬盘空间并没有立即释放，采用上述命令，找出那个文件在使用，重启调用该文件的程序即可。</p>
<h3 id="1-1-47-ltrace"><a href="#1-1-47-ltrace" class="headerlink" title="1.1.47 ltrace"></a>1.1.47 ltrace</h3><p>跟踪进程调用库函数的情况</p>
<h3 id="1-1-48-make"><a href="#1-1-48-make" class="headerlink" title="1.1.48 make"></a>1.1.48 make</h3><p>-C  dir  执行时进入dir目录，默认当前目录</p>
<p>-f  file  使用file 做为Makefile</p>
<h3 id="1-1-49-man"><a href="#1-1-49-man" class="headerlink" title="1.1.49 man"></a>1.1.49 man</h3><p>获得帮助</p>
<p>man [cmd]</p>
<p>man 2 [system call]   </p>
<p>man 3 [lib function call]</p>
<p>e.g.  man 2 creat</p>
<p>​     man 3 printf</p>
<h3 id="1-1-50-mkdir"><a href="#1-1-50-mkdir" class="headerlink" title="1.1.50 mkdir"></a>1.1.50 mkdir</h3><p>创建目录</p>
<p>-p    如果file的父目录不存在，则先创建父目录</p>
<p>-v		对于创建的每一个目录输出一条说明</p>
<p>e.g.		mkdir	&#x2F;abc		在根目录下创建abc目录</p>
<p>​		mkdir	-p	&#x2F;doc&#x2F;abcd		在创建doc目录的同时创建abcd目录</p>
<p>touch		新建文件</p>
<h3 id="1-1-51-mount-x2F-umount"><a href="#1-1-51-mount-x2F-umount" class="headerlink" title="1.1.51 mount&#x2F;umount"></a>1.1.51 mount&#x2F;umount</h3><p>挂载或卸载设备</p>
<p>mount	查看挂载情况</p>
<p>mount	&#x2F;dev&#x2F;sdb6		&#x2F;mnt&#x2F;sdb6				挂载磁盘分区</p>
<p>mout	&#x2F;dev&#x2F;cdrom		&#x2F;mnt&#x2F;cdrom				挂载光驱</p>
<p>mount	&#x2F;dev&#x2F;sdc1		&#x2F;mnt&#x2F;sdc1				挂载u盘	</p>
<p>mount –t	vfat		&#x2F;dev&#x2F;sdb	&#x2F;mnt&#x2F;udisk		 挂载u盘</p>
<p>umout	&#x2F;mnt&#x2F;udisk								 卸载u盘</p>
<h3 id="1-1-52-mpstat"><a href="#1-1-52-mpstat" class="headerlink" title="1.1.52 mpstat"></a>1.1.52 mpstat</h3><p>多cpu下显示各个可用cpu状态</p>
<p>mpstat –P 1</p>
<h3 id="1-1-53-mv"><a href="#1-1-53-mv" class="headerlink" title="1.1.53 mv"></a>1.1.53 mv</h3><p>移动或更名现有文件或目录</p>
<p>e.g.		mv		a  b		把a改名为b</p>
<h3 id="1-1-54-nautilus"><a href="#1-1-54-nautilus" class="headerlink" title="1.1.54 nautilus"></a>1.1.54 nautilus</h3><p>nautilus		&#x2F;home		打开图像化的home文件</p>
<p><a target="_blank" rel="noopener" href="http://hi.baidu.com/tjuliuxinghua/item/81333992027eb61a924f4108">关于nautilus的应用</a></p>
<h3 id="1-1-55-netstat"><a href="#1-1-55-netstat" class="headerlink" title="1.1.55 netstat"></a>1.1.55 netstat</h3><p>netstat –tln 查看端口使用情况</p>
<p>netstat –a  查看所有端口</p>
<p>netstat –apn | grep ems   查看ems连接（打开）的所有端口</p>
<h3 id="1-1-56-nm"><a href="#1-1-56-nm" class="headerlink" title="1.1.56 nm"></a>1.1.56 nm</h3><p>nm用来列出目标文件的符号清单。下面是nm命令的格式：</p>
<p>nm [-a|–debug-syms] [-g|–extern-only] [-B][-C|–demangle] [-D|–dynamic] [-s|–print-armap][-o|–print-file-name] [-n|–numeric-sort][-p|–no-sort] [-r|–reverse-sort] [–size-sort][-u|–undefined-only] [-l|–line-numbers] [–help][–version] [-t radix|–radix&#x3D;radix][-P|–portability] [-f format|–format&#x3D;format][–target&#x3D;bfdname] [objfile…]</p>
<p>如果没有为nm命令指出目标文件，则nm假定目标文件是a.out。下面列出该命令的任选项，大部分支持”-“开头的短格式和”—“开头的长格式。</p>
<p>-A、-o或–print-file-name：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。 </p>
<p>例如nm libtest.a的输出如下：</p>
<p>CPThread.o:<br>00000068 T Main__8CPThreadPv<br>00000038 T Start__8CPThread<br>00000014 T _._8CPThread<br>00000000 T __8CPThread<br>00000000 ? <strong>FRAME_BEGIN</strong><br>…………………………………</p>
<p>则nm -A 的输出如下：</p>
<p>libtest.a:CPThread.o:00000068 T Main__8CPThreadPv<br>libtest.a:CPThread.o:00000038 T Start__8CPThread<br>libtest.a:CPThread.o:00000014 T _._8CPThread<br>libtest.a:CPThread.o:00000000 T __8CPThread<br>libtest.a:CPThread.o:00000000 ? <strong>FRAME_BEGIN</strong><br>…………………………………………………………</p>
<p>l -a或–debug-syms：显示调试符号。 </p>
<p>l -B：等同于–format&#x3D;bsd，用来兼容MIPS的nm。 </p>
<p>l -C或–demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。 </p>
<p>l -D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。 </p>
<p>l -f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。 </p>
<p>l -g或–extern-only：仅显示外部符号。 </p>
<p>l -n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。 </p>
<p>l -p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。 </p>
<p>l -P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。 </p>
<p>l -s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。 </p>
<p>l -r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。 </p>
<p>l –size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。 </p>
<p>l -t radix或–radix&#x3D;radix：使用radix进制显示符号值。radix只能为”d”表示十进制、”o”表示八进制或”x”表示十六进制。 </p>
<p>l –target&#x3D;bfdname：指定一个目标代码的格式，而非使用系统的默认格式。 </p>
<p>l -u或–undefined-only：仅显示没有定义的符号(那些外部符号)。 </p>
<p>l -l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。 </p>
<p>l -V或–version：显示nm的版本号。 </p>
<p>l –help：显示nm的任选项。 </p>
<h3 id="1-1-57-nohup"><a href="#1-1-57-nohup" class="headerlink" title="1.1.57 nohup"></a>1.1.57 nohup</h3><p>不挂断运行命令</p>
<p>nohup wireshark &gt;&#x2F;dev&#x2F;null &amp;</p>
<h3 id="1-1-58-nslookup"><a href="#1-1-58-nslookup" class="headerlink" title="1.1.58 nslookup"></a>1.1.58 nslookup</h3><p>Nslookup(name server lookup)( 域名查询):是一个用于查询 Internet域名信息或诊断DNS 服务器问题的工具.</p>
<p>nslookup</p>
<p>&gt;	 <a target="_blank" rel="noopener" href="http://www.hnu.edu.cn/">www.hnu.edu.cn</a>		要查询的主机域名</p>
<p>…</p>
<p>Address					解析的IP地址</p>
<p>&gt;  exit					退出</p>
<h3 id="1-1-59-passwd"><a href="#1-1-59-passwd" class="headerlink" title="1.1.59 passwd"></a>1.1.59 passwd</h3><p>用于修改用户密码</p>
<p>-S 查看指定用户的密码状态</p>
<p>-a 与-S结合查看所有用户的密码状态</p>
<p>-d 删除指定用户的密码</p>
<h3 id="1-1-60-ping"><a href="#1-1-60-ping" class="headerlink" title="1.1.60 ping"></a>1.1.60 ping</h3><p>测试网络连通性</p>
<p>-a  收到响应发出声音</p>
<p>-c count  发送count 个，默认无限</p>
<p>-i interval	发送间隔，默认1s</p>
<p>ping	-c	3		192.168.1.1	 </p>
<p>-I eth&#x2F;ip   通过制定ip或端口</p>
<p>注：windows</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps4.jpg" alt="img"> </p>
<h3 id="1-1-61-pmap"><a href="#1-1-61-pmap" class="headerlink" title="1.1.61 pmap"></a>1.1.61 pmap</h3><p>报告进程的内存映射关系</p>
<p>pmap [pid]</p>
<p>-x 显示扩展格式</p>
<h3 id="1-1-62-prstat"><a href="#1-1-62-prstat" class="headerlink" title="1.1.62 prstat"></a>1.1.62 prstat</h3><p>显示系统当前运行的进程和项目的各种信息</p>
<h3 id="1-1-63-ps"><a href="#1-1-63-ps" class="headerlink" title="1.1.63 ps"></a>1.1.63 ps</h3><p>查看系统中的进程</p>
<p>-e显示所有进程</p>
<p>-l 输出关于进程更详细信息</p>
<h3 id="1-1-64-pstree"><a href="#1-1-64-pstree" class="headerlink" title="1.1.64 pstree"></a>1.1.64 pstree</h3><p>以树形结构显示进程</p>
<h3 id="1-1-65-pstack"><a href="#1-1-65-pstack" class="headerlink" title="1.1.65 pstack"></a>1.1.65 pstack</h3><p>查看进程的栈跟踪</p>
<p>pstack <code>pidof mme</code></p>
<h3 id="1-1-66-pwd"><a href="#1-1-66-pwd" class="headerlink" title="1.1.66 pwd"></a>1.1.66 pwd</h3><p>查看当前目录</p>
<h3 id="1-1-67-ranlib"><a href="#1-1-67-ranlib" class="headerlink" title="1.1.67 ranlib"></a>1.1.67 ranlib</h3><p>更新静态库符号索引表</p>
<h3 id="1-1-68-read"><a href="#1-1-68-read" class="headerlink" title="1.1.68 read"></a>1.1.68 read</h3><h4 id="1-1-68-1-基本读取"><a href="#1-1-68-1-基本读取" class="headerlink" title="1.1.68.1 基本读取"></a>1.1.68.1 基本读取</h4><p>read命令接收标准输入（键盘）的输入，或其他文件描述符的输入（后面在说）。得到输入后，read命令将数据放入一个标准变量中。下面是 read命令的最简单形式。</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>echo -n “Enter your name:”   &#x2F;&#x2F;参数-n的作用是不换行，echo默认是换行</p>
<p>read  name                   &#x2F;&#x2F;从键盘输入</p>
<p>echo “hello $name,welcome to my program”     &#x2F;&#x2F;显示信息</p>
<p>exit 0                       &#x2F;&#x2F;退出shell程序。</p>
<p>&#x2F;&#x2F;********************************</p>
<p>由于read命令提供了-p参数，允许在read命令行中直接指定一个提示。</p>
<p>所以上面的脚本可以简写成下面的脚本::</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>read -p “Enter your name:” name</p>
<p>echo “hello $name, welcome to my program”</p>
<p>exit 0</p>
<p>在上面read后面的变量只有name一个，也可以有多个，这时如果输入多个数据，则第一个数据给第一个变量，第二个数据给第二个变量，如果输入数 据个数过多，则最后所有的值都给第一个变量。如果太少输入不会结束。</p>
<p>&#x2F;&#x2F;*****************************************</p>
<p>在read命令行中也可以不指定变量.如果不指定变量，那么read命令会将接收到的数据放置在环境变量REPLY中。</p>
<p>例如::</p>
<p>read -p “Enter a number”</p>
<p>环境变量REPLY中包含输入的所有数据，可以像使用其他变量一样在shell脚本中使用环境变量REPLY.</p>
<h4 id="1-1-68-2-计时输入"><a href="#1-1-68-2-计时输入" class="headerlink" title="1.1.68.2 计时输入."></a>1.1.68.2 计时输入.</h4><p>使用read命令存在着潜在危险。脚本很可能会停下来一直等待用户的输入。如果无论是否输入数据脚本都必须继续执行，那么可以使用-t选项指定一个 计时器。</p>
<p>-t选项指定read命令等待输入的秒数。当计时满时，read命令返回一个非零退出状态;</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>if read -t 5 -p “please enter your name:” name</p>
<p>then </p>
<p>​    echo “hello $name ,welcome to my script”</p>
<p>else</p>
<p>​    echo “sorry,too slow”</p>
<p>fi</p>
<p>exit 0</p>
<p>除了输入时间计时，还可以设置read命令计数输入的字符。当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量。</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>read -n1 -p “Do you want to continue [Y&#x2F;N]?” answer</p>
<p>case $answer in</p>
<p>Y | y)</p>
<p>​      echo “fine ,continue”;;</p>
<p>N | n)</p>
<p>​      echo “ok,good bye”;;</p>
<p>*)</p>
<p>​     echo “error choice”;;</p>
<p>esac</p>
<p>exit 0</p>
<p>该例子使用了-n选项，后接数值1，指示read命令只要接受到一个字符就退出。只要按下一个字符进行回答，read命令立即接受输入并将其传给变量。无需按回车键。</p>
<h4 id="1-1-68-3-默读（输入不显示在监视器上）"><a href="#1-1-68-3-默读（输入不显示在监视器上）" class="headerlink" title="1.1.68.3 默读（输入不显示在监视器上）"></a>1.1.68.3 默读（输入不显示在监视器上）</h4><p>有时会需要脚本用户输入，但不希望输入的数据显示在监视器上。典型的例子就是输入密码，当然还有很多其他需要隐藏的数据。</p>
<p>-s选项能够使read命令中输入的数据不显示在监视器上（实际上，数据是显示的，只是 read命令将文本颜色设置成与背景相同的颜色）。</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>read  -s  -p “Enter your password:” pass</p>
<p>echo “your password is $pass”</p>
<p>exit 0 </p>
<h4 id="1-1-68-4-读文件"><a href="#1-1-68-4-读文件" class="headerlink" title="1.1.68.4 读文件"></a>1.1.68.4 读文件</h4><p>最后，还可以使用read命令读取Linux系统上的文件。</p>
<p>每次调用read命令都会读取文件中的”一行”文本。当文件没有可读的行时，read命令将以非零状态退出。</p>
<p>读取文件的关键是如何将文本中的数据传送给read命令。</p>
<p>最常用的方法是对文件使用cat命令并通过管道将结果直接传送给包含read命令的 while命令</p>
<p>例子::</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>count&#x3D;1    &#x2F;&#x2F;赋值语句，不加空格</p>
<p>cat test | while read line        &#x2F;&#x2F;cat 命令的输出作为read命令的输入,read读到的值放在line中</p>
<p>do</p>
<p>   echo “Line $count:$line”</p>
<p>   count&#x3D;$[ $count + 1 ]          &#x2F;&#x2F;注意中括号中的空格。</p>
<p>done</p>
<p>echo “finish”</p>
<p>exit 0</p>
<h3 id="1-1-69-readelf"><a href="#1-1-69-readelf" class="headerlink" title="1.1.69 readelf"></a>1.1.69 readelf</h3><p>读取elf文件信息</p>
<p>-a 所有</p>
<h3 id="1-1-70-rm"><a href="#1-1-70-rm" class="headerlink" title="1.1.70 rm"></a>1.1.70 rm</h3><p>remove删除文件</p>
<p>-r	递归删除，删除目录和目录下的所有文件</p>
<p>rm -rf 目录名     会把目录名的文件夹删掉，建议使用</p>
<p>-f	强制删除</p>
<p>-v	输出说明文字</p>
<p>rm -f  !(a) 最为方便。如果保留a和b,可以运行rm -f !(a|b)来实现。</p>
<h3 id="1-1-71-rmdir"><a href="#1-1-71-rmdir" class="headerlink" title="1.1.71 rmdir"></a>1.1.71 rmdir</h3><p>删除目录</p>
<p>rm  -rf</p>
<h3 id="1-1-72-route"><a href="#1-1-72-route" class="headerlink" title="1.1.72 route"></a>1.1.72 route</h3><p>显示路由信息</p>
<h4 id="1-1-72-1-添加路由"><a href="#1-1-72-1-添加路由" class="headerlink" title="1.1.72.1 添加路由"></a>1.1.72.1 添加路由</h4><p>route add -net 192.168.0.0&#x2F;24 gw 192.168.0.1</p>
<p>route add -host 192.168.1.1 dev 192.168.0.1</p>
<h4 id="1-1-72-2-删除路由"><a href="#1-1-72-2-删除路由" class="headerlink" title="1.1.72.2 删除路由"></a>1.1.72.2 删除路由</h4><p>route del -net 192.168.0.0&#x2F;24 gw 192.168.0.1</p>
<h4 id="1-1-72-3-增加默认路由"><a href="#1-1-72-3-增加默认路由" class="headerlink" title="1.1.72.3 增加默认路由"></a>1.1.72.3 增加默认路由</h4><p>route add default gw 192.168.0.1</p>
<p>默认路由一条就够了</p>
<p>route -n 查看路由表</p>
<p>add 增加路由</p>
<p>del 删除路由</p>
<p>-net 设置到某个网段的路由</p>
<p>-host 设置到某台主机的路由</p>
<p>gw 出口网关 IP地址</p>
<p>dev 出口网关 物理设备名</p>
<h4 id="1-1-72-4-添加路由2"><a href="#1-1-72-4-添加路由2" class="headerlink" title="1.1.72.4 添加路由2"></a>1.1.72.4 添加路由2</h4><p>ip route add 192.168.0.0&#x2F;24 via 192.168.0.1</p>
<p>ip route add 192.168.1.1 dev 192.168.0.1</p>
<p>删除路由</p>
<p>ip route del 192.168.0.0&#x2F;24 via 192.168.0.1</p>
<p>add 增加路由</p>
<p>del 删除路由</p>
<p>via 网关出口 IP地址</p>
<p>dev 网关出口 物理设备名</p>
<h4 id="1-1-72-5-增加默认路由2"><a href="#1-1-72-5-增加默认路由2" class="headerlink" title="1.1.72.5 增加默认路由2"></a>1.1.72.5 增加默认路由2</h4><p>ip route add default via 192.168.0.1 dev eth0</p>
<p>via 192.168.0.1 是我的默认路由器</p>
<h4 id="1-1-72-6-查看路由信息"><a href="#1-1-72-6-查看路由信息" class="headerlink" title="1.1.72.6 查看路由信息"></a>1.1.72.6 查看路由信息</h4><p>ip route</p>
<p>保存路由设置，使其在网络重启后任然有效 </p>
<p>在&#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;目录下创建名为route- eth0的文件 </p>
<p>vi &#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;route-eth0 </p>
<p>在此文件添加如下格式的内容 </p>
<p>192.168.1.0&#x2F;24 via 192.168.0.1 </p>
<p>重启网络验证 </p>
<p>&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;network中有这么几行：</p>
<p># Add non interface-specific static-routes.</p>
<p>if [ -f &#x2F;etc&#x2F;sysconfig&#x2F;static-routes ]; then</p>
<p>grep “^any” &#x2F;etc&#x2F;sysconfig&#x2F;static-routes | while read ignore args ; do</p>
<p>&#x2F;sbin&#x2F;route add -$args</p>
<p>done</p>
<p>fi </p>
<p>也就是说，将静态路由加到&#x2F;etc&#x2F;sysconfig&#x2F;static-routes 文件中就行了。</p>
<p>如加入：</p>
<p>route add -net 11.1.1.0 netmask 255.255.255.0 gw 11.1.1.1</p>
<p>则static-routes的格式为</p>
<p>any net 11.1.1.0 netmask 255.255.255.0 gw 11.1.1.1</p>
<h4 id="1-1-72-7-高级功能-策略路由"><a href="#1-1-72-7-高级功能-策略路由" class="headerlink" title="1.1.72.7 高级功能-策略路由"></a>1.1.72.7 高级功能-策略路由</h4><p>基于策略的路由比传统路由在功能上更强大，使用更灵活，它使网络管理员不仅能够根据目的地址而且能够根据报文大小、应用或IP源地址来选择转发路径…  </p>
<p>#&#x2F;etc&#x2F;iproute2&#x2F;rt_tables 此文件存有linux 系统路由表默认表有255 254 253三张表 </p>
<p>255  local 本地路由表 存有本地接口地址，广播地址，已及NAT地址.</p>
<p>local表由系统自动维护..管理员不能操作此表… </p>
<p>254  main 主路由表 传统路由表,ip route若没指定表亦操作表254.一般存所有的路由.. </p>
<p>​     注:平时用ip ro sh查看的亦是此表设置的路由. </p>
<p>253  default  默认路由表一般存放默认路由… </p>
<p>​     注：rt_tables文件中表以数字来区分表0保留最多支持255张表 </p>
<p>路由表的查看可有以下二种方法： </p>
<p>​      #ip route list table table_number </p>
<p>​      #ip route list table table_name</p>
<h3 id="1-1-73-rpm"><a href="#1-1-73-rpm" class="headerlink" title="1.1.73 rpm"></a>1.1.73 rpm</h3><p>安装管理包</p>
<p>rpm	-ivh		&#x2F;a.e15.i386.rpm</p>
<p>​		-i		安装</p>
<p>​		-v		查看详细安装信息</p>
<p>​		-h		安装进度</p>
<p>rpm	-qa			q查询		a所有包</p>
<p>rpm	-ivh		p.rpm		i  安装p.rpm到系统上</p>
<p>​								v  执行时显示命令执行过程</p>
<p>​								h	显示安装过程</p>
<p>rpm -ivh package.rpm 安装一个rpm包</p>
<p>rpm -qa 显示系统中所有已经安装的rpm包</p>
<p>rpm –qa httpd</p>
<p>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包</p>
<h4 id="1-1-73-1-强制卸载"><a href="#1-1-73-1-强制卸载" class="headerlink" title="1.1.73.1 强制卸载"></a>1.1.73.1 强制卸载</h4><p>Rpm –nodeps -e test.rpm</p>
<h4 id="1-1-73-2-详解"><a href="#1-1-73-2-详解" class="headerlink" title="1.1.73.2 详解"></a>1.1.73.2 详解</h4><p>二进制包（Binary）以及源代码包（Source）两种。二进制包可以直接安装在计算机中，而源代码包将会由 RPM自动编译、安装。源代码包经常以src.rpm作为后缀名。 </p>
<p>常用命令组合： </p>
<p>－ivh：安装显示安装进度–install–verbose–hash</p>
<p>－Uvh：升级软件包–Update；</p>
<p>－qpl： 列出RPM软件包内的文件信息[Query Package list]；</p>
<p>－qpi：列出RPM软件包的描述信息[Query Package install package(s)]；</p>
<p>－qf：查找指定文件属于哪个RPM软件包[Query File]；</p>
<p>－Va：校验所有的 RPM软件包，查找丢失的文件[View Lost]；</p>
<p>－e：删除包 </p>
<p>rpm -q samba &#x2F;&#x2F;查询程序是否安装 </p>
<p>rpm -ivh &#x2F;media&#x2F;cdrom&#x2F;RedHat&#x2F;RPMS&#x2F;samba-3.0.10-1.4E.i386.rpm &#x2F;&#x2F;按路径安装并显示进度</p>
<p>rpm -ivh –relocate &#x2F;&#x3D;&#x2F;opt&#x2F;gaim gaim-1.3.0-1.fc4.i386.rpm    &#x2F;&#x2F;指定安装目录 </p>
<p>rpm -ivh –test gaim-1.3.0-1.fc4.i386.rpm　　　 &#x2F;&#x2F;用来检查依赖关系；并不是真正的安装；</p>
<p>rpm -Uvh –oldpackage gaim-1.3.0-1.fc4.i386.rpm &#x2F;&#x2F;新版本降级为旧版本 </p>
<p>rpm -qa | grep httpd　　　　　 ＃[搜索指定rpm包是否安装]–all搜索<em>httpd</em></p>
<p>rpm -ql httpd　　　　　　　　　＃[搜索rpm包]–list所有文件安装目录 </p>
<p>rpm -qpi Linux-1.4-6.i368.rpm　＃[查看rpm包]–query–package–install package信息</p>
<p>rpm -qpf Linux-1.4-6.i368.rpm　＃[查看rpm包]–file</p>
<p>rpm -qpR file.rpm　　　　　　　＃[查看包]依赖关系</p>
<p>rpm2cpio file.rpm |cpio -div    ＃[抽出文件] </p>
<p>rpm -ivh file.rpm 　＃[安装新的rpm]–install–verbose–hash</p>
<p>rpm -ivh [url]<a target="_blank" rel="noopener" href="http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm[/url]">http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm[/url]</a> </p>
<p>rpm -Uvh file.rpm    ＃[升级一个rpm]–upgrade</p>
<p>rpm -e file.rpm      ＃[删除一个rpm包]–erase </p>
<p>常用参数： </p>
<p>Install&#x2F;Upgrade&#x2F;Erase options:</p>
<p>-i, –install                     install package(s)</p>
<p>-v, –verbose                     provide more detailed output</p>
<p>-h, –hash                        print hash marks as package installs (good with -v)</p>
<p>-e, –erase                       erase (uninstall) package</p>
<p>-U, –upgrade&#x3D;<packagefile>+      upgrade package(s)</p>
<p>－-replacepkge                    无论软件包是否已被安装，都强行安装软件包</p>
<p>–test                            安装测试，并不实际安装</p>
<p>–nodeps                          忽略软件包的依赖关系强行安装</p>
<p>–force                           忽略软件包及文件的冲突 </p>
<p>Query options (with -q or –query):</p>
<p>-a, –all                         query&#x2F;verify all packages</p>
<p>-p, –package                     query&#x2F;verify a package file</p>
<p>-l, –list                        list files in package</p>
<p>-d, –docfiles                    list all documentation files</p>
<p>-f, –file                        query&#x2F;verify package(s) owning file </p>
<p>RPM源代码包装安装 </p>
<p>.src.rpm结尾的文件，这些文件是由软件的源代码包装而成的，用户要安装这类RPM软件包，必须使用命令： </p>
<p>rpm　–recompile　vim-4.6-4.src.rpm   ＃这个命令会把源代码解包并编译、安装它，如果用户使用命令： </p>
<p>rpm　–rebuild　vim-4.6-4.src.rpm　　＃在安装完成后，还会把编译生成的可执行文件重新包装成i386.rpm 的RPM软件包。</p>
<p>[root@localhost src]# rpm -ivh awstats-6.8-1.noarch.rpm</p>
<p>error: Failed dependencies:</p>
<p>perl(LWP::UserAgent) is needed by awstats-6.8-1.noarch</p>
<p>[root@localhost src]#</p>
<p>使用rpm 属性相依套件的档案</p>
<p>[root@localhost src]# rpm -qpR awstats-6.8-1.noarch.rpm</p>
<p>&#x2F;bin&#x2F;sh</p>
<p>&#x2F;usr&#x2F;bin&#x2F;perl</p>
<p>config(awstats) &#x3D; 6.8-1</p>
<p>perl &gt;&#x3D; 0:5.005</p>
<p>perl(LWP::UserAgent)</p>
<p>perl(POSIX)</p>
<p>perl(Socket)</p>
<p>perl(Time::Local)</p>
<p>perl(strict)</p>
<p>perl(vars)</p>
<p>rpmlib(CompressedFileNames) &lt;&#x3D; 3.0.4-1</p>
<p>rpmlib(PayloadFilesHavePrefix) &lt;&#x3D; 4.0-1 </p>
<p>另外：# rpm -ivh –aid samba*.rpm (一定要安装rpmdb后才可以用这种方式安装排除依赖关系) </p>
<h4 id="1-1-73-3-RPM安装"><a href="#1-1-73-3-RPM安装" class="headerlink" title="1.1.73.3 RPM安装"></a>1.1.73.3 RPM安装</h4><p>*.libs.rpm à  其他</p>
<h3 id="1-1-74-rpmbuild"><a href="#1-1-74-rpmbuild" class="headerlink" title="1.1.74 rpmbuild"></a>1.1.74 rpmbuild</h3><p>rpmbuild –ba ‘spec文件路径’</p>
<h3 id="1-1-75-rpmdev-tools"><a href="#1-1-75-rpmdev-tools" class="headerlink" title="1.1.75 rpmdev-tools"></a>1.1.75 rpmdev-tools</h3><h4 id="1-1-75-1-rpmdev-newspec"><a href="#1-1-75-1-rpmdev-newspec" class="headerlink" title="1.1.75.1 rpmdev-newspec"></a>1.1.75.1 rpmdev-newspec</h4><h4 id="1-1-75-2-rpmdev-newinit"><a href="#1-1-75-2-rpmdev-newinit" class="headerlink" title="1.1.75.2 rpmdev-newinit"></a>1.1.75.2 rpmdev-newinit</h4><h3 id="1-1-76-sar"><a href="#1-1-76-sar" class="headerlink" title="1.1.76 sar"></a>1.1.76 sar</h3><p>System Activity Reporter系统活动情况报告</p>
<p>显示系统状态计时器</p>
<p>sar –u 2 5  报告cpu使用情况，2s每次，统计5次</p>
<p>sar –r 2 5  报告内存使用情况，2s每次，统计5次</p>
<h3 id="1-1-77-scp"><a href="#1-1-77-scp" class="headerlink" title="1.1.77 scp"></a>1.1.77 scp</h3><p>复制本地文件到远程：</p>
<p>scp localfile <a href="mailto:&#x72;&#x6f;&#111;&#x74;&#64;&#49;&#x2e;&#49;&#x2e;&#49;&#46;&#49;">&#x72;&#x6f;&#111;&#x74;&#64;&#49;&#x2e;&#49;&#x2e;&#49;&#46;&#49;</a>:&#x2F;remotefile</p>
<p>得到远程文件：</p>
<p>scp <a href="mailto:root@192.168.210.1:/remotefile">root@192.168.210.1:/remotefile</a> localfile</p>
<h3 id="1-1-78-sed"><a href="#1-1-78-sed" class="headerlink" title="1.1.78 sed"></a>1.1.78 sed</h3><p>cat &#x2F;tmp&#x2F;im_sys_log_temp | sed ‘s|($SystemLogRateLimitInterval)(.*)|\1 0 1’ &gt;&#x2F;tmp&#x2F;im_sys_log.conf</p>
<p>(  … )   保留匹配的字符</p>
<p>*         匹配零或多个字符</p>
<p>.			 匹配一个非换行符字符</p>
<h4 id="1-1-78-1-命令详解"><a href="#1-1-78-1-命令详解" class="headerlink" title="1.1.78.1 命令详解"></a>1.1.78.1 命令详解</h4><p>sed命令行格式为：</p>
<p> sed [-nefri]  ‘command’  输入文本&#x2F;文件        </p>
<p>常用选项：<br>​        -n∶取消默认的输出,使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到屏幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来<br>​        -e∶进行多项编辑，即对输入行应用多条sed命令时使用. 直接在指令列模式上进行 sed 的动作编辑<br>​        -f∶指定sed脚本的文件名. 直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作<br>​        -r∶sed 的动作支援的是延伸型正则表达式的语法。(预设是基础正则表达式语法)<br>​        -i∶直接修改读取的文件内容，而不是由屏幕输出       </p>
<p>常用命令：<br>​        a ∶ 新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)<br>​        c ∶ 取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行<br>​        d ∶ 删除，因为是删除，所以 d 后面通常不接任何内容<br>​         i ∶ 插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)<br>​         p∶ 列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起用<br>​         s∶ 取代，可以直接进行替换的工作。通常这个 s 的动作可以搭配正则表达式。例如 1,20s&#x2F;old&#x2F;new&#x2F;g </p>
<p><strong>定址</strong></p>
<p>定址用于决定对哪些行进行编辑。地址的形式可以是数字、正则表达式、或二者的结合。如果没有指定地址，sed将处理输入文件的所有行。 </p>
<p>地址是一个数字，则表示行号；是“$”符号，则表示最后一行。例如：  </p>
<p>  只显示指定行范围的文件内容，例如： </p>
<p># 只查看文件的第100行到第200行</p>
<p>sed -n ‘100,200p’ mysql_slow_query.log</p>
<p>  地址是逗号分隔的，那么需要处理的地址是这两行之间的范围（包括这两行在内）。范围可以用数字、正则表达式、或二者的组合表示。例如： </p>
<h4 id="1-1-78-2-举例：（假设我们有一文件名为ab）"><a href="#1-1-78-2-举例：（假设我们有一文件名为ab）" class="headerlink" title="1.1.78.2 举例：（假设我们有一文件名为ab）"></a>1.1.78.2 举例：（假设我们有一文件名为ab）</h4><h5 id="1-1-78-2-1-删除某行"><a href="#1-1-78-2-1-删除某行" class="headerlink" title="1.1.78.2.1 删除某行"></a>1.1.78.2.1 删除某行</h5><p>​     [root@localhost ruby] # sed ‘1d’ ab              #删除第一行<br>​     [root@localhost ruby] # sed ‘$d’ ab              #删除最后一行<br>​     [root@localhost ruby] # sed ‘1,2d’ ab           #删除第一行到第二行<br>​     [root@localhost ruby] # sed ‘2,$d’ ab           #删除第二行到最后一行</p>
<h5 id="1-1-78-2-2-显示某行"><a href="#1-1-78-2-2-显示某行" class="headerlink" title="1.1.78.2.2 显示某行"></a>1.1.78.2.2 显示某行</h5><p>  [root@localhost ruby] # sed -n ‘1p’ ab           #显示第一行<br>​     [root@localhost ruby] # sed -n ‘$p’ ab           #显示最后一行<br>​     [root@localhost ruby] # sed -n ‘1,2p’ ab        #显示第一行到第二行<br>​     [root@localhost ruby] # sed -n ‘2,$p’ ab        #显示第二行到最后一行</p>
<h5 id="1-1-78-2-3-使用模式进行查询"><a href="#1-1-78-2-3-使用模式进行查询" class="headerlink" title="1.1.78.2.3 使用模式进行查询"></a>1.1.78.2.3 使用模式进行查询</h5><p> [root@localhost ruby] # sed -n ‘&#x2F;ruby&#x2F;p’ ab    #查询包括关键字ruby所在所有行<br>​     [root@localhost ruby] # sed -n ‘&#x2F;$&#x2F;p’ ab        #查询包括关键字$所在所有行，使           用反斜线\屏蔽特殊含义</p>
<h5 id="1-1-78-2-4-增加一行或多行字符串"><a href="#1-1-78-2-4-增加一行或多行字符串" class="headerlink" title="1.1.78.2.4 增加一行或多行字符串"></a>1.1.78.2.4 增加一行或多行字符串</h5><p>​     [root@localhost ruby]# cat ab<br>​     Hello!<br>​     ruby is me,welcome to my blog.<br>​     end<br>​     [root@localhost ruby] # sed ‘1a drink tea’ ab  #第一行后增加字符串”drink tea”<br>​     Hello!<br>​     drink tea<br>​     ruby is me,welcome to my blog.<br>​     end<br>​     [root@localhost ruby] # sed ‘1,3a drink tea’ ab #第一行到第三行后增加字符串”drink tea”**     Hello!<br>​     drink tea<br>​     ruby is me,welcome to my blog.<br>​     drink tea<br>​     end<br>​     drink tea<br>​     [root@localhost ruby] # sed ‘1a drink tea\nor coffee’ ab   #第一行后增加多行，使用换行符\n<br>​     Hello!<br>​     drink tea<br>​     or coffee<br>​     ruby is me,welcome to my blog.<br>​     end</p>
<h5 id="1-1-78-2-5-代替一行或多行"><a href="#1-1-78-2-5-代替一行或多行" class="headerlink" title="1.1.78.2.5 代替一行或多行"></a>1.1.78.2.5 代替一行或多行</h5><p>​    [root@localhost ruby] # sed ‘1c Hi’ ab                #第一行代替为Hi<br>​     Hi<br>​     ruby is me,welcome to my blog.<br>​     end<br>​     [root@localhost ruby] # sed ‘1,2c Hi’ ab             #第一行到第二行代替为Hi<br>​     Hi<br>​     end</p>
<h5 id="1-1-78-2-6-替换一行中的某部分"><a href="#1-1-78-2-6-替换一行中的某部分" class="headerlink" title="1.1.78.2.6 替换一行中的某部分"></a>1.1.78.2.6 替换一行中的某部分</h5><p>格式：sed ‘s&#x2F;要替换的字符串&#x2F;新的字符串&#x2F;g’   （要替换的字符串可以用正则表达式）<br>​     [root@localhost ruby] # sed -n ‘&#x2F;ruby&#x2F;p’ ab | sed ‘s&#x2F;ruby&#x2F;bird&#x2F;g’    #替换ruby为bird<br>　  [root@localhost ruby] # sed -n ‘&#x2F;ruby&#x2F;p’ ab | sed ‘s&#x2F;ruby&#x2F;&#x2F;g’        #删除ruby</p>
<p>​     插入<br>​     [root@localhost ruby] # sed -i ‘$a bye’ ab         #在文件ab中最后一行直接输入”bye”<br>​     [root@localhost ruby]# cat ab<br>​     Hello!<br>​     ruby is me,welcome to my blog.<br>​     end<br>​     bye</p>
<h4 id="1-1-78-3-替换"><a href="#1-1-78-3-替换" class="headerlink" title="1.1.78.3  替换"></a>1.1.78.3  替换</h4><p>-e是编辑命令，用于sed执行多个编辑任务的情况下。在下一行开始编辑前，所有的编辑动作将应用到模式缓冲区中的行上。</p>
<p>sed -e ‘1,10d’ -e ‘s&#x2F;My&#x2F;Your&#x2F;g’ datafile</p>
<p>#选项-e用于进行多重编辑。第一重编辑删除第1-3行。第二重编辑将出现的所有My替换为Your。因为是逐行进行这两项编辑（即这两个命令都在模式空间的当前行上执行），所以编辑命令的顺序会影响结果。</p>
<p># 替换两个或多个空格为一个空格   sed ‘s&#x2F;[ ][ ]*&#x2F; &#x2F;g’ file_name</p>
<p># 替换两个或多个空格为分隔符:    sed ‘s&#x2F;[ ][ ]*&#x2F;:&#x2F;g’ file_name</p>
<p># 如果空格与tab共存时用下面的命令进行替换</p>
<p># 替换成空格 sed ‘s&#x2F;[[:space:]][[:space:]]*&#x2F; &#x2F;g’ filename</p>
<p># 替换成分隔符:  sed ‘s&#x2F;[[:space:]][[:space:]]*&#x2F;:&#x2F;g’ filename</p>
<h4 id="1-1-78-4-sed命令的调用"><a href="#1-1-78-4-sed命令的调用" class="headerlink" title="1.1.78.4 sed命令的调用"></a>1.1.78.4 sed命令的调用</h4><p>在命令行键入命令;将sed命令插入脚本文件,然后调用sed;将sed命令插入脚本文件,并使sed脚本可执行<br>​    sed [option] sed命令 输入文件            在命令行使用sed命令,实际命令要加单引号<br>​    sed [option] -f sed脚本文件 输入文件     使用sed脚本文件<br>​    sed脚本文件 [option] 输入文件            第一行具有sed命令解释器的sed脚本文件<br>​    option如下:<br>​      n 不打印; sed不写编辑行到标准输出,缺省为打印所有行(编辑和未编辑),p命令可以用来打印编辑行<br>​      c 下一命令是编辑命令,使用多项编辑时加入此选项<br>​      f 如果正在调用sed脚本文件,使用此选项,此选项通知sed一个脚本文件支持所用的sed命令,如<br>​          sed -f myscript.sed input_file  这里myscript.sed即为支持sed命令的文件<br>​    使用重定向文件即可保存sed的输出</p>
<p><strong>使用sed在文本中定位文本的方式</strong>:<br>​    x       x为一行号,比如1<br>​    x,y     表示行号范围从x到y,如2,5表示从第2行到第5行<br>​    &#x2F;pattern&#x2F;    查询包含模式的行,如&#x2F;disk&#x2F;或&#x2F;[a-z]&#x2F;<br>​    &#x2F;pattern&#x2F;pattern&#x2F;   查询包含两个模式的行,如&#x2F;disk&#x2F;disks&#x2F;<br>​    &#x2F;pattern&#x2F;,x  在给定行号上查询包含模式的行,如&#x2F;disk&#x2F;,3<br>​    x,&#x2F;pattern&#x2F;  通过行号和模式查询匹配行,如 3,&#x2F;disk&#x2F;<br>​    x,y!    查询不包含指定行号x和y的行</p>
<p><strong>基本sed编辑命令</strong>:<br>​    p      打印匹配行                      </p>
<p>c&#x2F;    用新文本替换定位文本<br>​    &#x3D;      显示文件行号                    </p>
<p>s     使用替换模式替换相应模式<br>​    a&#x2F;     在定位行号后附加新文本信息        </p>
<p>r     从另一个文本中读文本<br>​    i&#x2F;     在定位行号后插入新文本信息        </p>
<p>w     写文本到一个文件<br>​    d      删除定位行                     </p>
<p> q     第一个模式匹配完成后退出或立即退出<br>​    l      显示与八进制ASCII代码等价的控制字符        y  传送字符<br>​    n      从另一个文本中读文本下一行,并附加在下一行   {}     在定位行执行的命令组<br>​    g      将模式2粘贴到&#x2F;pattern n&#x2F;</p>
<p><strong>基本sed编程举例</strong>:<br>​    使用p(rint)显示行: sed -n ‘2p’ temp.txt   只显示第2行,使用选项n<br>​    打印范围:  sed -n ‘1,3p’ temp.txt         打印第1行到第3行<br>​    打印模式:  sed -n ‘&#x2F;movie&#x2F;‘p temp.txt     打印含movie的行<br>​    使用模式和行号查询:  sed -n ‘3,&#x2F;movie&#x2F;‘p temp.txt   只在第3行查找movie并打印<br>​    显示整个文件:  sed -n ‘1,$’p temp.txt      $为最后一行<br>​    任意字符:  sed -n ‘&#x2F;.<em>ing&#x2F;‘p temp.txt     注意是.<em>ing,而不是</em>ing<br>​    打印行号:  sed -e ‘&#x2F;music&#x2F;&#x3D;’ temp.txt<br>​    附加文本:(创建sed脚本文件)chmod u+x script.sed,运行时.&#x2F;script.sed temp.txt<br>​        #!&#x2F;bin&#x2F;sed -f<br>​        &#x2F;name1&#x2F; a&#x2F;             #a&#x2F;表示此处换行添加文本<br>​        HERE ADD NEW LINE.     #添加的文本内容<br>​    插入文本: &#x2F;name1&#x2F; a&#x2F; 改成 4 i&#x2F; 4表示行号,i插入<br>​    修改文本: &#x2F;name1&#x2F; a&#x2F; 改成 &#x2F;name1&#x2F; c&#x2F; 将修改整行,c修改<br>​    删除文本: sed ‘1d’ temp.txt  或者 sed ‘1,4d’ temp.txt<br>​    替换文本: sed ‘s&#x2F;source&#x2F;OKSTR&#x2F;‘ temp.txt     将source替换成OKSTR<br>​             sed ‘s&#x2F;&#x2F;$&#x2F;&#x2F;g’ temp.txt             将文本中所有的$符号全部删除<br>​             sed ‘s&#x2F;source&#x2F;OKSTR&#x2F;w temp2.txt’ temp.txt 将替换后的记录写入文件temp2.txt<br>​    替换修改字符串: sed ‘s&#x2F;source&#x2F;“ADD BEFORE” &amp;&#x2F;p’ temp.txt<br>​             结果将在source字符串前面加上”ADD BEFORE”,这里的&amp;表示找到的source字符并保存<br>​    sed结果写入到文件: sed ‘1,2 w temp2.txt’ temp.txt<br>​                     sed ‘&#x2F;name&#x2F; w temp2.txt’ temp.txt<br>​    从文件中读文本: sed ‘&#x2F;name&#x2F;r temp2.txt’ temp.txt<br>​    在每列最后加文本: sed ‘s&#x2F;[0-9]</em>&#x2F;&amp; Pass&#x2F;g’ temp.txt<br>​    从shell向sed传值: echo $NAME | sed “s&#x2F;go&#x2F;$REP&#x2F;g”   注意需要使用双引号</p>
<p><strong>快速一行命令</strong>:<br>​    ‘s&#x2F;&#x2F;.$&#x2F;&#x2F;g’         删除以句点结尾行<br>​    ‘-e &#x2F;abcd&#x2F;d’       删除包含abcd的行<br>​    ‘s&#x2F;[][][]<em>&#x2F;[]&#x2F;g’   删除一个以上空格,用一个空格代替<br>​    ‘s&#x2F;^[][]</em>&#x2F;&#x2F;g’      删除行首空格<br>​    ‘s&#x2F;&#x2F;.[][]*&#x2F;[]&#x2F;g’   删除句号后跟两个或更多的空格,用一个空格代替<br>​    ‘&#x2F;^$&#x2F;d’            删除空行<br>​    ‘s&#x2F;^.&#x2F;&#x2F;g’          删除第一个字符,区别  ‘s&#x2F;&#x2F;.&#x2F;&#x2F;g’删除所有的句点<br>​    ‘s&#x2F;COL&#x2F;(…&#x2F;)&#x2F;&#x2F;g’  删除紧跟COL的后三个字母<br>​    ‘s&#x2F;^&#x2F;&#x2F;&#x2F;&#x2F;g’         删除路径中第一个&#x2F;</p>
<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<p><strong>、使用句点匹配单字符</strong>    句点“.”可以匹配任意单字符。“.”可以匹配字符串头，也可以是中间任意字符。假定正在过滤一个文本文件，对于一个有1 0个字符的脚本集，要求前4个字符之后为X C，匹配操作如下：. . . .X C. . . .<br><strong>2、在行首以^匹配字符串或字符序列</strong>    ^只允许在一行的开始匹配字符或单词。在行首第4个字符为1，匹配操作表示为：^ . . . 1<br><strong>3、在行尾以$匹配字符串或字符</strong>    可以说$与^正相反，它在行尾匹配字符串或字符， $符号放在匹配单词后。如果在行尾匹配单词j e t 0 1，操作如下：j e t 0 1 $    如果只返回包含一个字符的行，操作如下：^ . $<br><strong>4、使用*匹配字符串中的单字符或其重复序列</strong>    使用此特殊字符匹配任意字符或字符串的重复多次表达式。<br><strong>5、使用&#x2F;屏蔽一个特殊字符的含义</strong>    有时需要查找一些字符或字符串，而它们包含了系统指定为特殊字符的一个字符。如果要在正则表达式中匹配以* . p a s结尾的所有文件，可做如下操作：&#x2F; * &#x2F; . p a s<br><strong>6、使用[]匹配一个范围或集合</strong>     使用[ ]匹配特定字符串或字符串集，可以用逗号将括弧内要匹配的不同字符串分开，但并不强制要求这样做（一些系统提倡在复杂的表达式中使用逗号），这样做可以增 加模式的可读性。使用“ -”表示一个字符串范围，表明字符串范围从“ -”左边字符开始，到“ -”右边字符结束。假定要匹配任意一个数字，可以使用：[ 0 1 2 3 4 5 6 7 8 9 ]    要匹配任意字母，则使用：[ A - Z a - z ]表明从A - Z、a - z的字母范围。<br><strong>7、使用&#x2F;{&#x2F;}匹配模式结果出现的次数</strong>    使用*可匹配所有匹配结果任意次，但如果只要指定次数，就应使用&#x2F; { &#x2F; }，此模式有三种形式，即：<br>​    pattern&#x2F;{n&#x2F;} 匹配模式出现n次。<br>​    pattern&#x2F;{n,&#x2F;} 匹配模式出现最少n次。<br>​    pattern&#x2F;{n,m} 匹配模式出现n到m次之间，n , m为0 - 2 5 5中任意整数。<br>​    匹配字母A出现两次，并以B结尾，操作如下：A &#x2F; { 2 &#x2F; } B匹配值为A A B    匹配A至少4次，使用：A &#x2F; { 4 , &#x2F; } B</p>
<p>替换单引号为空：</p>
<p>可以这样写：</p>
<p>sed ‘s&#x2F;‘“‘“‘&#x2F;&#x2F;g’ </p>
<p>sed ‘s&#x2F;‘&#39;‘&#x2F;&#x2F;g’</p>
<p>sed s&#x2F;&#39;&#x2F;&#x2F;g</p>
<h4 id="1-1-78-5-示例"><a href="#1-1-78-5-示例" class="headerlink" title="1.1.78.5 示例"></a>1.1.78.5 示例</h4><p>将&#x2F;root&#x2F;Desktop&#x2F;testsed下的各个文件中的test1替换为test1-1</p>
<p>sed -i ‘s&#x2F;test1&#x2F;test1-1&#x2F;g’ <code>grep test1 -rl /root/Desktop/testsed</code></p>
<h4 id="1-1-78-6-替换路径"><a href="#1-1-78-6-替换路径" class="headerlink" title="1.1.78.6 替换路径"></a>1.1.78.6 替换路径</h4><p>echo “&#x2F;home&#x2F;”|sed “s:&#x2F;home:&#x2F;root:”</p>
<p>​    输出：&#x2F;root&#x2F;</p>
<h4 id="1-1-78-7-应用"><a href="#1-1-78-7-应用" class="headerlink" title="1.1.78.7 应用"></a>1.1.78.7 应用</h4><p>一、从第3000行开始，显示1000行。即显示3000~3999行<br>cat filename | tail -n +3000 | head -n 1000<br> 二、显示1000行到3000行<br>cat filename| head -n 3000 | tail -n +1000<br> 注意两种方法的顺序<br> 分解：<br>​    tail -n 1000：显示最后1000行<br>​    tail -n +1000：从1000行开始显示，显示1000行以后的<br>​    head -n 1000：显示前面1000行<br> 三、用sed命令<br>  sed -n ‘5,10p’ filename 这样就可以只查看文件的第5行到第10行。</p>
<p>昨天写一个脚本花了一天的2&#x2F;3的时间，而且大部分时间都耗在了sed命令上，今天不总结一下都对不起昨天流逝的时间啊~~~</p>
<p>用sed命令在行首或行尾添加字符的命令有以下几种：<br>假设处理的文本为test.file<br><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps5.jpg" alt="img"><br>在每行的头添加字符，比如”HEAD”，命令如下：<br>sed ‘s&#x2F;^&#x2F;HEAD&amp;&#x2F;g’ test.file<br>在每行的行尾添加字符，比如“TAIL”，命令如下：<br>sed ‘s&#x2F;$&#x2F;&amp;TAIL&#x2F;g’ test.file<br>运行结果如下图：<br><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps6.jpg" alt="img"><br>几点说明：<br>1.”^”代表行首，”$”代表行尾<br>2.’s&#x2F;$&#x2F;&amp;TAIL&#x2F;g’中的字符g代表每行出现的字符全部替换，如果想在特定字符处添加，g就有用了，否则只会替换每行第一个，而不继续往后找了<br>例：<br><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps7.jpg" alt="img"><br>3.如果想导出文件，在命令末尾加”&gt; outfile_name”；如果想在原文件上更改，添加选项”-i”，如<br><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps8.jpg" alt="img"><br>4.也可以把两条命令和在一起，在test.file的每一行的行头和行尾分别添加字符”HEAD”、“TAIL”，命令：sed ‘&#x2F;.&#x2F;{s&#x2F;^&#x2F;HEAD&amp;&#x2F;;s&#x2F;$&#x2F;&amp;TAIL&#x2F;}’ test.file<br>以上其实都还OK，昨天花太多时间，主要因为被处理的文件是用<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/mysql"><strong>MySQL</strong></a>从<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/mysql"><strong>数据库</strong></a>提取的结果导出来的，别人给我之后我就直接处理，太脑残了&#x3D; -我一直有点怀疑之所以结果不对，有可能是windows和<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/linux"><strong>Linux</strong></a>换行的问题，可是因为对sed不熟，就一直在搞sed。。。。。。。<br>众所周知（&#x3D; -），window和linux的回车换行之云云，如果你知道了，跳过这一段，不知道，读一下呗：<br>Unix系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows系统里面，每行结尾是“&lt;换行&gt;&lt;回 车&gt;”，即“\n\r”。一个直接后果是，Unix系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix下打开的话，在每行的结尾可能会多出一个^M符号。<br>好了，所以我的问题就出在被处理的文件的每行末尾都有^M符号，而这通常是看不出来的。可以用”cat -A test.file”命令查看。因此当我想在行尾添加字符的时候，它总是添加在行首且会覆盖掉原来行首的字符。<br>要把文件转换一下，有两种方法：<br>1.命令dos2unix test.file<br>2.去掉”\r” ，用命令sed -i ‘s&#x2F;\r&#x2F;&#x2F;‘ test.file</p>
<p>好了，这样处理完，就OK啦！！！</p>
<h3 id="1-1-79-setup"><a href="#1-1-79-setup" class="headerlink" title="1.1.79 setup"></a>1.1.79 setup</h3><p>设置系统参数</p>
<h3 id="1-1-80-slabtop"><a href="#1-1-80-slabtop" class="headerlink" title="1.1.80 slabtop"></a>1.1.80 slabtop</h3><p><strong>slabtop命令</strong>以实时的方式显示内核“slab”缓冲区的细节信息。</p>
<h3 id="1-1-81-ss"><a href="#1-1-81-ss" class="headerlink" title="1.1.81 ss"></a>1.1.81 ss</h3><p>查看活动状态的套接字信息</p>
<h3 id="1-1-82-strace"><a href="#1-1-82-strace" class="headerlink" title="1.1.82 strace"></a>1.1.82 strace</h3><p>跟踪进程</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps9.jpg" alt="img"> </p>
<h3 id="1-1-83-strings"><a href="#1-1-83-strings" class="headerlink" title="1.1.83 strings"></a>1.1.83 strings</h3><p>在对象文件或二进制文件中查找可打印的字符串</p>
<h3 id="1-1-84-sync"><a href="#1-1-84-sync" class="headerlink" title="1.1.84 sync"></a>1.1.84 sync</h3><p>刷新系统缓存</p>
<h3 id="1-1-85-su-x2F-sudo"><a href="#1-1-85-su-x2F-sudo" class="headerlink" title="1.1.85 su&#x2F;sudo"></a>1.1.85 su&#x2F;sudo</h3><p>su切换用户</p>
<p>sudo以其他用户执行</p>
<h3 id="1-1-86-tar"><a href="#1-1-86-tar" class="headerlink" title="1.1.86 tar"></a>1.1.86 tar</h3><p>tar	 -cvzf	test.tar.gz	test&#x2F;	将当前目录下的test文件夹打包并压缩成gzip格式，</p>
<p>tar	 -xvzf 	 test.tar.gz </p>
<p>​	x		解压文件 extract</p>
<p>c 		打包文件 compress</p>
<p>v		显示详细过程  vision</p>
<p>z		gzip，使用gzip压缩</p>
<p>j		bz2格式</p>
<p>f		指定文件</p>
<p>-P    压缩时携带路径信息</p>
<p>tar	-cvzf	a.tar.gz		-C		&#x2F;		压到指定目录用-C</p>
<p>tar   cvPf  a.tar.gz  &#x2F;opt&#x2F;test</p>
<p>如果打包时带了路径，采用tar –xvPf解压时可恢复到对应路径</p>
<h3 id="1-1-87-time"><a href="#1-1-87-time" class="headerlink" title="1.1.87 time"></a>1.1.87 time</h3><p>指定程序需要运行的时间</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps10.jpg" alt="img"> </p>
<h3 id="1-1-88-top"><a href="#1-1-88-top" class="headerlink" title="1.1.88 top"></a>1.1.88 top</h3><p>监视进程运行情况</p>
<p>-p 指定的进程</p>
<p>top –p 123,134</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps11.png" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps12.png" alt="img"></p>
<h3 id="1-1-89-touch"><a href="#1-1-89-touch" class="headerlink" title="1.1.89 touch"></a>1.1.89 touch</h3><p>新建指定名称的文件或更新文件时间戳</p>
<h3 id="1-1-90-tr"><a href="#1-1-90-tr" class="headerlink" title="1.1.90 tr"></a>1.1.90 tr</h3><p>将字符进行替换或删除</p>
<h3 id="1-1-91-tree"><a href="#1-1-91-tree" class="headerlink" title="1.1.91 tree"></a>1.1.91 tree</h3><p>列出目录树</p>
<p>-a  列出所有文件</p>
<p>-d  只列出目录</p>
<p>-f  列出文件的完整目录</p>
<p>-I  去掉输出中的导引线</p>
<p>-L level  只列出到第level层子目录</p>
<p>tree	&#x2F;boot&#x2F;	-p	*.conf		在..目录下，以.conf结尾的文件以树状显示</p>
<h3 id="1-1-92-wall"><a href="#1-1-92-wall" class="headerlink" title="1.1.92 wall"></a>1.1.92 wall</h3><p>向当前机器所有用户广播信息</p>
<p>wall   “hello”</p>
<h3 id="1-1-93-write"><a href="#1-1-93-write" class="headerlink" title="1.1.93 write"></a>1.1.93 write</h3><p>向某个用户发送消息</p>
<p>write hytera(用户) </p>
<p>hello</p>
<h3 id="1-1-94-whatis"><a href="#1-1-94-whatis" class="headerlink" title="1.1.94 whatis"></a>1.1.94 whatis</h3><p>查询某个条目出现在手册的哪些节中。</p>
<h3 id="1-1-95-which"><a href="#1-1-95-which" class="headerlink" title="1.1.95 which"></a>1.1.95 which</h3><p>查找程序所在位置</p>
<p>如：which ls   &#x2F;usr&#x2F;bin&#x2F;ls</p>
<h3 id="1-1-96-wc"><a href="#1-1-96-wc" class="headerlink" title="1.1.96 wc"></a>1.1.96 wc</h3><p>查看文件信息命令</p>
<p>文件的文本行数  文件的字数  文件的字符数</p>
<h3 id="1-1-97-xxd"><a href="#1-1-97-xxd" class="headerlink" title="1.1.97 xxd"></a>1.1.97 xxd</h3><p>读取二进制文件，以二进制显示</p>
<p>Hexdump 以16进制显示</p>
<h3 id="1-1-98-yum"><a href="#1-1-98-yum" class="headerlink" title="1.1.98 yum"></a>1.1.98 yum</h3><p>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</p>
<p>yum install package_name 下载并安装一个rpm包</p>
<p>yum	-Y	install		gcc-c++		安装gcc-c++</p>
<p>​		-Y：不需要用户确认发生的动作</p>
<h3 id="1-1-99-zip-x2F-uzip"><a href="#1-1-99-zip-x2F-uzip" class="headerlink" title="1.1.99 zip&#x2F;uzip"></a>1.1.99 zip&#x2F;uzip</h3><p>zip		jack		jack.doc		</p>
<p>uzip	jack	.zip</p>
<h3 id="1-1-100-uname"><a href="#1-1-100-uname" class="headerlink" title="1.1.100 uname"></a>1.1.100 uname</h3><p>显示系统信息	</p>
<p>-a  显示所有信息</p>
<p>-r   显示内核版本信息</p>
<p>-m  机器硬件名称</p>
<h3 id="1-1-101-uptime"><a href="#1-1-101-uptime" class="headerlink" title="1.1.101 uptime"></a>1.1.101 uptime</h3><p>显示Linux负载信息</p>
<h3 id="1-1-102-useradd"><a href="#1-1-102-useradd" class="headerlink" title="1.1.102 useradd"></a>1.1.102 useradd</h3><p>useradd  smart   添加smart用户</p>
<h3 id="1-1-103-vmstat命令"><a href="#1-1-103-vmstat命令" class="headerlink" title="1.1.103 vmstat命令"></a>1.1.103 vmstat命令</h3><p><strong>vmstat命令</strong>的含义为显示虚拟内存状态（“Viryual Memor Statics”），但是它可以报告关于进程、内存、I&#x2F;O等系统整体运行状态。 </p>
<h4 id="1-1-103-1-语法"><a href="#1-1-103-1-语法" class="headerlink" title="1.1.103.1 语法"></a>1.1.103.1 语法</h4><p>vmstat(选项)(参数)</p>
<h4 id="1-1-103-2-选项"><a href="#1-1-103-2-选项" class="headerlink" title="1.1.103.2 选项"></a>1.1.103.2 选项</h4><p>-a：显示活动内页；</p>
<p>-f：显示启动后创建的进程总数；</p>
<p>-m：显示slab信息；</p>
<p>-n：头信息仅显示一次；</p>
<p>-s：以表格方式显示事件计数器和内存状态；</p>
<p>-d：报告磁盘状态；</p>
<p>-p：显示指定的硬盘分区状态；</p>
<p>-S：输出信息的单位。</p>
<h4 id="1-1-103-3-参数"><a href="#1-1-103-3-参数" class="headerlink" title="1.1.103.3 参数"></a>1.1.103.3 参数</h4><p>Ø 事件间隔：状态信息刷新的时间间隔； </p>
<p>Ø 次数：显示报告的次数。 </p>
<h4 id="1-1-103-4-实例"><a href="#1-1-103-4-实例" class="headerlink" title="1.1.103.4 实例"></a>1.1.103.4 实例</h4><p>vmstat 3</p>
<p>procs ———–memory———- —swap– —–io—- –system– —–cpu——</p>
<p> r  b   swpd   <a target="_blank" rel="noopener" href="http://man.linuxde.net/free">free</a>   buff  cache   si   so    bi    bo   in   cs us sy <a target="_blank" rel="noopener" href="http://man.linuxde.net/id">id</a> wa st</p>
<p> 0  0    320  42188 167332 1534368    0    0     4     7    1    0  0  0 99  0  0</p>
<p> 0  0    320  42188 167332 1534392    0    0     0     0 1002   39  0  0 100  0  0</p>
<p> 0  0    320  42188 167336 1534392    0    0     0    19 1002   44  0  0 100  0  0</p>
<p> 0  0    320  42188 167336 1534392    0    0     0     0 1002   41  0  0 100  0  0</p>
<p> 0  0    320  42188 167336 1534392    0    0     0     0 1002   41  0  0 100  0  0</p>
<h4 id="1-1-103-5-字段说明："><a href="#1-1-103-5-字段说明：" class="headerlink" title="1.1.103.5 字段说明："></a>1.1.103.5 字段说明：</h4><p>Procs（进程） </p>
<p>· r: 运行队列中进程数量，这个值也可以判断是否需要增加CPU。（长期大于1） </p>
<p>· b: 等待IO的进程数量。 </p>
<p>Memory（内存） </p>
<p>· swpd: 使用虚拟内存大小，如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。 </p>
<p>· free: 空闲物理内存大小。 </p>
<p>· buff: 用作缓冲的内存大小。 </p>
<p>· cache: 用作缓存的内存大小，如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。 </p>
<p>Swap </p>
<p>· si: 每秒从交换区写到内存的大小，由磁盘调入内存。 </p>
<p>· so: 每秒写入交换区的内存大小，由内存调入磁盘。 </p>
<p>注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。 </p>
<p>IO（现在的Linux版本块的大小为1kb） </p>
<p>· bi: 每秒读取的块数 </p>
<p>· bo: 每秒写入的块数 </p>
<p>注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。 </p>
<p>system（系统） </p>
<p>· in: 每秒中断数，包括时钟中断。 </p>
<p>· cs: 每秒上下文切换数。 </p>
<p>注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。 </p>
<p>CPU（以百分比表示） </p>
<p>· us: 用户进程执行时间百分比(user <a target="_blank" rel="noopener" href="http://man.linuxde.net/time">time</a>) </p>
<p>us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。 </p>
<p>· sy: 内核系统进程执行时间百分比(system time) </p>
<p>sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。 </p>
<p>· wa: IO等待时间百分比 </p>
<p>wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。 </p>
<p>· id: 空闲时间百分比 </p>
<h3 id="1-1-104-排除某个目录或文件"><a href="#1-1-104-排除某个目录或文件" class="headerlink" title="1.1.104 排除某个目录或文件"></a>1.1.104 排除某个目录或文件</h3><p>$:tree test</p>
<p>test</p>
<p>├── a</p>
<p>├── b</p>
<p>│   └── c</p>
<p>├── c</p>
<p>└── d</p>
<p>tar –cvzf test.tar.gz –exclude&#x3D;{test&#x2F;b,test&#x2F;c} test </p>
<h3 id="1-1-105-删除除某个文件外的文件"><a href="#1-1-105-删除除某个文件外的文件" class="headerlink" title="1.1.105 删除除某个文件外的文件"></a>1.1.105 删除除某个文件外的文件</h3><p>rm –rf  <code>ls|grep –v “hello.c”</code></p>
<h3 id="1-1-106-Linux反选删除文件汇总"><a href="#1-1-106-Linux反选删除文件汇总" class="headerlink" title="1.1.106 Linux反选删除文件汇总"></a>1.1.106 Linux反选删除文件汇总</h3><p>最简单的方法是</p>
<p># shopt -s extglob      （打开extglob模式）</p>
<p># rm -fr !(file1)</p>
<p>如果是多个要排除的，可以这样：</p>
<p># rm -rf !(file1|file2) </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps13.jpg" alt="img"> </p>
<p>Linuxrm删除指定文件外的其他文件方法汇总</p>
<p>一、Linux下删除文件和文件夹常用命令如下： 删除文件： rm file<br>删除文件夹： rm -rf dir<br>需要注意的是， rmdir 只能够删除 空文件夹。 二、删除制定文件（夹）之外的所有文件呢？<br>1、方法1，比较麻烦的做法是：<br>复制需要保留的文件到其他文件夹，然后将该目录删除， 然后将需要保留的移动 回来。 mv keep ..&#x2F; #保留文件（夹） keep<br>rm -rf * #删除当前文件夹里的所有文件 mv ..&#x2F;keep .&#x2F; #将原来的东西移动回来<br>2、方法2，需要在当前文件夹中进行:<br>rm -rf !(keep) #删除keep文件之外的所有文件<br>rm -rf !(keep1 | keep2) #删除keep1和keep2文件之外的所有文件<br>3、方法3，当前文件夹中结合使用grep和xargs来处理文件名： ls | grep -v keep | xargs rm #删除keep文件之外的所有文件<br>说明： ls先得到当前的所有文件和文件夹的名字， grep -v keep，进行grep正则匹配查找keep，-v参数决定了结果为匹配之外的结果，也就是的到了keep之外的所有文件名，然后 xargs用于从 标准输入获得参数 并且传递给后面的命令，这里使用的命令是 rm，然后由rm删除前面选择的文件。<br>好处：使用了grep来正则表达式来匹配文件名字，可以一次保留多个文件，从而进行更加准确的处理。<br>4、方法4，使用find命令代替ls，改进方法3从而能够处理制定文件夹的文件：<br>find .&#x2F;test&#x2F; | grep -v keep | xargs rm #删除当前test文件夹中keep文件之外的所有文件<br>说明，用grep而不用find -name选取名字，因为find选取名字时比较麻烦，对正则表达式支持不够，无法排除指定文件名。<br>5、方法5，直接使用find命令删除其他文件：<br>find .&#x2F; -name ‘[^k][^e][^e][^p]<em>‘  -exec rm -rf {} ; #删除keep以外的其他文件。 find .&#x2F; -name ‘[^k][^e][^e][^p]</em>‘  | xargs rm -rf  #删除keep以外的其他文件。推荐！<br>说明：上面第二行的代码效率高些，原因在于删除多个文件时 -exec会启动多个进程来处理，而xargs会启动一个rm进程来处理。<br>关于find 执行命令的效率和借用xargs启动的命令效率的比较，详情请参考：<a target="_blank" rel="noopener" href="http://www.linuxsir.org/main/?q=node/137">http://www.linuxsir.org/main/?q=node/137</a><br>Linux文件查找命令find,xargs详述  <a target="_blank" rel="noopener" href="http://www.linuxsir.org/main/?q=node/137">http://www.linuxsir.org/main/?q=node/137</a> 本文转载自：<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_70ffb5c501011rrk.html">http://blog.sina.com.cn/s/blog_70ffb5c501011rrk.html</a></p>
<p>rm删除除去指定文件的剩余所有文件  (rm 反向删除）</p>
<p>zhou@zhou:<del>&#x2F;LinuxC&#x2F;file&#x2F;test$ ls<br>1  23sdfwe 88888888  aabb ag   ghdda    mmm<br>2 3       aaaaaaaa abc  asdg  llllllll wwwww<br>zhou@zhou:</del>&#x2F;LinuxC&#x2F;file&#x2F;test$<br>然后我想删除除了包含字符串aa外所有的文件，也就是想留下aabb，aaaaaaaa，这两个文件，<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_67e34ceb01014930.html"><strong>其他</strong></a>的全部删除<br>下面是我的命令：<br>zhou@zhou:<del>&#x2F;LinuxC&#x2F;file&#x2F;test$ <strong>rm <code>ls | grep -v&quot;aa&quot;</code></strong><br>zhou@zhou:</del>&#x2F;LinuxC&#x2F;file&#x2F;test$ ls<br>aaaaaaaa  aabb<br>zhou@zhou:~&#x2F;LinuxC&#x2F;file&#x2F;test$<br>所以了，成功了。<br>简单的解释一下那条命令吧：rm 删除后面指定的文件<br><code>ls | grep -v &quot;aa&quot; </code> 记得外面是反引号（<strong>反引号的位置就在标准键盘的数字1的左边）</strong>， </p>
<p>ls：查看当前目录下所有的文件，使用grep命令过滤一下grep -v “aa” 就是找出字符串中不带“aa”的。<br>整体再顺一下：列出文件名不带“aa”串的文件，然后删除他们。OK。<br>其实说起来简单，当时我也做了好长时间，因为以前没怎么接触grep，因此一开始我想到的办法是使用<strong>正则表</strong>****<strong>达式</strong>，但是在做的过程中突然发现了grep使个不错的东西，因此就使用了。<br>上面的命令使删除带有“aa”串的文件，那如果我只想留下文件aa呢？很简单<br>zhou@zhou:~&#x2F;LinuxC&#x2F;file&#x2F;test$<strong>rm <code>ls | grep -v&quot;^aa$&quot; </code></strong><br><strong>在aa前面加上^，后面加上$表示结束符的意思，这个就是完全匹配了。</strong><br>好了，就这么多。但愿以后能用到这个有用的命令</p>
<p>转自：<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_67e34ceb01014930.html">http://blog.sina.com.cn/s/blog_67e34ceb01014930.html</a></p>
<p>linux 删除其他文件</p>
<p><a target="_blank" rel="noopener" href="http://zhidao.baidu.com/link?url=uvHfrb3kSnM_8p5ILhZyc39U0h3md-Ncrm3iaygeYTLU-zjthNBlqO674VulVGTnPiNcl2nj7wo5vn08N4481">http://zhidao.baidu.com/link?url=uvHfrb3kSnM_8p5ILhZyc39U0h3md-Ncrm3iaygeYTLU-zjthNBlqO674VulVGTnPiNcl2nj7wo5vn08N4481</a>_</p>
<p>求教 linux centos我想删除某目录中文件名不符合”<em>20100330</em>“这样规则的文件应该怎么删除？</p>
<p>假设目录名为myTest且为当前目录的下一级目录，使用如下命令即可：</p>
<p>cd .&#x2F;myTest &amp;&amp; rm <code>ls | grep -v &#39;20100330&#39;</code> &amp;&amp; cd ..</p>
<p>进入myTest目录，删除文件后返回当前目录。</p>
<p>grep的-v参数表示反向选择。</p>
<p>一般使用rm删除文件的时候会有确认提示，如果不要确认，直接强制删除，可以使用rm的-f参数。</p>
<p>其他1条回答</p>
<p>find .&#x2F; -type f ! -name “<em>20100330</em>“ -exec rm -rf {} ;</p>
<p>如何反向选择文件并删除</p>
<p><a href="http://bbs.csdn[**.NET**](http://lib.csdn.net/base/dotnet)/topics/390077765">http://bbs.csdn[**.NET**](http://lib.csdn.net/base/dotnet)/topics/390077765</a></p>
<p>案例：一个文件夹下我想删除 除了abc文件 之外的所有文件，命令怎么写（<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/linux"><strong>Linux</strong></a>下）</p>
<p>find . -maxdepth 1 -type f -not -name ‘abc’ -exec rm ‘{}’ ‘;’</p>
<p>ls | grep -v abc | xargs -i rm -rf {}</p>
<p>rm -f <code>ls | grep -v abc</code><br>如果文件很多的情况下，不要用这种方法……<br>要用2楼的方法……</p>
<p>mv abc &#x2F;tmp<br>rm *<br>mv &#x2F;tmp&#x2F;abc .</p>
<p>反向显示文件</p>
<p>使用ls命令仅仅显示当前目录不包括.的文件.</p>
<p>ls加grep过滤的方式：ls -al | grep -v ‘.‘(ls –ignore&#x3D;.* -al也可实现)。</p>
<p>在打开extglob模式下(缺省是打开的),ls也可以实现,而且更加灵活.</p>
<p>shopt -u extglob #关闭</p>
<p>shopt -s extglob #打开</p>
<p>ls -al !(<em>.</em>) </p>
<p>ls -al -d !(<em>.</em>)</p>
<h2 id="1-2-Linux常用命令"><a href="#1-2-Linux常用命令" class="headerlink" title="1.2 Linux常用命令"></a>1.2 Linux常用命令</h2><p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps14.png" alt="img"></p>
<h3 id="1-2-1-系统信息"><a href="#1-2-1-系统信息" class="headerlink" title="1.2.1 系统信息"></a>1.2.1 系统信息</h3><p>arch 显示机器的处理器架构(1)</p>
<p>cat &#x2F;proc&#x2F;version 显示内核的版本</p>
<p>cat &#x2F;proc&#x2F;net&#x2F;dev 显示网络适配器及统计</p>
<p>cat &#x2F;proc&#x2F;mounts 显示已加载的文件系统</p>
<p>date 显示系统日期</p>
<p>cal 2007 显示2007年的日历表</p>
<p>date 041217002007.00 设置日期和时间 - 月日时分年.秒</p>
<p>date –s “20180410”</p>
<p>clock -w 将时间修改保存到 BIOS</p>
<p>shutdown -h now 关闭系统(1)</p>
<p>reboot 重启(2)</p>
<p>logout 注销</p>
<h3 id="1-2-2-文件和目录"><a href="#1-2-2-文件和目录" class="headerlink" title="1.2.2 文件和目录"></a>1.2.2 文件和目录</h3><p>cd &#x2F;home 进入 ‘&#x2F; home’ 目录’</p>
<p>cd .. 返回上一级目录</p>
<p>cd ..&#x2F;.. 返回上两级目录</p>
<p>cd 进入个人的主目录</p>
<p>cd ~user1 进入个人的主目录</p>
<p>cd - 返回上次所在的目录</p>
<p>pwd 显示工作路径</p>
<p>ls 查看目录中的文件</p>
<p>ls -F 查看目录中的文件</p>
<p>ls -l 显示文件和目录的详细资料</p>
<p>ls -a 显示隐藏文件</p>
<p>ls <em>[0-9]</em> 显示包含数字的文件名和目录名</p>
<p>tree 显示文件和目录由根目录开始的树形结构(1)</p>
<p>lstree 显示文件和目录由根目录开始的树形结构(2)</p>
<p>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’</p>
<p>mkdir dir1 dir2 同时创建两个目录</p>
<p>mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2 创建一个目录树</p>
<p>rm -f file1 删除一个叫做 ‘file1’ 的文件’</p>
<p>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’</p>
<p>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容</p>
<p>rm -rf dir1 dir2 同时删除两个目录及它们的内容</p>
<p>mv dir1 new_dir 重命名&#x2F;移动 一个目录</p>
<p>cp file1 file2 复制一个文件</p>
<p>cp dir&#x2F;* . 复制一个目录下的所有文件到当前工作目录</p>
<p>cp -a &#x2F;tmp&#x2F;dir1 . 复制一个目录到当前工作目录</p>
<p>cp -a dir1 dir2 复制一个目录</p>
<p>ln -s file1 lnk1 创建一个指向文件或目录的软链接</p>
<p>ln file1 lnk1 创建一个指向文件或目录的物理链接</p>
<h3 id="1-2-3-文件搜索"><a href="#1-2-3-文件搜索" class="headerlink" title="1.2.3 文件搜索"></a>1.2.3 文件搜索</h3><p>find &#x2F; -name file1 从 ‘&#x2F;‘ 开始进入根文件系统搜索文件和目录</p>
<p>find &#x2F;home&#x2F;user1 -name *.bin 在目录 ‘&#x2F; home&#x2F;user1’ 中搜索带有’.bin’ 结尾的文件</p>
<p>find &#x2F; -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限</p>
<p>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令</p>
<p>whereis halt 显示一个二进制文件、源码或man的位置</p>
<p>which halt 显示一个二进制文件或可执行文件的完整路径</p>
<h3 id="1-2-4-挂载一个文件系统"><a href="#1-2-4-挂载一个文件系统" class="headerlink" title="1.2.4 挂载一个文件系统"></a>1.2.4 挂载一个文件系统</h3><p>mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2 挂载一个叫做hda2的盘 - 确定目录 ‘&#x2F; mnt&#x2F;hda2’ 已经存在</p>
<p>umount &#x2F;dev&#x2F;hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘&#x2F; mnt&#x2F;hda2’ 退出</p>
<p>fuser -km &#x2F;mnt&#x2F;hda2 当设备繁忙时强制卸载</p>
<p>umount -n &#x2F;mnt&#x2F;hda2 运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用</p>
<p>mount -o loop file.iso &#x2F;mnt&#x2F;cdrom 挂载一个文件或ISO镜像文件</p>
<p>mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5 挂载一个Windows FAT32文件系统</p>
<p>mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk 挂载一个usb 捷盘或闪存设备</p>
<p>mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share &#x2F;mnt&#x2F;share 挂载一个windows网络共享</p>
<p>passwd 修改口令</p>
<p>passwd user1 修改一个用户的口令 (只允许root执行)</p>
<h3 id="1-2-5-打包和压缩文件"><a href="#1-2-5-打包和压缩文件" class="headerlink" title="1.2.5 打包和压缩文件"></a>1.2.5 打包和压缩文件</h3><p>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包</p>
<p>tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包</p>
<p>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包</p>
<p>tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包</p>
<p>zip file1.zip file1 创建一个zip格式的压缩包</p>
<p>unzip file1.zip 解压一个zip格式压缩包</p>
<h3 id="1-2-6-如何设置Linux启动模式"><a href="#1-2-6-如何设置Linux启动模式" class="headerlink" title="1.2.6 如何设置Linux启动模式"></a>1.2.6 如何设置Linux启动模式</h3><p>把&#x2F;etc&#x2F;inittab中的默认启动级别设为3<br>七个运行级别分别是：<br>0：直接关机<br>1：单用户模式<br>2：没有NFS服务<br>3：完整含有网络功能的纯文本模式<br>4：系统保留功能<br>5：图形界面<br>6：重启</p>
<h3 id="1-2-7-linux下解决端口被占用问题"><a href="#1-2-7-linux下解决端口被占用问题" class="headerlink" title="1.2.7 linux下解决端口被占用问题"></a>1.2.7 linux下解决端口被占用问题</h3><p>查找被占用的端口：</p>
<p>netstat -tln</p>
<p>netstat -tln | grep 8080</p>
<p>查看端口属于哪个程序</p>
<p>lsof -i :8080</p>
<p>杀掉占用端口的进程：</p>
<p>kill -9 进程ID</p>
<p>ps -ef | grep xxx</p>
<p>kill xxx</p>
<h3 id="1-2-8-修改core文件格式"><a href="#1-2-8-修改core文件格式" class="headerlink" title="1.2.8 修改core文件格式"></a>1.2.8 修改core文件格式</h3><p>永久修改：sysctl -w  kernel.core_pattern&#x3D;%e.core.%p</p>
<p>临时修改：</p>
<h3 id="1-2-9-释放cache缓存"><a href="#1-2-9-释放cache缓存" class="headerlink" title="1.2.9 释放cache缓存"></a>1.2.9 释放cache缓存</h3><p>echo 3&gt;&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</p>
<h2 id="1-3-得到系统bit位"><a href="#1-3-得到系统bit位" class="headerlink" title="1.3 得到系统bit位"></a>1.3 得到系统bit位</h2><p>getconf LONG_BIT</p>
<h2 id="1-4-系统设置"><a href="#1-4-系统设置" class="headerlink" title="1.4 系统设置"></a>1.4 系统设置</h2><h3 id="1-4-1-Linux防火墙-iptables-的开启与关闭"><a href="#1-4-1-Linux防火墙-iptables-的开启与关闭" class="headerlink" title="1.4.1 Linux防火墙(iptables)的开启与关闭"></a>1.4.1 Linux防火墙(iptables)的开启与关闭</h3><p>Linux中的防火墙主要是对iptables的设置和管理。</p>
<p>① Linux防火墙(Iptables)重启系统生效</p>
<p>开启： chkconfig iptables on  </p>
<p>关闭： chkconfig iptables off  </p>
<p>② Linux防火墙(Iptables) 即时生效，重启后失效</p>
<p>开启： service iptables start  </p>
<p>关闭： service iptables stop  </p>
<p>③ 示例</p>
<p>在开启了Linux防火墙(Iptables)时，做如下设置，开启25和110端口，修改&#x2F;etc&#x2F;sysconfig&#x2F;iptables 文件，添加以下内容：</p>
<p>-A RH-Firewall-1-INPUT -m state –state NEW -p tcp -m tcp –dport 25 –syn -j ACCEPT  </p>
<p>-A RH-Firewall-1-INPUT -m state –state NEW -p tcp -m tcp –dport 110 –syn -j ACCEPT  </p>
<h2 id="1-5-系统服务"><a href="#1-5-系统服务" class="headerlink" title="1.5 系统服务"></a>1.5 系统服务</h2><h3 id="1-5-1-rsyslog"><a href="#1-5-1-rsyslog" class="headerlink" title="1.5.1 rsyslog"></a>1.5.1 rsyslog</h3><p>配置文件：&#x2F;etc&#x2F;rsyslog.conf</p>
<p>$SystemLogRateLimitInterval 0</p>
<p>local6.debug -&#x2F;workspace&#x2F;im.log</p>
<p>日志限定大小：</p>
<p>#Update the &#x2F;etc&#x2F;crontab for running the logrotate every 5 minutes </p>
<p>var&#x3D;<code>grep -c &quot;/usr/sbin/logrotate /etc/logrotateim.conf&quot; /etc/crontab</code></p>
<p>if [ $var &#x3D;&#x3D; 0 ] ; then</p>
<p>echo “*&#x2F;2 * * * * root &#x2F;usr&#x2F;sbin&#x2F;logrotate &#x2F;etc&#x2F;logrotateim.conf “ &gt;&gt; &#x2F;etc&#x2F;crontab</p>
<p>fi</p>
<p>logrotateim.conf内容：</p>
<p># see “man logrotate” for details</p>
<p># rotate log files weekly</p>
<p>weekly</p>
<p># keep 4 weeks worth of backlogs</p>
<p>rotate 4</p>
<p># create new (empty) log files after rotating old ones</p>
<p>create</p>
<p># use date as a suffix of the rotated file</p>
<p>#dateext</p>
<p># uncomment this if you want your log files compressed</p>
<p>#compress</p>
<p># RPM packages drop log rotation information into this directory</p>
<p>include &#x2F;etc&#x2F;logrotate.d</p>
<p># no packages own wtmp and btmp – we’ll rotate them here</p>
<p>&#x2F;var&#x2F;log&#x2F;wtmp {</p>
<p>​    monthly</p>
<p>​    create 0664 root utmp</p>
<p>​	 minsize 1M</p>
<p>​    rotate 1</p>
<p>}</p>
<p># system-specific logs may be also be configured here.</p>
<p>&#x2F;var&#x2F;log&#x2F;im&#x2F;im.log {</p>
<p>​      rotate 10</p>
<p>​      size&#x3D;100M</p>
<p>​      postrotate</p>
<p>​      &#x2F;usr&#x2F;bin&#x2F;kill -HUP rsyslogd</p>
<p>​      endscript</p>
<p>}</p>
<p>&#x2F;var&#x2F;log&#x2F;im&#x2F;memery.log {</p>
<p>​      rotate 10</p>
<p>​      size&#x3D;100M</p>
<p>​      postrotate</p>
<p>​      &#x2F;usr&#x2F;bin&#x2F;kill -HUP rsyslogd   #注意此处可能为syslogd</p>
<p>​      endscript</p>
<p>}</p>
<p># system-specific logs may be also be configured here.</p>
<h3 id="1-5-2-crond"><a href="#1-5-2-crond" class="headerlink" title="1.5.2 crond"></a>1.5.2 crond</h3><p>定时任务</p>
<p>配置文件:&#x2F;etc&#x2F;crontab</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps15.jpg" alt="img"> </p>
<h3 id="1-5-3-开机自动执行脚本"><a href="#1-5-3-开机自动执行脚本" class="headerlink" title="1.5.3 开机自动执行脚本"></a>1.5.3 开机自动执行脚本</h3><p>① 将脚本置于&#x2F;etc&#x2F;rc.local中即可</p>
<p>② &#x2F;etc&#x2F;init.d&#x2F;rcS</p>
<h3 id="1-5-4-设置时间"><a href="#1-5-4-设置时间" class="headerlink" title="1.5.4 设置时间"></a>1.5.4 设置时间</h3><p>显示时间 hwclock</p>
<p>设置时间  在linux系统设置系统时钟用命令date，格式为：date 062920502008.10，表示系统时间设置为2008年6月29日20时50分10秒。硬件时钟RTC时间是通过hwclock命令来设置的，比如说硬件时间要设置为2008年6月29日20时50分10秒，则应该先用date 062920502008.10，然后用命令：hwclock -w，这样RTC时间就跟系统时间一致了。</p>
<p><a target="_blank" rel="noopener" href="http://blog.163.com/pirates_fish/blog/static/183333150201141222953793/">http://blog.163.com/pirates_fish/blog/static/183333150201141222953793/</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/jk110333/article/details/8590746">http://blog.csdn.net/jk110333/article/details/8590746</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-23095063-id-203369.html">linux下C获取系统时间的方法</a> </p>
<h2 id="1-6-系统操作"><a href="#1-6-系统操作" class="headerlink" title="1.6 系统操作"></a>1.6 系统操作</h2><h2 id="1-7-重定向"><a href="#1-7-重定向" class="headerlink" title="1.7 重定向"></a>1.7 重定向</h2><table>
<thead>
<tr>
<th>数字</th>
<th>含义</th>
<th>标准叫法</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>标准输入</td>
<td>stdin &#x3D; standard input</td>
</tr>
<tr>
<td>1</td>
<td>标准输出</td>
<td>stdout &#x3D; standard output</td>
</tr>
<tr>
<td>2</td>
<td>标准错误输出</td>
<td>stderr &#x3D; standard error</td>
</tr>
</tbody></table>
<p>而系统默认的stdin，stdout，stderr，都是屏幕，所以，当你执行命令，比如make，后，所输出的信息，都是可以在屏幕上看到的。所以，想要将对应信息输出到某个文件中，就用对应的数字加上重定向符号’&gt;’，实现将这些信息，重新定向到对应的文件中，即可。下面以make命令为例来说明，如何把对应的信息，输出到对应的文件中：</p>
<p>1.想要把make输出的全部信息，输出到某个文件中，最常见的办法就是：</p>
<p><strong>make xxx <strong><strong>&gt;</strong></strong> build_output.txt</strong><br>此时默认情况是没有改变2&#x3D;stderr的输出方式，还是屏幕，所以，如果有错误信息，还是可以在屏幕上看到的。</p>
<p>2.只需要把make输出中的错误（及警告）信息输出到文件中ing，可以用：</p>
<p><strong>make xxx <strong><strong>2&gt;</strong></strong> build_output.txt</strong>****</p>
<p>相应地，由于1&#x3D;stdout没有变，还是屏幕，所以，那些命令执行时候输出的正常信息，还是会输出到屏幕上，你还是可以在屏幕上看到的。</p>
<p>3.只需要把make输出中的正常（非错误，非警告）的信息输出到文件中，可以用：<br>**make xxx **<strong>1&gt; <strong><strong>build_output.txt</strong></strong></strong></p>
<p>相应地，由于2&#x3D;stderr没有变，还是屏幕，所以，那些命令执行时候输出的错误信息，还是会输出到屏幕上，你还是可以在屏幕上看到的。</p>
<p>4.想要把正常输出信息和错误信息输出到分别的文件中，可以用：</p>
<p>**make xxx <strong><strong>1&gt;</strong></strong> build_output_normal.txt **<strong>2&gt;<strong><strong>build_output_error.txt</strong></strong></strong></p>
<p>即联合使用了1和2，正常信息和错误信息，都输出到对应文件中了。</p>
<p>\5. 所有的信息都输出到同一个文件中：</p>
<p><strong>make xxx <strong><strong>&gt;</strong></strong> build_output_all.txt <strong><strong>2&gt;&amp;1</strong></strong></strong></p>
<p>其中的2&gt;&amp;1表示错误信息输出到&amp;1中，而&amp;1，指的是前面的那个文件：build_output_all.txt 。</p>
<p><strong>注意：上面所有的1,2等数字，后面紧跟着大于号’&gt;’ ，中间不能有空格。</strong>****</p>
<h2 id="1-8-关于文本导出"><a href="#1-8-关于文本导出" class="headerlink" title="1.8 关于文本导出"></a>1.8 关于文本导出</h2><h4 id="1-8-0-1-如何把命令运行的结果保存到文件当中"><a href="#1-8-0-1-如何把命令运行的结果保存到文件当中" class="headerlink" title="1.8.0.1 如何把命令运行的结果保存到文件当中?"></a>1.8.0.1 如何把命令运行的结果保存到文件当中?</h4><p>用 &gt;</p>
<p>例子:</p>
<p>[lhd@hongdi ~]$ ls &gt; ls.txt</p>
<p>[lhd@hongdi ~]$ cat ls.txt</p>
<p>1.gtkrc-2.0</p>
<p>2009</p>
<p>a</p>
<p>amsn_received</p>
<p>a.tar.gz</p>
<p>说明: &gt; 是把输出转向到指定的文件，如文件已存在的话也会重新写入，文件原内容不会保留</p>
<blockquote>
<blockquote>
<p>是把输出附向到文件的后面，文件原内容会保留下来</p>
</blockquote>
</blockquote>
<h4 id="1-8-0-2-如何能在输出信息的同时把信息记录到文件中"><a href="#1-8-0-2-如何能在输出信息的同时把信息记录到文件中" class="headerlink" title="1.8.0.2 如何能在输出信息的同时把信息记录到文件中?"></a>1.8.0.2 如何能在输出信息的同时把信息记录到文件中?</h4><p>tee</p>
<p>tee的作用:read from standard input and write to standard output and files</p>
<p>它从标准输入读取内容并将其写到标准输出和文件中</p>
<p>看例子:</p>
<p>[lhd@hongdi ~]$ ls | tee ls_tee.txt</p>
<p>1.gtkrc-2.0</p>
<p>2009</p>
<p>a</p>
<p>amsn_received</p>
<p>a.tar.gz</p>
<p>[lhd@hongdi ~]$ cat ls_tee.txt</p>
<p>1.gtkrc-2.0</p>
<p>2009</p>
<p>a</p>
<p>amsn_received</p>
<p>a.tar.gz</p>
<p>备注：使用 tee时,如果想保留目标文件原有的内容怎么办？</p>
<p>可以使用 -a参数</p>
<p>-a, –append</p>
<p>append to the given FILEs, do not overwrite</p>
<p>附加至给出的文件，而不是覆盖它</p>
<h4 id="1-8-0-3-同时在屏幕和文件中输出"><a href="#1-8-0-3-同时在屏幕和文件中输出" class="headerlink" title="1.8.0.3 同时在屏幕和文件中输出"></a>1.8.0.3 同时在屏幕和文件中输出</h4><p>.&#x2F;build 2&gt;&amp;1 | tee build.log</p>
<h4 id="1-8-0-4-多个命令的输出都需要记录，可以用script"><a href="#1-8-0-4-多个命令的输出都需要记录，可以用script" class="headerlink" title="1.8.0.4 多个命令的输出都需要记录，可以用script"></a>1.8.0.4 多个命令的输出都需要记录，可以用script</h4><p>script这个命令很强大，可以记录终端的所有输出到相应的文件中</p>
<p>看例子:</p>
<p>[lhd@hongdi ~]$ script</p>
<p>Script. started, file is typescript</p>
<p>[lhd@hongdi ~]$ ls</p>
<p>1.gtkrc-2.0 c.tar kmess-2.0alpha2.tar.gz secpanel-0.5.3-1.noarch.rpm</p>
<p>2009 DownZipAction.php kmesslog secpanel-0.5.4-2.noarch.rpm</p>
<p>[lhd@hongdi ~]$ exit</p>
<p>exit</p>
<p>Script. done, file is typescript</p>
<p>[lhd@hongdi ~]$ cat typescript</p>
<p>Script. started on 2009年02月08日 星期日 18时56分52秒</p>
<p>[lhd@hongdi ~]$ ls</p>
<p>1.gtkrc-2.0 c.tar kmess-2.0alpha2.tar.gz secpanel-0.5.3-1.noarch.rpm</p>
<p>2009 DownZipAction.php kmesslog secpanel-0.5.4-2.noarch.rpm</p>
<p>[lhd@hongdi ~]$ exit</p>
<p>exit</p>
<p>Script. done on 2009年02月08日 星期日 18时57分00秒</p>
<p>说明:</p>
<p>1,我们在启动script时没有指定文件名，它会自动记录到当前目录下一个名为 typescript的文件中。也可以用 -a参数 指定文件名</p>
<p>例子:</p>
<p>[lhd@hongdi ~]$ script. -a example.txt</p>
<p>Script. started, file is example.txt</p>
<p>此时终端的输出内容被记录到 example.txt这个文件中</p>
<p>2,退出script时，用exit</p>
<p>感到奇怪吗？事实上script就是启动了一个shell</p>
<p>看一下ps auxfww 的信息就知道了</p>
<p>lhd 17738 0.1 3.2 152028 33328 ? Sl 18:30 0:03 &#x2F;usr&#x2F;bin&#x2F;konsole</p>
<p>lhd 17740 0.0 0.1 6372 1720 pts&#x2F;1 Ss 18:30 0:00 _ &#x2F;bin&#x2F;bash</p>
<p>lhd 17900 0.0 0.0 5344 628 pts&#x2F;1 S 19:01 0:00 | _ script</p>
<p>lhd 17901 0.0 0.0 5348 464 pts&#x2F;1 S 19:01 0:00 | _ script</p>
<p>lhd 17902 0.5 0.1 6372 1688 pts&#x2F;2 Ss 19:01 0:00 | _ bash -i</p>
<p>3,查看typescript的内容，可以看到它同时记录下了script的启动和结束时间</p>
<p>用script录制并播放session的内容</p>
<p>我们可以用 script把整个终端会话的所有操作和输出录制下来，然后再用scriptreplay进行播放。</p>
<p>如果录制时记录下来了操作时的时间数据，那么播放时和操作时的使用时间完全相同。</p>
<p>这个很有用吧，比如：我们可以把安装软件时编译的过程记录下来，然后给别人进行演示</p>
<p>看例子:</p>
<p>[lhd@hongdi ~]$ script. -t 2&gt;example.time -a example.txt</p>
<p>Script. started, file is example.txt</p>
<p>[lhd@hongdi ~]$ ls</p>
<p>说明: -t 2&gt;example.time -t是把时间数据输出到标准错误(standard error)，所以我们使用 2&gt;example.time 把数据转向到 example.time这个文件当中</p>
<p>如何播放所记录的内容?</p>
<p>第一步：安装scriptreplay</p>
<p>下载</p>
<p>　 　wget linux&#x2F;utils&#x2F;util-linux&#x2F;util-linux-2.12r.tar.bz2”&gt;<a href="ftp://ftp.kernel.org/pub/linux/utils/util-linux/util-linux-2.12r.tar.bz2">ftp://ftp.kernel.org/pub/linux/utils/util-linux/util-linux-2.12r.tar.bz2</a></p>
<p>解压</p>
<p>tar -jxvf util-linux-2.12r.tar.bz2</p>
<p>之后复制文件到系统的命令目录中即可</p>
<p>[root@hongdi 下载]# cp util-linux-2.12r&#x2F;misc-utils&#x2F;scriptreplay.pl &#x2F;usr&#x2F;bin&#x2F;scriptreplay</p>
<p>[root@hongdi 下载]# chmod 755 &#x2F;usr&#x2F;bin&#x2F;scriptreplay</p>
<p>备注: fedora 10的util-linux-ng-2.14.1-3.2.fc10.i386.rpm 此包中已包含 scriptreplay,已无需另行安装</p>
<p>第二步：播放所录制的session内容</p>
<p>[lhd@hongdi ~]$ scriptreplay example1.time example1.txt</p>
<p>[lhd@hongdi ~]$ ls</p>
<p>1.gtkrc-2.0 c.tar <a href="mailto:&#x6a;&#x65;&#x66;&#x66;&#114;&#97;&#x79;&#95;&#x6c;&#101;&#101;&#x40;&#x68;&#x6f;&#x74;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;">&#x6a;&#x65;&#x66;&#x66;&#114;&#97;&#x79;&#95;&#x6c;&#101;&#101;&#x40;&#x68;&#x6f;&#x74;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;</a> pass</p>
<p>[lhd@hongdi ~]$ abcd</p>
<p>bash: abcd: command not found</p>
<p>[lhd@hongdi ~]$ exit</p>
<h2 id="1-9-Linux打开单层文件夹"><a href="#1-9-Linux打开单层文件夹" class="headerlink" title="1.9 Linux打开单层文件夹"></a>1.9 Linux打开单层文件夹</h2><p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps16.jpg" alt="img"> </p>
<p>把Always open in browse windows 勾选。</p>
<h2 id="1-10-Linux打开文件夹后默认最大化"><a href="#1-10-Linux打开文件夹后默认最大化" class="headerlink" title="1.10 Linux打开文件夹后默认最大化"></a>1.10 Linux打开文件夹后默认最大化</h2><p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps17.jpg" alt="img"> </p>
<p>如图。</p>
<h2 id="1-11-Linux下采用Cloc统计代码行数"><a href="#1-11-Linux下采用Cloc统计代码行数" class="headerlink" title="1.11 Linux下采用Cloc统计代码行数"></a>1.11 Linux下采用Cloc统计代码行数</h2><p>源代码下载、详细说明等见：<a target="_blank" rel="noopener" href="http://cloc.sourceforge.net/">http://cloc.sourceforge.net</a></p>
<h3 id="1-11-1-使用方法"><a href="#1-11-1-使用方法" class="headerlink" title="1.11.1 使用方法"></a>1.11.1 使用方法</h3><p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps18.jpg" alt="img"> </p>
<h4 id="1-11-1-1-显示各类文件统计结果"><a href="#1-11-1-1-显示各类文件统计结果" class="headerlink" title="1.11.1.1 显示各类文件统计结果"></a>1.11.1.1 显示各类文件统计结果</h4><p>Cloc  .    ：统计当前文件夹下的所有文件的代码</p>
<p>统计结果如下图，</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps19.jpg" alt="img"> </p>
<h4 id="1-11-1-2-详细统计各个文件下的代码量"><a href="#1-11-1-2-详细统计各个文件下的代码量" class="headerlink" title="1.11.1.2 详细统计各个文件下的代码量"></a>1.11.1.2 详细统计各个文件下的代码量</h4><p>首先安装好sqlite3.</p>
<p>命令：cloc   –sql  1  .|sqlite3 code.db     </p>
<p>​	   Cloc   –sql  1  –sql-project  epc  &#x2F;epc地址&#x2F;|sqlite3 epc.db    </p>
<p>说明：.表示当前目录，也可以为压缩文件等。</p>
<p>执行后，统计结果将输出到code.db数据库中，可以使用工具导出。</p>
<p>当有多个工程需要统计时可以使用：</p>
<p>cloc  –sql  –sql-project   pgw   –sql-append  &#x2F;pgw地址|sqlite3  epc.db   将后面的数据附加到前面的数据库</p>
<h2 id="1-12-永久性修改hostname"><a href="#1-12-永久性修改hostname" class="headerlink" title="1.12 永久性修改hostname"></a>1.12 永久性修改hostname</h2><p>&#x2F;etc&#x2F;sysconfig&#x2F;network</p>
<p>HOSTNAME &#x3D; smart</p>
<p>重启即可生效</p>
<h2 id="1-13-查看linux发布版本"><a href="#1-13-查看linux发布版本" class="headerlink" title="1.13 查看linux发布版本"></a>1.13 查看linux发布版本</h2><p>cat &#x2F;etc&#x2F;redhat-release</p>
<h2 id="1-14-修改ip地址"><a href="#1-14-修改ip地址" class="headerlink" title="1.14 修改ip地址"></a>1.14 <a href="">修改ip地址</a></h2><p>对于开发板：</p>
<p>vi  &#x2F;etc&#x2F;eth0-setting</p>
<p>对于CentOS：</p>
<p>修改&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</p>
<h2 id="1-15-去除DHCP"><a href="#1-15-去除DHCP" class="headerlink" title="1.15 去除DHCP"></a>1.15 <a href="">去除DHCP</a></h2><p>修改启动文件&#x2F;etc&#x2F;init.d&#x2F;rcS 把 fa-network-service注释掉</p>
<h2 id="1-16-telnet"><a href="#1-16-telnet" class="headerlink" title="1.16 telnet"></a>1.16 <a href="">telnet</a></h2><p>远程登录时，应注意新版的文件系统必须先设置开发板的密码，方可远程登录。</p>
<p>passwd  root</p>
<h2 id="1-17-修改主机名"><a href="#1-17-修改主机名" class="headerlink" title="1.17 修改主机名"></a>1.17 <a href="">修改主机名</a></h2><h3 id="1-17-1-方法1"><a href="#1-17-1-方法1" class="headerlink" title="1.17.1 方法1"></a>1.17.1 方法1</h3><p>主机名即：root@zhuyan中的zhuyan</p>
<p>hostname  DataCollector即修改了。</p>
<h3 id="1-17-2-方法2"><a href="#1-17-2-方法2" class="headerlink" title="1.17.2 方法2"></a>1.17.2 方法2</h3><p>修改rcS 下的&#x2F;bin&#x2F;hostname  </p>
<h2 id="1-18-linux配置虚拟IP地址"><a href="#1-18-linux配置虚拟IP地址" class="headerlink" title="1.18 linux配置虚拟IP地址"></a>1.18 <a href="">linux配置虚拟IP地址</a></h2><p>在日常linux管理工作中,需要为应用配置单独的IP地址,以达到主机与应用的分离,在应用切换与迁移过程中可以做到动态切换,特别是在使用HA的时候,这种方案可以保证主机与应用的隔离,对日常的运维有很大的益处.</p>
<p>但在有些应用中还没有配置HA,后期需要配置HA时,我们可以先配置虚拟IP给在线的应用使用,这要后期的系统运维可以做到更好的可扩展性.</p>
<p>本文主要是对IP地址如何配置做一些简单的介绍.</p>
<p>PS:以下实例在redhat linux实施成功!</p>
<ol>
<li>在线配置虚拟IP</li>
</ol>
<p>ifconfig eth0:1 192.168.109.108 netmask 255.255.255.0 </p>
<ol start="2">
<li>查看新增加的子接口配置信息是否正确.主要是看IP与子网掩码.</li>
</ol>
<p>ifconfig eth0:1 </p>
<p># ifconfig eth0:1</p>
<p>eth0:1 Link encap:Ethernet HWaddr 00:0C:29:45:62:3B </p>
<p>inet addr:192.168.109.108 Bcast:192.168.109.255 Mask:255.255.255.0</p>
<p>UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</p>
<p>Base address:0x2000 Memory:d8920000-d8940000 </p>
<ol start="3">
<li>启动网卡eth0的子接口</li>
</ol>
<p>ifconfig eht0:1 up </p>
<p>查看IP是否可以联通</p>
<p>ping -c 3 192.168.109.108 </p>
<p># ping -c 3 192.168.109.108</p>
<p>PING 192.168.109.108 (192.168.109.108) 56(84) bytes of data.</p>
<p>64 bytes from 192.168.109.108: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.032 ms</p>
<p>64 bytes from 192.168.109.108: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.053 ms</p>
<p>64 bytes from 192.168.109.108: icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.036 ms</p>
<p>— 192.168.109.108 ping statistics —</p>
<p>3 packets transmitted, 3 received, 0% packet loss, time 2000ms</p>
<p>rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.032&#x2F;0.040&#x2F;0.053&#x2F;0.010 ms</p>
<ol start="4">
<li>修改配置文件，使配置在主机重启后自动生效.</li>
</ol>
<p>cd &#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;</p>
<p>cp ifcfg-eth0 ifcfg-eth0:1</p>
<p>vi ifcfg-eth0:1</p>
<p># Intel Corporation 82545EM Gigabit Ethernet Controller (Copper)</p>
<p>DEVICE&#x3D;eth0:1 —-&gt;子接口名</p>
<p>HWADDR&#x3D;00:0C:29:45:62:3B</p>
<p>ONBOOT&#x3D;yes</p>
<p>BOOTPROTO&#x3D;static</p>
<p>IPADDR&#x3D;192.168.109.108</p>
<p>NETMASK&#x3D;255.255.255.0</p>
<ol start="5">
<li>对于要切换主机IP与应用IP的情可以做如下处理</li>
</ol>
<p>如下面的例子：主机IP是192.168.109.105 应用IP是192.168.109.108</p>
<p>我们要将IP做对调，</p>
<p>192.168.109.108给主机使用</p>
<p>192.168.109.105给应用使用</p>
<p>做法如下：</p>
<p>配置前的信息：</p>
<p>#ifconfig eth0 </p>
<p>eth0 Link encap:Ethernet HWaddr 00:0C:29:45:62:3B </p>
<p>inet addr:192.168.109.105 Bcast:192.168.109.255 Mask:255.255.255.0</p>
<p>inet6 addr: fe80::20c:29ff:fe45:623b&#x2F;64 Scope:Link</p>
<p>UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</p>
<p>RX packets:20340 errors:0 dropped:0 overruns:0 frame:0</p>
<p>TX packets:16678 errors:0 dropped:0 overruns:0 carrier:0</p>
<p>collisions:0 txqueuelen:1000 </p>
<p>RX bytes:1800154 (1.7 MiB) TX bytes:2438822 (2.3 MiB)</p>
<p>Base address:0x2000 Memory:d8920000-d8940000</p>
<p># ifconfig eth0:1</p>
<p>eth0:1 Link encap:Ethernet HWaddr 00:0C:29:45:62:3B </p>
<p>inet addr:192.168.109.108 Bcast:192.168.109.255 Mask:255.255.255.0</p>
<p>UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</p>
<p>Base address:0x2000 Memory:d8920000-d8940000 </p>
<p>修改eth0:1的网卡配置信息：</p>
<p># vi ifcfg-eth0:1</p>
<p># Intel Corporation 82545EM Gigabit Ethernet Controller (Copper)</p>
<p>DEVICE&#x3D;eth0:1 —-&gt;子接口名</p>
<p>HWADDR&#x3D;00:0C:29:45:62:3B</p>
<p>ONBOOT&#x3D;yes</p>
<p>BOOTPROTO&#x3D;static</p>
<p>IPADDR&#x3D;192.168.109.105</p>
<p>NETMASK&#x3D;255.255.255.0</p>
<p>修改eth0的网卡配置信息：</p>
<p>#vi ifcfg-eth0</p>
<p># Intel Corporation 82545EM Gigabit Ethernet Controller (Copper)</p>
<p>DEVICE&#x3D;eth0</p>
<p>HWADDR&#x3D;00:0C:29:45:62:3B</p>
<p>ONBOOT&#x3D;yes</p>
<p>BOOTPROTO&#x3D;static</p>
<p>IPADDR&#x3D;192.168.109.108</p>
<p>NETMASK&#x3D;255.255.255.0</p>
<p>重启网络生效：这一步很重要！！！</p>
<p>nohup service network restart &amp; </p>
<p>将命令提交给后台去执行，这样子可以保证系统正常重启网络</p>
<h2 id="1-19-Linux设备"><a href="#1-19-Linux设备" class="headerlink" title="1.19 Linux设备"></a>1.19 Linux设备</h2><p>&#x2F;<strong>dev</strong>&#x2F;pts是远程登陆(telnet**,<strong>ssh等)后创建的控制台设备文件所在的目录。第一个用户登陆</strong>，console<strong>的设备文件为&#x2F;<strong>dev</strong>&#x2F;pts&#x2F;0</strong>，<strong>第二个为&#x2F;<strong>dev</strong>&#x2F;pts&#x2F;1</strong>，<strong>以此类推。这里的0、1、2、3不是具体的标准输入或输出</strong>，**而是整个控制台。你可尝试 echo “aaaaaa” &gt; &#x2F;<strong>dev</strong>&#x2F;pts0、1、2……。</p>
<h2 id="1-20-Samba搭建"><a href="#1-20-Samba搭建" class="headerlink" title="1.20 Samba搭建"></a>1.20 Samba搭建</h2><ol>
<li><p>安装Samba软件</p>
</li>
<li><p>编辑&#x2F;etc&#x2F;samba&#x2F;smb.conf</p>
</li>
</ol>
<p>[root]</p>
<p>comment&#x3D;Root Directories</p>
<p>browseable&#x3D;yes</p>
<p>path&#x3D; &#x2F;root&#x2F;</p>
<p>valid  users &#x3D;root</p>
<p>writable&#x3D;yes</p>
<ol start="3">
<li><p>smbpasswd –a root</p>
</li>
<li><p>重启服务</p>
</li>
<li><p>主机打开<a href="file:///\192.168.55.21">\192.168.55.21</a> ok</p>
</li>
</ol>
<h2 id="1-21-Linux软件打包"><a href="#1-21-Linux软件打包" class="headerlink" title="1.21 Linux软件打包"></a>1.21 Linux软件打包</h2><h3 id="1-21-1-Linux打包软件"><a href="#1-21-1-Linux打包软件" class="headerlink" title="1.21.1 Linux打包软件"></a>1.21.1 Linux打包软件</h3><h4 id="1-21-1-1-rpmdevtools"><a href="#1-21-1-1-rpmdevtools" class="headerlink" title="1.21.1.1 rpmdevtools"></a>1.21.1.1 rpmdevtools</h4><p>首先安装rpmdevtools这个工具,该工具包含rpmbuild,rpmdev-newspec,rpmdev-setuptree等工具 </p>
<p>sudo yum install rpmdevtools</p>
<p>rpm常用命令 </p>
<p>安装&#x2F;升级命令 </p>
<p>rpm -ivh package_name</p>
<p>rpm -Uvh package_name</p>
<p>rpm -Fvh package_name</p>
<p>选项与参数：</p>
<p>-i: install 的意思</p>
<p>-v: 察看更绅部的安装信息画面</p>
<p>-h：以安装信息列显示安装迚度</p>
<p>-U: 升级软件,如果系统未安装指定软件,则进行安装</p>
<p>-F: 升级指定的软件,如果该软件未安装,则不执行任何操作</p>
<p>卸载 </p>
<p>rpm -e package_name</p>
<p>强制卸载</p>
<p>rpm -e –nodeps package_name</p>
<p>重建rpm数据库 </p>
<p>rpm –rebuilddb</p>
<p>查询某个软件是否安装 </p>
<p>rpm -qa|grep package_name</p>
<p>列出完成的安装信息</p>
<p>rpm -ql packa_name</p>
<h4 id="1-21-1-2-rpmbuild"><a href="#1-21-1-2-rpmbuild" class="headerlink" title="1.21.1.2 rpmbuild"></a>1.21.1.2 rpmbuild</h4><p># 同时产生rpm和srpm包</p>
<p>rpmbuild -ba spec</p>
<p>#只产生rpm包</p>
<p>rpmbuild -bb spec</p>
<p># 用srpm包生成rpm包</p>
<p>rpmbuild –rebuild src.rpm</p>
<p>rpmdev-setuptree </p>
<p>在CentOS 6.2系统下,使用该命令,会生成~&#x2F;rpmbuild目录.</p>
<p>其子目录功能:</p>
<p>目录名 解释 </p>
<p>BUILD 解压SOURCES目录中的tar.gz源码包后,放到该目录下 </p>
<p>BUILDROOT 执行make install时的”虚拟”目录 </p>
<p>RPMS 打包好的rpm文件 </p>
<p>SOURCES 源码包(tar.gz) </p>
<p>SPECS spec配置文件 </p>
<p>SRPMS 打包好的src.rpm文件 </p>
<h4 id="1-21-1-3-rpmdev-newspec"><a href="#1-21-1-3-rpmdev-newspec" class="headerlink" title="1.21.1.3 rpmdev-newspec"></a>1.21.1.3 rpmdev-newspec</h4><p>在当前目录下生成spec模板文件,默认文件名称:newpackage.spec</p>
<h4 id="1-21-1-4-rpmdev-newinit"><a href="#1-21-1-4-rpmdev-newinit" class="headerlink" title="1.21.1.4 rpmdev-newinit"></a>1.21.1.4 rpmdev-newinit</h4><p>生成service初始化文件</p>
<h3 id="1-21-2-打包步骤"><a href="#1-21-2-打包步骤" class="headerlink" title="1.21.2 打包步骤"></a>1.21.2 打包步骤</h3><p>常见的Linux发行版主要可以分为两类，类ReadHat系列和类Debian系列，这里我们是以其软件包的格式来划分的，这两类系统分别提供了自己的软件包管理系统和相应的工具。类RedHat系统中软件包的后缀是rpm；类Debian系统中软件包的后缀是deb。另一方面，类RedHat系统提供了同名的rpm命令来安装、卸载、升级rpm软件包；类Debian系统同样提供了dpkg命令来对后缀是deb的软件包进行安装、卸载和升级等操作。<br>   rpm的全称是Redhat Package Manager，常见的使用rpm软件包的系统主要有Fedora、CentOS、openSUSE、SUSE企业版、PCLinuxOS以及Mandriva Linux、Mageia等。使用deb软件包后缀的类Debian系统最常见的有Debian、Ubuntu、Finnix等。 </p>
<p>无论是rpm命令还是dpkg命令在安装软件包时都存在一个让人非常头疼的问题，那就是软件包的依赖关系。这一点很多人应该深有体会，这也使初学者在接触Linux系统时觉得很不方便的地方。庆幸的是，很多发行版都考虑到了这问题，于是Fedora和CentOS提供了yum来自动解决软件包的安装依赖，同样的openSUSE提供了zypper，类Debian系统提供了apt-*命令。也就是说这些工具本质上最终还是调用了rpm(或者dpkg)是不过安装前自动帮用户解决了软件包的安装依赖。如下表所示：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>发行版</th>
<th>手动安装命令</th>
<th>自动安装命令</th>
<th>软件包后缀</th>
</tr>
</thead>
<tbody><tr>
<td>类RedHat</td>
<td>Fedora&#x2F;CentOS</td>
<td>rpm</td>
<td>yum</td>
<td>*.rpm</td>
</tr>
<tr>
<td>openSUSE&#x2F;SUSE</td>
<td>zypper</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mandriva Linux&#x2F;Mageia</td>
<td>urpmi</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类Debian</td>
<td>Debian&#x2F;Ubuntu</td>
<td>dpkg</td>
<td>apt-get</td>
<td>*.deb</td>
</tr>
</tbody></table>
<p>简单点了说，如果你会在Fedora或者CentOS上用yum来自动安装软件包，那么在Debian或者Ubuntu上你就会用apt-get自动安装软件，同理，在openSUSE上你就会用zypper自动安装软件包。<br>   本文档主要描述如何通过软件包的源代码构建自己的rpm软件安装包。<br>   从软件运行的结构来说，一个软件主要可以分为三个部分：可执行程序、配置文件和动态库。当然还有可能会有相关文档、手册、供二次开发用的头文件以及一些示例程序等等。其他部分都是可选的，只有可执行文件是必须的。<br>   关于如何制作rpm软件包的方法，网上教程也一大堆，谈及最多的当属rpmbuild这个命令行工具。这也是本文要介绍的“配角”，而主角是它的输入对象，也就是所谓的SPEC文件的格式，写法和说明。<br>   rpm的打包流程相比deb的要稍微麻烦一些，因为它对打包目录有一些严格的层次上的要求。如果你的rpm的版本&lt;&#x3D;4.4.x，那么rpmbuid工具其默认的工作路径是&#x2F;usr&#x2F;src&#x2F;redhat，这就使得普通用户不能制作rpm包，因为权限的问题，在制作rpm软件包时必须切换到root身份才可以。所以，rpm从4.5.x版本开始，将rpmbuid的默认工作路径移动到用户家目录下的rpmbuild目录里，即$HOME&#x2F;rpmbuild，并且推荐用户在制作rpm软件包时尽量不要以root身份进行操作。<br>   关于rpmbuild默认工作路径的确定，通常由在&#x2F;usr&#x2F;lib&#x2F;rpm&#x2F;macros这个文件里的一个叫做**%_topdir**的宏变量来定义。如果用户想更改这个目录名，rpm官方并不推荐直接更改这个目录，而是在用户家目录下建立一个名为.rpmmacros的隐藏文件(注意前面的点不能少，这是Linux下隐藏文件的常识)，然后在里面重新定义%_topdir，指向一个新的目录名。这样就可以满足某些“高级”用户的差异化需求了。通常情况下.rpmmacros文件里一般只有一行内容，比如：</p>
<p>*%_topdir    $HOME&#x2F;myrpmbuildenv **    ****   在%_topdir目录下一般需要建立6个目录： ***</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>说明</th>
<th>macros中的宏名</th>
</tr>
</thead>
<tbody><tr>
<td>BUILD</td>
<td>编译rpm包的临时目录</td>
<td>%_builddir</td>
</tr>
<tr>
<td>BUILDROOT</td>
<td>编译后生成的软件临时安装目录</td>
<td>%_buildrootdir</td>
</tr>
<tr>
<td>RPMS</td>
<td>最终生成的可安装rpm包的所在目录</td>
<td>%_rpmdir</td>
</tr>
<tr>
<td>SOURCES</td>
<td>所有源代码和补丁文件的存放目录</td>
<td>%_sourcedir</td>
</tr>
<tr>
<td>SPECS</td>
<td>存放SPEC文件的目录(重要)</td>
<td>%_specdir</td>
</tr>
<tr>
<td>SRPMS</td>
<td>软件最终的rpm源码格式存放路径(暂时忽略掉，别挂在心上)</td>
<td>%_srcrpmdir</td>
</tr>
</tbody></table>
<p>   小技巧：执行<strong>rpmdev-setuptree</strong>会在当前用户家目录下的rpmbuild目录(如果该目录不存在也会被自动创建)里自动建立上述目录。<br>   当上述目录建立好之后，将所有用于生成rpm包的源代码、shell脚本、配置文件都拷贝到SOURCES目录里，注意<strong>通常</strong>情况下源码的压缩格式都为*.tar.gz格式(当然还可以为其他格式，但那就是另外一种方式，这里先不介绍)。然后，将最最最重要的SPEC文件，命名格式一般是“软件名-版本.spec”的形式，将其拷贝到SPECS目录下，切换到该目录下执行： </p>
<p>*rpmbuild -bb 软件名-版本.spec     ***</p>
<p> 最终我们想要的rpm软件包就安安稳稳地躺在RPMS目录下了。对，就这么简单。</p>
<p>这里的关键就是上面的SPEC文件的写法，我们可以用rpmdev-newspec -o <em>Name-version</em>.spec命令来生成SPEC文件的模板，然后在上面修改就可。例如： </p>
<p>点击(此处)折叠或打开 </p>
<p>[root@localhost ~]# rpmdev-newspec -o myapp-0.1.0.spec</p>
<p>Skeleton specfile (minimal) has been created to “myapp-0.1.0.spec”.</p>
<p>[root@localhost ~]# cat myapp-0.1.0.spec </p>
<p>Name: myapp-0.1.0</p>
<p>Version:</p>
<p>Release: 1%{?dist}</p>
<p>Summary:</p>
<p>Group:</p>
<p>License:</p>
<p>URL:</p>
<p>Source0:</p>
<p>BuildRoot: %{_tmppath}&#x2F;%{name}-%{version}-%{release}-root-%(%{__id_u} -n)</p>
<p>BuildRequires:</p>
<p>Requires:</p>
<p>%description</p>
<p>%prep</p>
<p>%setup -q</p>
<p>%build</p>
<p>%configure</p>
<p>make %{?_smp_mflags}</p>
<p>%install</p>
<p>rm -rf $RPM_BUILD_ROOT</p>
<p>make install DESTDIR&#x3D;$RPM_BUILD_ROOT</p>
<p>%clean</p>
<p>rm -rf $RPM_BUILD_ROOT</p>
<p>%files</p>
<p>%defattr(-,root,root,-)</p>
<p>%doc</p>
<p>%changelog </p>
<p>​    其实SPEC文件的核心是它定义了一些“阶段”(%prep、%build、%install和%clean)，当rpmbuild执行时它首先会去解析SPEC文件，然后依次执行每个“阶段”里的指令。<br>   接下来，我们来简单了解一下SPEC文件的头部。假如，我们的源码包名字是myapp-0.1.0.tar.gz，那么myapp-0.1.0.spec的头部一般如下的样子： </p>
<p>点击(此处)折叠或打开 </p>
<p>Name:                  myapp &lt;&#x3D;&#x3D;&#x3D;软件包的名字(后面会用到) </p>
<p>Version:               0.1.0 &lt;&#x3D;&#x3D;&#x3D;软件包的版本(后面会用到) </p>
<p>Release:               1%{?dist} &lt;&#x3D;&#x3D;&#x3D;发布序号 </p>
<p>Summary:               my first rpm &lt;&#x3D;&#x3D;&#x3D;软件包的摘要信息 </p>
<p>Group:                 &lt;&#x3D;&#x3D;&#x3D;软件包的安装分类，参见&#x2F;usr&#x2F;share&#x2F;doc&#x2F;rpm-4.x.x&#x2F;GROUPS这个文件 </p>
<p>License:               GPL &lt;&#x3D;&#x3D;&#x3D;软件的授权方式 </p>
<p>URL:                   &lt;&#x3D;&#x3D;&#x3D;这里本来写源码包的下载路径或者自己的博客地址或者公司网址之类 </p>
<p>Source0:               %{name}-%{version}.tar.gz &lt;&#x3D;&#x3D;&#x3D;源代码包的名称(默认时rpmbuid回到SOURCES目录中去找)，这里的name和version就是前两行定义的值。如果有其他配置或脚本则依次用Source1、Source2等等往后增加即可。 </p>
<p>BuildRoot:             %{_topdir}&#x2F;BUILDROOT &lt;&#x3D;&#x3D;&#x3D; 这是make install时使用的“虚拟”根目录，最终制作rpm安装包的文件就来自这里。 </p>
<p>BuildRequires:         &lt;&#x3D;&#x3D;&#x3D; 在本机编译rpm包时需要的辅助工具，以逗号分隔。假如，要求编译myapp时，gcc的版本至少为4.4.2，则可以写成gcc &gt;&#x3D;4.2.2。还有其他依赖的话则以逗号分别继续写道后面。 </p>
<p>Requires:              &lt;&#x3D;&#x3D;&#x3D; 编译好的rpm软件在其他机器上安装时，需要依赖的其他软件包，也以逗号分隔，有版本需求的可以 </p>
<p>%description           &lt;&#x3D;&#x3D;&#x3D; 软件包的详细说明信息，但最多只能有80个英文字符。 </p>
<p>​    下面我们来看一下制作rpm包的几个关键阶段，以及所发生的事情：  </p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>%prep</td>
<td>将%_sourcedir目录下的源代码解压到%_builddir目录下。如果有补丁的需要在这个阶段进行打补丁的操作</td>
</tr>
<tr>
<td>%build</td>
<td>在%_builddir目录下执行源码包的编译。一般是执行.&#x2F;configure和make指令</td>
</tr>
<tr>
<td>%install</td>
<td>将需要打包到rpm软件包里的文件从%_builddir下拷贝%_buildrootdir目录下。当用户最终用rpm -ivh name-version.rpm安装软件包时，这些文件会安装到用户系统中相应的目录里</td>
</tr>
<tr>
<td>制作rpm包</td>
<td>这个阶段是自动完成的，所以在SPEC文件里面是看不到的，这个阶段会将%_buildroot目录的相关文件制作成rpm软件包最终放到%_rpmdir目录里</td>
</tr>
<tr>
<td>%clean</td>
<td>编译后的清理工作，这里可以执行make clean以及清空%_buildroot目录等</td>
</tr>
</tbody></table>
<p>​    每个阶段的详细说明如下： </p>
<h4 id="1-21-2-1-prep阶段"><a href="#1-21-2-1-prep阶段" class="headerlink" title="1.21.2.1 %prep阶段"></a>1.21.2.1 %prep阶段</h4><p>​    这个阶段里通常情况，主要完成对源代码包的解压和打补丁(如果有的话)，而解压时最常见到的就是一句指令：</p>
<p>*%setup -q ***</p>
<p>当然，这句指令可以成功执行的前提是你位于SOURCES目录下的源码包必须是name-version.tar.gz的格式才行，它还会完成后续阶段目录的切换和设置。如果在这个阶段你不用这条指令，那么后面每个阶段都要自己手动去改变相应的目录。解压完成之后如果有补丁文件，也在这里做。想了解的童鞋可以自己去查查如何实现，也不难，这里我就不展开了。</p>
<h4 id="1-21-2-2-build阶段"><a href="#1-21-2-2-build阶段" class="headerlink" title="1.21.2.2 %build阶段"></a>1.21.2.2 %build阶段</h4><p>这个阶段就是执行常见的configure和make操作，如果有些软件需要最先执行bootstrap之类的，可以放在configure之前来做。这个阶段我们最常见只有两条指令： </p>
<p>%configure </p>
<p>make %{?_smp_mflags} </p>
<p>​    它就自动将软件安装时的路径自动设置成如下约定：</p>
<ol>
<li><p>可执行程序&#x2F;usr&#x2F;bin </p>
</li>
<li><p>依赖的动态库&#x2F;usr&#x2F;lib或者&#x2F;usr&#x2F;lib64视操作系统版本而定。 </p>
</li>
<li><p>二次开发的头文件&#x2F;usr&#x2F;include</p>
</li>
</ol>
<h4 id="1-21-2-3-文档及手册-x2F-usr-x2F-share-x2F-man"><a href="#1-21-2-3-文档及手册-x2F-usr-x2F-share-x2F-man" class="headerlink" title="1.21.2.3 文档及手册&#x2F;usr&#x2F;share&#x2F;man"></a>1.21.2.3 文档及手册&#x2F;usr&#x2F;share&#x2F;man</h4><p>注意，这里的%configure是个宏常量，会自动将prefix设置成&#x2F;usr。另外，这个宏还可以接受额外的参数，如果某些软件有某些高级特性需要开启，可以通过给%configure宏传参数来开启。如果不用 %configure这个宏的话，就需要完全手动指定configure时的配置参数了。同样地，我们也可以给make传递额外的参数，例如： </p>
<p>make %{?_smp_mflags} CFLAGS&#x3D;”” … </p>
<h4 id="1-21-2-4-install阶段"><a href="#1-21-2-4-install阶段" class="headerlink" title="1.21.2.4 %install阶段"></a>1.21.2.4 %install阶段</h4><p>​    这个阶段就是执行make install操作。这个阶段会在%_buildrootdir目录里建好目录结构，然后将需要打包到rpm软件包里的文件从%_builddir里拷贝到%_buildrootdir里对应的目录里。这个阶段最常见的两条指令是： </p>
<ol>
<li>rm -rf $RPM_BUILD_ROOT</li>
</ol>
<p>make install DESTDIR&#x3D;$RPM_BUILD_ROOT </p>
<p>   其中$RPM_BUILD_ROOT也可以换成我们前面定义的BuildRoot变量，不过要写成%{buildroot}才可以，必须全部用小写，不然要报错。<br>   如果软件有配置文件或者额外的启动脚本之类，就要手动用copy命令或者install命令你给将它也拷贝到%{buildroot}相应的目录里。用copy命令时如果目录不存在要手动建立，不然也会报错，所以推荐用install命令。  </p>
<h4 id="1-21-2-5-clean阶段"><a href="#1-21-2-5-clean阶段" class="headerlink" title="1.21.2.5 %clean阶段"></a>1.21.2.5 %clean阶段</h4><p>​    编译完成后一些清理工作，主要包括对%{buildroot}目录的清空(当然这不是必须的)，通常执行诸如make clean之类的命令。  </p>
<h4 id="1-21-2-6-制作rpm软件包的阶段"><a href="#1-21-2-6-制作rpm软件包的阶段" class="headerlink" title="1.21.2.6 制作rpm软件包的阶段"></a>1.21.2.6 制作rpm软件包的阶段</h4><p>这个阶段必须引出下面一个叫做%files的阶段。它主要用来说明会将%{buildroot}目录下的哪些文件和目录最终打包到rpm包里。</p>
<p>%files </p>
<p>%defattr(-,root,root,-) </p>
<p>%doc </p>
<p>​    在%files阶段的第一条命令的语法是： </p>
<p>*%defattr(文件权限,用户名,组名,目录权限) ***</p>
<p>如果不牵扯到文件、目录权限的改变则一般用%defattr(-,root,root,-)这条指令来为其设置缺省权限。所有需要打包到rpm包的文件和目录都在这个地方列出，例如： </p>
<p>%files </p>
<p>%{_bindir}&#x2F;* </p>
<p>%{_libdir}&#x2F;* </p>
<p>%config(noreplace) %{_sysconfdir}&#x2F;*.conf </p>
<p>在安装rpm时，会将可执行的二进制文件放在&#x2F;usr&#x2F;bin目录下，动态库放在&#x2F;usr&#x2F;lib或者&#x2F;usr&#x2F;lib64目录下，配置文件放在&#x2F;etc目录下，并且多次安装时新的配置文件不会覆盖以前已经存在的同名配置文件。<br>   这里在写要打包的文件列表时，既可以以宏常量开头，也可以为“&#x2F;”开头，没任何本质的区别，都表示从%{buildroot}中拷贝文件到最终的rpm包里；如果是相对路径，则表示要拷贝的文件位于%{_builddir}目录，这主要适用于那些在%install阶段没有被拷贝到%{buildroot}目录里的文件，最常见的就是诸如README、LICENSE之类的文件。如果不想将%{buildroot}里的某些文件或目录打包到rpm里，则用： </p>
<p>*%exclude dic_name或者file_name ***</p>
<p>但是关于%files阶段有两个特性要牢记：</p>
<p>%{buildroot}里的所有文件都要明确被指定是否要被打包到rpm里。什么意思呢？假如，%{buildroot}目录下有4个目录a、b、c和d，在%files里仅指定a和b要打包到rpm里，如果不把c和d用exclude声明是要报错的； </p>
<p>如果声明了%{buildroot}里不存在的文件或者目录也会报错。 </p>
<p> 关于%doc宏，所有跟在这个宏后面的文件都来自%{_builddir}目录，当用户安装rpm时，由这个宏所指定的文件都会安装到&#x2F;usr&#x2F;share&#x2F;doc&#x2F;<em>name</em>-<em>version</em>&#x2F;目录里。</p>
<h4 id="1-21-2-7-changelog阶段"><a href="#1-21-2-7-changelog阶段" class="headerlink" title="1.21.2.7 %changelog阶段"></a>1.21.2.7 %changelog阶段</h4><p>​    这是最后一个阶段，主要记录的每次打包时的修改变更日志。标准格式是： </p>
<p>** date +”%a %b %d %Y” 修改人 邮箱 本次版本x.y.z-p ***</p>
<p>*- 本次变更修改了那些内容 ***</p>
<p>   说了这么多，我们实战一下。网上很多教程都是拿Tomcat或者Nigix开头，这里我就先从简单的mp3解码库libmad入手，将它打成一个rpm包，具体步骤如下： </p>
<p>​    (如果自己系统上没有rpmbuild命令就安装之：yum install rpm* rpm-build rpmdev*)</p>
<p>​    1、构建rpm的编译目录结构：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps20.png" alt="img"> </p>
<p>   2、下载libmad源码到rpmbuild&#x2F;SOURCES目录下，可以从 <a target="_blank" rel="noopener" href="http://downloads.sourceforge.net/mad/libmad-0.15.1b.tar.gz">http://downloads.sourceforge.net/mad/libmad-0.15.1b.tar.gz</a>这里下载。 </p>
<p>​    3、在rpmbuild&#x2F;SPECS目录下执行rpmdev-newspec -o libmad-0.15.1b.spec，会在当前目录下生成名为libmad-0.15.1b.spec的模板文件。 </p>
<p>​    4、将libmad-0.15.1b.spec修改成如下的样子：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps21.png" alt="img"> </p>
<p>​    5、在rpmbuild&#x2F;SPECS目录下执行打包编译： </p>
<p>*rpmbuild -bb libmad-0.15.1b.spec ***</p>
<p>​    最终生成的rpm包如下：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps22.png" alt="img"> </p>
<p>​    因为我是64位系统，所以编译出的libmad适用于CentOS6.0-64。 </p>
<p>​    如果我们将libmad的源码和spec文件拷贝32位系统上，再执行rpm打包，看看结果：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps23.png" alt="img"> </p>
<p>​    结果如下：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps24.png" alt="img"> </p>
<p>后记：<br>   关于SPEC文件，还有一些其他特性，诸如安装软件包之前、之后要做的事情，以及卸载软件包之前之后要做的事情，包括给源码打补丁，关于这些特性感兴趣的童鞋自己去摸索吧。最后给出一个完整的，包含了打补丁、安装、卸载特性的SPEC文件模板：</p>
<p>点击(此处)折叠或打开 </p>
<p>Name: test </p>
<p>Version: </p>
<p>Requires: </p>
<p>%description </p>
<p>… </p>
<p>#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;SPEC头部&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </p>
<p>%prep </p>
<p>%setup -q </p>
<p>%patch &lt;&#x3D;&#x3D;&#x3D;&#x3D; 在这里打包 </p>
<p>%build </p>
<p>%configure </p>
<p>make %{?_smp_mflags} </p>
<p>%install </p>
<p>rm -rf $RPM_BUILD_ROOT </p>
<p>make install DESTDIR&#x3D;$RPM_BUILD_ROOT </p>
<p>%clean </p>
<p>rm -rf $RPM_BUILD_ROOT </p>
<p>%files </p>
<p>%defattr(-,root,root,-) </p>
<p>要打包到rpm包里的文件清单 </p>
<p>%doc </p>
<p>%changelog </p>
<p>#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;SPEC主体&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </p>
<p>%pre </p>
<p>安装或者升级软件前要做的事情，比如停止服务、备份相关文件等都在这里做。 </p>
<p>%post </p>
<p>安装或者升级完成后要做的事情，比如执行ldconfig重构动态库缓存、启动服务等。 </p>
<p>%preun </p>
<p>卸载软件前要做的事情，比如停止相关服务、关闭进程等。 </p>
<p>%postun </p>
<p>卸载软件之后要做的事情，比如删除备份、配置文件等。 </p>
<h2 id="1-22-ping包问题"><a href="#1-22-ping包问题" class="headerlink" title="1.22 ping包问题"></a>1.22 ping包问题</h2><p>ping指定的主机，当回响信息分别为目的地不可达、超时、未知的主机名时，分析各自可能的故障原因</p>
<p>一、 目的地不可达，可能出现原因：<br>1．对方服务器与外网断开连接；<br>2．对方服务器拒绝Ping入；<br>3．对方服务器拒绝Ping出；<br>4．自己计算机与外网已经断开连接。<br>二、超时，可能出现原因：<br>1、网卡安装或配置有问题。将网线断开再次执行此命令，如果显示正常，则说明本机使用的IP地址可能与另一台正在使用的机器IP地址重复了。如果仍然不正常，则表明本机网卡安装或配置有问题，需继续检查相关网络配置。<br>2、对方拒绝接收你发给它的数据包造成数据包丢失。大多数的原因可能是对方装有防火墙或已下线。<img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps25.png" alt="img"><br>三、未知的主机名，可能出现原因：<br>1、对方主机不存在或者没有跟对方建立连接。<br>2、主机文件存在问题。</p>
<h2 id="1-23-linux-M格式问题"><a href="#1-23-linux-M格式问题" class="headerlink" title="1.23 linux ^M格式问题"></a>1.23 linux ^M格式问题</h2><p>在linux下，不可避免的会用VIM打开一些windows下编辑过的文本文件。我们会发现文件的每行结尾都会有一个^M符号，这是因为 DOS下的编辑器和Linux编辑器对文件行末的回车符处理不一致， </p>
<p>对于回车符的定义： </p>
<p>windows：0D0A </p>
<p>unix\linux: 0A </p>
<p>MAC: 0D </p>
<p>比较快捷的去除这些符号的方法有这么几种： </p>
<p>（1）是用VI的命令： </p>
<p>​    使用vi打开文本文件 </p>
<p>​    vi dos.txt </p>
<p>​    命令模式下输入 </p>
<p>​    :set fileformat&#x3D;unix </p>
<p>​    :w </p>
<p>(2) VI下使用正则表达式替换 </p>
<p>   g&#x2F;^M&#x2F;s&#x2F;^M&#x2F;&#x2F; </p>
<p>​    或者 </p>
<p>   %s&#x2F;^M&#x2F;&#x2F;g </p>
<p>（3）使用sed 工具 </p>
<p>​    sed ’s&#x2F;^M&#x2F;&#x2F;’ filename &gt; tmp_filename </p>
<p>（4）既然window下的回车符多了‘\r’，那么当然通过删除‘\r’ ，也可以实现： </p>
<p>​    tr -d ‘\r’ </p>
<p>（5）最后一个方法是本人最常用的方法，个人觉得最方便 </p>
<p>​    在终端下敲命令： </p>
<p>​    $ dos2unix filename </p>
<p>​    直接转换成unix格式，就OK了！～  </p>
<h2 id="1-24-linux下解决端口被占用问题"><a href="#1-24-linux下解决端口被占用问题" class="headerlink" title="1.24 linux下解决端口被占用问题"></a>1.24 linux下解决端口被占用问题</h2><p>查找被占用的端口：</p>
<p>netstat -tln</p>
<p>netstat -tln | grep 8080</p>
<p>查看端口属于哪个程序</p>
<p>lsof -i :8080</p>
<p>杀掉占用端口的进程：</p>
<p>kill -9 进程ID</p>
<p>ps -ef | grep xxx</p>
<p>kill xxx</p>
<h2 id="1-25-切换系统中英文"><a href="#1-25-切换系统中英文" class="headerlink" title="1.25 切换系统中英文"></a>1.25 切换系统中英文</h2><p>修改&#x2F;etc&#x2F;sysconfig&#x2F;i18n</p>
<p>LANG&#x3D;”zh_CN.UTF-8”</p>
<p>LANG&#x3D;”en_US.UTF-8”</p>
<h1 id="第-2-章-Linux软件"><a href="#第-2-章-Linux软件" class="headerlink" title="第 2 章 Linux软件"></a>第 2 章 Linux软件</h1><h2 id="2-1-boa配置"><a href="#2-1-boa配置" class="headerlink" title="2.1 boa配置"></a>2.1 boa配置</h2><h3 id="2-1-1-boa-conf"><a href="#2-1-1-boa-conf" class="headerlink" title="2.1.1 boa.conf"></a>2.1.1 boa.conf</h3><p>&#x2F;etc&#x2F;boa&#x2F;下的boa.conf如下：</p>
<p><em>Port 80</em>**</p>
<p><em>User root</em>**</p>
<p><em>Group root</em>**</p>
<p><em>ErrorLog &#x2F;dev&#x2F;console</em>**</p>
<p><em>AccessLog &#x2F;dev&#x2F;null</em>**</p>
<p><em>ServerName friendly-arm</em>**</p>
<p><em>DocumentRoot &#x2F;dau&#x2F;boa</em>**</p>
<p><em>#DocumentRoot &#x2F;www</em>**</p>
<p><em>DirectoryIndex index.html</em>**</p>
<p><em>KeepAliveMax 1000</em>**</p>
<p><em>KeepAliveTimeout 10</em>**</p>
<p><em>MimeTypes &#x2F;etc&#x2F;mime.types</em>**</p>
<p><em>DefaultType text&#x2F;plain</em>**</p>
<p><em>CGIPath &#x2F;bin:&#x2F;daucgipath</em>**</p>
<p><em>AddType application&#x2F;x-httpd-cgi cgi</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<h2 id="2-2-Vi编辑器"><a href="#2-2-Vi编辑器" class="headerlink" title="2.2 Vi编辑器"></a>2.2 <a href="">Vi编辑器</a></h2><p>Vim		vi  improved</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps26.jpg" alt="img"> </p>
<p>i    在光标前插入</p>
<p>a	  在光标后插入</p>
<h3 id="2-2-1-进入VI"><a href="#2-2-1-进入VI" class="headerlink" title="2.2.1 进入VI"></a>2.2.1 进入VI</h3><p>vi  a.x</p>
<h3 id="2-2-2-退出Vi"><a href="#2-2-2-退出Vi" class="headerlink" title="2.2.2 退出Vi"></a>2.2.2 退出Vi</h3><p>:q! 				强制退出	</p>
<p>:wq					保存退出</p>
<p>w	filename		另存为文件</p>
<p>^					光标跳转至行首</p>
<p>$					光标跳转至行尾</p>
<p>:set  nu			显示行号</p>
<p>nG 				跳转至文件中的第n行</p>
<p>dd					删除光标所在行</p>
<p>ndd				删除光标所在行向下删除n行</p>
<p>u					取消最后一次操作</p>
<p>yy					复制当前行</p>
<p>nyy	&#x2F;yny			复制n行</p>
<p>p					读取vi缓冲区的内容，并粘贴到光标当前位置</p>
<p>&#x2F;word				从上而下查找“word”</p>
<p>?word				从下而上查找“word”</p>
<p>n					查找下一个匹配的被查找字符串</p>
<h3 id="2-2-3-调用shell命令"><a href="#2-2-3-调用shell命令" class="headerlink" title="2.2.3 调用shell命令"></a>2.2.3 调用shell命令</h3><p>e.g.    :r!ls  &#x2F;root  把文件列表插入当前编辑文本中</p>
<h3 id="2-2-4-编译过程四个阶段"><a href="#2-2-4-编译过程四个阶段" class="headerlink" title="2.2.4 编译过程四个阶段"></a>2.2.4 编译过程四个阶段</h3><p>l 预处理(Pre-Processing) </p>
<p>在该阶段，编译器将C源代码中的包含的头文件如stdio.h编译进来，用户可以使用gcc的选项”-E”进行查看。 </p>
<p>用法：#gcc -E hello.c -o hello.i </p>
<p>作用：将hello.c预处理输出hello.i文件。</p>
<p>l 编译(Compiling) </p>
<p>第二步进行的是编译阶段，在这个阶段中，Gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，Gcc把代码翻译成汇编语言。用户可以使用”-S”选项来进行查看，该选项只进行编译而不进行汇编，生成汇编代码。</p>
<p>选项 -S </p>
<p>用法：[root]# gcc –S hello.i –o hello.s </p>
<p>作用：将预处理输出文件hello.i汇编成hello.s文件。</p>
<p>l 汇编(Assembling) </p>
<p>汇编阶段是把编译阶段生成的”.s”文件转成二进制目标代码. </p>
<p>选项 -c </p>
<p>用法：[root]# gcc –c  hello.s –o  hello.o </p>
<p>作用：将汇编输出文件test.s编译输出test.o文件。</p>
<p>l 链接(Linking)</p>
<p>在成功编译之后，就进入了链接阶段。</p>
<p>无选项链接 </p>
<p>用法：[root]# gcc  hello.o –o  hello.exe </p>
<p>作用：将编译输出文件hello.o链接成最终可执行文件hello.exe。</p>
<h3 id="2-2-5-gcc常用编译选项"><a href="#2-2-5-gcc常用编译选项" class="headerlink" title="2.2.5 gcc常用编译选项"></a>2.2.5 gcc常用编译选项</h3><p>-c	 只编译，不连接成为可执行文件，编译器只是由输入的.c等源代码文件生成.o为后缀的目标文件。</p>
<p>-o  output_filename：确定可执行文件的名称为output_filename。如果不给出这个选项，gcc就给出预设的可执行文件a.out。(演示)</p>
<p>-g	 产生调试工具(GNU的gdb)所必要的符号信息，要想对编译出的程序进行调试，就必须加入这个选项。</p>
<p>-O	 对程序进行优化编译、链接，采用这个选项，整个源代码会在编译、连接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是，编译、连接的速度就相应地要慢一些。</p>
<p>-O2	  比-O更好的优化编译、连接，当然整个编译、连接过程会更慢。</p>
<p>-Wall	生成所有警告信息</p>
<p>gcc  –O 	optimize.c   -o   optimizetime   .&#x2F;optimize</p>
<h1 id="第-3-章-Linux基础"><a href="#第-3-章-Linux基础" class="headerlink" title="第 3 章 Linux基础"></a>第 3 章 Linux基础</h1><p>Linux严格说只是一个操作系统内核，实现了操作系统的核心功能：内存管理、进程管理、文件系统管理、和设备管理等。</p>
<h2 id="3-1-Linux标准目录"><a href="#3-1-Linux标准目录" class="headerlink" title="3.1 Linux标准目录"></a>3.1 <a href="">Linux标准目录</a></h2><p>· root — 启动<a target="_blank" rel="noopener" href="http://linux-wiki.cn/wiki/Linux">Linux</a>时使用的一些核心文件。如操作系统<a target="_blank" rel="noopener" href="http://linux-wiki.cn/index.php?title=%E5%86%85%E6%A0%B8&action=edit&redlink=1">内核</a>、引导程序<a target="_blank" rel="noopener" href="http://linux-wiki.cn/wiki/Category:Grub">Grub</a>等。</p>
<p>· home — 存储普通用户的个人文件</p>
<p>· ftp — 用户所有服务</p>
<p>· httpd</p>
<p>· samba</p>
<p>· user1</p>
<p>· user2</p>
<p>· bin — 系统启动时需要的执行文件（二进制）</p>
<p>· sbin — 可执行程序的目录，但大多存放涉及系统管理的命令。只有root权限才能执行</p>
<p>· proc — 虚拟，存在linux内核镜像；保存所有内核参数以及系统配置信息</p>
<p>· usr — 用户目录，存放用户级的文件</p>
<p>· bin — 几乎所有用户所用命令，另外存在与&#x2F;bin，&#x2F;usr&#x2F;local&#x2F;bin</p>
<p>· sbin — 系统管理员命令，与用户相关，例如，大部分服务器程序</p>
<p>· include —  存放C&#x2F;C++头文件的目录</p>
<p>· lib — 固定的程序数据</p>
<p>· local — 本地安装软件保存位置</p>
<p>· man — 手工生成的目录</p>
<p>· info — 信息文档</p>
<p>· doc — 不同包文档信息</p>
<p>· tmp</p>
<p>· X11R6 —  该目录用于保存运行X-Window所需的所有文件。该目录中还包含用于运行GUI要的配置文件和二进制文件。</p>
<p>· X386　— 功能同X11R6，X11 发行版5 的系统文件</p>
<p>· boot — 引导加载器所需文件，系统所需图片保存于此</p>
<p>· lib — 根文件系统目录下程序和核心模块的公共库</p>
<p>· modules — 可加载模块，系统崩溃后重启所需模块</p>
<p>· dev — 设备文件目录</p>
<p>· etc — 配置文件</p>
<p>· skel — home目录建立，该目录初始化</p>
<p>· sysconfig — 网络，时间，键盘等配置目录</p>
<p>· var</p>
<p>· file</p>
<p>· lib — 该目录下的文件在系统运行时，会改变</p>
<p>· local — 安装在&#x2F;usr&#x2F;local的程序数据，变化的</p>
<p>· lock — 文件使用特定外设或文件，为其上锁，其他文件暂时不能访问</p>
<p>· log — 记录日志</p>
<p>· run — 系统运行合法信息</p>
<p>· spool — 打印机、邮件、代理服务器等假脱机目录</p>
<p>· tmp</p>
<p>· catman — 缓存目录</p>
<p>· mnt — 临时用于挂载文件系统的地方。一般情况下这个目录是空的，而在我们将要挂载分区时在这个目录下建立目录，再将我们将要访问的设备<a target="_blank" rel="noopener" href="http://linux-wiki.cn/wiki/Category:Mount">挂载</a>在这个目录上，这样我们就可访问文件了。</p>
<p>· tmp — 临时文件目录，系统启动后的临时文件存放在&#x2F;var&#x2F;tmp</p>
<p>· lost+found — 在文件系统修复时恢复的文件</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps27.png" alt="img"> <strong>&#x2F;：</strong>根目录，一般根目录下只存放目录，不要存放文件，&#x2F;etc、&#x2F;bin、&#x2F;dev、&#x2F;lib、&#x2F;sbin应该和根目录放置在一个分区中</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps28.png" alt="img"> **&#x2F;bin:&#x2F;usr&#x2F;bin:**可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps29.png" alt="img"> <strong>&#x2F;boot：</strong>放置linux系统启动时用到的一些文件。&#x2F;boot&#x2F;vmlinuz为linux的内核文件，以及&#x2F;boot&#x2F;gurb。建议单独分区，分区大小100M即可</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps30.png" alt="img"> <strong>&#x2F;dev：</strong>存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount &#x2F;dev&#x2F;cdrom &#x2F;mnt。</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps31.png" alt="img"> <strong>&#x2F;etc：</strong>系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有&#x2F;etc&#x2F;inittab、&#x2F;etc&#x2F;fstab、&#x2F;etc&#x2F;init.d、&#x2F;etc&#x2F;X11、&#x2F;etc&#x2F;sysconfig、&#x2F;etc&#x2F;xinetd.d修改配置文件之前记得备份。注：&#x2F;etc&#x2F;X11存放与x windows有关的设置。</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps32.png" alt="img"> <strong>&#x2F;home：</strong>系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，<del>表示当前用户的家目录，</del>test表示用户test的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps33.png" alt="img"> <strong>&#x2F;lib:&#x2F;usr&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib：</strong>系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为&#x2F;lib&#x2F;modules。</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps34.png" alt="img"> <strong>&#x2F;lost+fount：</strong>系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于&#x2F;disk 中，此目录下就会自动产生目录&#x2F;disk&#x2F;lost+found</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps35.png" alt="img"> <strong>&#x2F;mnt:&#x2F;media：</strong>光盘默认挂载点，通常光盘挂载于&#x2F;mnt&#x2F;cdrom下，也不一定，可以选择任意位置进行挂载。</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps36.png" alt="img"> <strong>&#x2F;opt：</strong>给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的KDE 桌面软件，可以将该软件安装在该目录下。以前的 Linux 系统中，习惯放置在 &#x2F;usr&#x2F;local 目录下</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps37.png" alt="img"> <strong>&#x2F;proc：</strong>此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有&#x2F;proc&#x2F;cpuinfo、&#x2F;proc&#x2F;interrupts、&#x2F;proc&#x2F;dma、&#x2F;proc&#x2F;ioports、&#x2F;proc&#x2F;net&#x2F;*等</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps38.png" alt="img"> <strong>&#x2F;root：</strong>系统管理员root的家目录，系统第一个启动的分区为&#x2F;，所以最好将&#x2F;root和&#x2F;放置在一个分区下。</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps39.png" alt="img"> <strong>&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;sbin：</strong>放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。与&#x2F;bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能”查看”而不能设置和使用。</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps40.png" alt="img"> <strong>&#x2F;tmp：</strong>一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps41.png" alt="img"> <strong>&#x2F;srv：</strong>服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在&#x2F;srv&#x2F;www内</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps42.png" alt="img"> <strong>&#x2F;usr：</strong>应用程序存放目录，**&#x2F;usr&#x2F;bin<strong>存放应用程序，</strong>&#x2F;usr&#x2F;share<strong>存放共享数据，</strong>&#x2F;usr&#x2F;lib<strong>存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。</strong>&#x2F;usr&#x2F;local:<strong>存放软件升级包。</strong>&#x2F;usr&#x2F;share&#x2F;doc:<strong>系统说明文件存放目录。</strong>&#x2F;usr&#x2F;share&#x2F;man:** 程序说明文件存放目录，使用 man ls时会查询&#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;ls.1.gz的内容<strong>建议单独分区，设置较大的磁盘空间</strong></p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps43.png" alt="img"> <strong>&#x2F;var：</strong>放置系统执行过程中经常变化的文件，如随时更改的日志文件&#x2F;var&#x2F;log，**&#x2F;var&#x2F;log&#x2F;message：<strong>所有的登录文件存放目录，</strong>&#x2F;var&#x2F;spool&#x2F;mail<strong>：邮件存放的目录，</strong>&#x2F;var&#x2F;run:<strong>程序或服务启动后，其PID存放在该目录下。</strong>建议单独分区，设置较大的磁盘空间**</p>
<h2 id="3-2-Linux名词"><a href="#3-2-Linux名词" class="headerlink" title="3.2 Linux名词"></a>3.2 <a href="">Linux名词</a></h2><h3 id="3-2-1-NAT"><a href="#3-2-1-NAT" class="headerlink" title="3.2.1 NAT"></a>3.2.1 NAT</h3><p>network  address	translation	网络地址转换</p>
<h3 id="3-2-2-命名"><a href="#3-2-2-命名" class="headerlink" title="3.2.2 命名"></a>3.2.2 <a href="">命名</a></h3><p>linux 2.4.18     主版本号2		从版本号4 	补丁18</p>
<h2 id="3-3-快捷键"><a href="#3-3-快捷键" class="headerlink" title="3.3 快捷键"></a>3.3 <a href="">快捷键</a></h2><p>ctrl+Alt+F1    进入图形界面</p>
<p>ctrl+alt+F2&#x2F;F3    进入命令界面</p>
<p>​		+F7		返回</p>
<p>ctrl+D			结束</p>
<p>which+x		查询x是否存在</p>
<p>TAB			自动补全</p>
<p>Ctrl+Alt+à&#x2F;ß 切换虚拟机、切换workspace</p>
<p>Shift+ctrl+N   新建文件夹</p>
<h3 id="3-3-1-在终端界面下"><a href="#3-3-1-在终端界面下" class="headerlink" title="3.3.1 在终端界面下"></a>3.3.1 在终端界面下</h3><p>Shift+ctrl+N   新建窗口</p>
<p>Shift+ctrl+T   新建标签</p>
<p>Alt+1~9      切换标签页</p>
<p>复制：Shift+Ctrl+C</p>
<p>粘贴：Shift+Ctrl+V</p>
<p>开启新窗口：Shift+Ctrl+N</p>
<p>开启新分页（Tab）：Shift+Ctrl+T</p>
<h3 id="3-3-2-设置快捷键"><a href="#3-3-2-设置快捷键" class="headerlink" title="3.3.2 设置快捷键"></a>3.3.2 设置快捷键</h3><p>System-&gt;Preferences-&gt;Keyboard Shortcuts</p>
<p>在Desktop分类下找到“Run a terminal”</p>
<p>点击Run a terminal，按下需要的快捷键，比如Ctrl+Alt+T，即可。</p>
<h2 id="3-4-安装软件"><a href="#3-4-安装软件" class="headerlink" title="3.4 安装软件"></a>3.4 <a href="">安装软件</a></h2><p>A	.configure</p>
<p>B	make</p>
<p>C	make install</p>
<p>D	source	<a href="">&#x2F;etc&#x2F;profile</a>		保持环境变量生效</p>
<h2 id="3-5-文件操作"><a href="#3-5-文件操作" class="headerlink" title="3.5 文件操作"></a>3.5 <a href="">文件操作</a></h2><h3 id="3-5-1-rwx-rwx-rwx-文件拥有者-文件所有组-其他用户"><a href="#3-5-1-rwx-rwx-rwx-文件拥有者-文件所有组-其他用户" class="headerlink" title="3.5.1 -rwx rwx rwx   文件拥有者  文件所有组  其他用户"></a>3.5.1 -rwx rwx rwx   文件拥有者  文件所有组  其他用户</h3><p>-   普通文件</p>
<p>r	 可读</p>
<p>w	 可写</p>
<p>x	 可执行</p>
<h3 id="3-5-2-磁盘分区的文件名表示"><a href="#3-5-2-磁盘分区的文件名表示" class="headerlink" title="3.5.2 磁盘分区的文件名表示"></a>3.5.2 磁盘分区的文件名表示</h3><p>&#x2F;dev&#x2F;hda5</p>
<p>dev：所有设备文件的目录</p>
<p>hd：硬件设备代号  hd：IDE设备（Integrated-Drive-Electronics是原来普遍使用的外部接口，主要接硬盘和光驱）；sd：SCSI,SATA设备</p>
<p>a是指同类型设备编号  a：第一个硬盘，b：第二个硬盘</p>
<p>5是指分区号</p>
<h3 id="3-5-3-隐藏文件"><a href="#3-5-3-隐藏文件" class="headerlink" title="3.5.3 隐藏文件"></a>3.5.3 隐藏文件</h3><p>在文件前加.</p>
<h2 id="3-6-minicom"><a href="#3-6-minicom" class="headerlink" title="3.6 minicom"></a>3.6 <a href="">minicom</a></h2><p>Linux下串口通信软件</p>
<h2 id="3-7-开启root账户方法"><a href="#3-7-开启root账户方法" class="headerlink" title="3.7 开启root账户方法"></a>3.7 <a href="">开启root账户方法</a></h2><p>A 命令</p>
<p>sudo  passwd  root </p>
<p>禁用 sudo passwd  -l  root</p>
<p>B 在终端模式下切换root</p>
<p>​	 sudo  -s  -H</p>
<h2 id="3-8-fedora以root登录的方法"><a href="#3-8-fedora以root登录的方法" class="headerlink" title="3.8 fedora以root登录的方法"></a>3.8 <a href="">fedora以root登录的方法</a></h2><p>fedora从10开始就禁止了以root来登录系统,这个可能是出于安全的考虑,毕竟root的权限太大了,出余增强系统安全性,而且普通的账号可以运行一般应该用户的应用程序来说足够了,如果需要用到root权限时，会自动提示输入密码,可以说在安全考虑上做到相当完美了.</p>
<p>步骤&#x2F;方法</p>
<p>想用root登录系统该怎么办呢？在网上找到了资料解决如下:</p>
<p>修改目录 &#x2F;etc&#x2F;pam.d&#x2F;gdm与&#x2F;etc&#x2F;pam.d&#x2F;gdm-password两个文件</p>
<p>一般修改方法:</p>
<p>在终端中输入su命令并输入root密码这样我在终端中就有了root的操权限接下来我们使用gdit命令对其进行修改</p>
<p>gdit &#x2F;etc&#x2F;pam.d&#x2F;gdm</p>
<p>在这段”auth required pam_succeed_if.so user !&#x3D; root quiet”加上#号注释掉就可以了</p>
<p>同样的gdit &#x2F;etc&#x2F;pam.d&#x2F;gdm-password</p>
<p>也是在auth required pam_succeed_if.so user !&#x3D; root quiet前面加上#号注释</p>
<p>保存之后我们重启或者注销一次计算机就能以root进行登录系统了</p>
<p>当然如果会使用vi命令的话这个最方便</p>
<h2 id="3-9-重命名逻辑卷名"><a href="#3-9-重命名逻辑卷名" class="headerlink" title="3.9 重命名逻辑卷名"></a>3.9 <a href="">重命名逻辑卷名</a></h2><p>vgrename   原名  新名</p>
<p><strong>提示：最好不要使用，多次使用证明，这样会导致虚拟机无法打开</strong>****</p>
<h2 id="3-10-busybox"><a href="#3-10-busybox" class="headerlink" title="3.10 busybox"></a>3.10 <a href="">busybox</a></h2><p>BusyBox 是一个集成了一百多个最常用linux命令和工具的软件。BusyBox 包含了一些简单的工具，例如ls、cat和echo等等，还包含了一些更大、更复杂的工具，例grep、find、mount以及telnet。有些人将 BusyBox 称为 Linux 工具里的瑞士军刀。简单的说BusyBox就好像是个大工具箱，它集成压缩了 Linux 的许多工具和命令，也包含了 Android 系统的自带的shell。</p>
<h2 id="3-11-linux移植"><a href="#3-11-linux移植" class="headerlink" title="3.11 linux移植"></a>3.11 <a href="">linux移植</a></h2><p>修改rcS文件下的内容改变root@FrindlyARM</p>
<h3 id="3-11-1-Linux内核"><a href="#3-11-1-Linux内核" class="headerlink" title="3.11.1 Linux内核"></a>3.11.1 Linux内核</h3><p>Linux由内核空间和用户空间两部分组成。</p>
<h4 id="3-11-1-1-arch目录"><a href="#3-11-1-1-arch目录" class="headerlink" title="3.11.1.1 arch目录"></a>3.11.1.1 arch目录</h4><p>architecture的缩写，内核支持的每种CPU体系</p>
<h4 id="3-11-1-2-block"><a href="#3-11-1-2-block" class="headerlink" title="3.11.1.2 block"></a>3.11.1.2 block</h4><p>部分块设备的驱动程序</p>
<h4 id="3-11-1-3-drives"><a href="#3-11-1-3-drives" class="headerlink" title="3.11.1.3 drives"></a>3.11.1.3 drives</h4><p>设备驱动程序</p>
<h4 id="3-11-1-4-fs"><a href="#3-11-1-4-fs" class="headerlink" title="3.11.1.4 fs"></a>3.11.1.4 fs</h4><p>文件系统</p>
<h4 id="3-11-1-5-include"><a href="#3-11-1-5-include" class="headerlink" title="3.11.1.5 include"></a>3.11.1.5 include</h4><p>内核所需的头文件</p>
<h4 id="3-11-1-6-lib"><a href="#3-11-1-6-lib" class="headerlink" title="3.11.1.6 lib"></a>3.11.1.6 lib</h4><p>库文件代码</p>
<h4 id="3-11-1-7-mm"><a href="#3-11-1-7-mm" class="headerlink" title="3.11.1.7 mm"></a>3.11.1.7 mm</h4><p>用于实现内存管理与体系结构无关代码</p>
<h4 id="3-11-1-8-net"><a href="#3-11-1-8-net" class="headerlink" title="3.11.1.8 net"></a>3.11.1.8 net</h4><p>网络协议代码</p>
<h4 id="3-11-1-9-usr"><a href="#3-11-1-9-usr" class="headerlink" title="3.11.1.9 usr"></a>3.11.1.9 usr</h4><p>cpio命令实现</p>
<p>移植需要修改的两个目录：arch、driver</p>
<h3 id="3-11-2-内核配置与编译"><a href="#3-11-2-内核配置与编译" class="headerlink" title="3.11.2 内核配置与编译"></a>3.11.2 内核配置与编译</h3><p>内核配置		a.修改makefile里的ARCH	:&#x3D;	arm		b. make  menuconfig</p>
<p>建立依赖关系	make</p>
<p>创建内核镜像	make zImage</p>
<p>[1] 清除临时文件、中间文件、配置文件</p>
<p>make	clean</p>
<p>删除产生文件保留配置文件</p>
<p>make  mrproper</p>
<p>删除所有产生文件+config files</p>
<p>make  distclean</p>
<p>删除  mrproper+remove  editor  backup  and patch files</p>
<p>[2] 确定目标系统的软硬件配置情况，比如cpu类型、网卡型号、网络协议等。</p>
<p>[3] 使用如下命令配置内核</p>
<p>make  config			基于文本模式的交互式配置</p>
<p>make  menuconfig		基于文本模式的菜单型配置</p>
<p>make  oldconfig</p>
<p>make  xconfig			图形化界面配置</p>
<p>配置时，	*        Y</p>
<p>​			[ ]		  N       不编译</p>
<p>​			M		  module	只编译不连接</p>
<p>[4] 编译内核</p>
<p>make	zImage    小于512k的内核（在x86）</p>
<p>make  bzImage	</p>
<p>如需获取详细信息</p>
<p>make  zImage   v&#x3D;1</p>
<p>make  bzImage  v&#x3D;1</p>
<p>编译好的内核位于  arch &#x2F;<cpu>&#x2F;boot目录下</p>
<p>[5] 编译内核步骤</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps44.png" alt="img"> 以root用户登录</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps45.png" alt="img"> 拷贝config_mini6410_h43为文件.config</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps46.png" alt="img"> 执行make  menuconfig 定制内核组件</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps47.png" alt="img"> 编译内核  make  zImage</p>
<p>编译完成后内核镜像文件生成在&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;..</p>
<p>[6] 编译内核模块</p>
<p>make  modules</p>
<p>[7] 安装内核模块</p>
<p>make  modules_install</p>
<p>将编译好的内核模块从内核代码目录copy至&#x2F;lib&#x2F;modules下</p>
<p>[8] 制作init ramdisk</p>
<p>mkinitrd  initrd  -$version  $version</p>
<p>例如，mkinitrd  initrd-2.6.29   2.6.29</p>
<p>$version可以通过查询&#x2F;lib&#x2F;modules下的目录得到</p>
<h3 id="3-11-3-内核安装"><a href="#3-11-3-内核安装" class="headerlink" title="3.11.3 内核安装"></a>3.11.3 内核安装</h3><p>[1] cp  arch&#x2F;x86&#x2F;boot&#x2F;bzImage   &#x2F;boot&#x2F;vmlinuz		-$version</p>
<p>[2] cp  $initrd   &#x2F;boot&#x2F;</p>
<p>[3] 修改 &#x2F;etc&#x2F;grub.conf    或者&#x2F;etc&#x2F;lilo.conf</p>
<h3 id="3-11-4-内核模块"><a href="#3-11-4-内核模块" class="headerlink" title="3.11.4 内核模块"></a>3.11.4 内核模块</h3><h4 id="3-11-4-1-加载函数-module-init-hello-init"><a href="#3-11-4-1-加载函数-module-init-hello-init" class="headerlink" title="3.11.4.1 加载函数  module_init(hello_init)"></a>3.11.4.1 加载函数  module_init(hello_init)</h4><h4 id="3-11-4-2-卸载函数-module-exit-hello-exit"><a href="#3-11-4-2-卸载函数-module-exit-hello-exit" class="headerlink" title="3.11.4.2 卸载函数  module_exit(hello_exit)"></a>3.11.4.2 卸载函数  module_exit(hello_exit)</h4><h4 id="3-11-4-3-模块编译-makefile"><a href="#3-11-4-3-模块编译-makefile" class="headerlink" title="3.11.4.3 模块编译    makefile"></a>3.11.4.3 模块编译    makefile</h4><p>obj  -m :&#x3D;hello.o</p>
<p>hello-objs:&#x3D; main.o  add.o</p>
<p>obj-m:&#x3D;a.o</p>
<p>a-objs:&#x3D;main.o  add.o</p>
<h4 id="3-11-4-4-模块安装与卸载"><a href="#3-11-4-4-模块安装与卸载" class="headerlink" title="3.11.4.4 模块安装与卸载"></a>3.11.4.4 模块安装与卸载</h4><p>加载	insmod     	insmod  hello.ko</p>
<p>卸载	rmmod			rmmod  hello</p>
<p>查看	lsmod</p>
<p>加载	modprobe		modprobe  hello</p>
<h4 id="3-11-4-5-MODULE-LICENSE"><a href="#3-11-4-5-MODULE-LICENSE" class="headerlink" title="3.11.4.5 MODULE_LICENSE"></a>3.11.4.5 MODULE_LICENSE</h4><p>用来告知内核该模块带有一个许可证</p>
<p>module_author(“…”)</p>
<p>module_alias(“a simple”)</p>
<h4 id="3-11-4-6-模块参数"><a href="#3-11-4-6-模块参数" class="headerlink" title="3.11.4.6 模块参数"></a>3.11.4.6 模块参数</h4><p>通过宏module_param指定模块参数</p>
<p>module_param(name,type,perm)</p>
<p>name:模块参数名称</p>
<p>type:参数类型      bool，charp（字符串型）</p>
<p>perm:参数范围权限</p>
<p>条用几个模块时，参数要使用导出export_symbol  &lt;参数&gt;</p>
<p>内核符号导出：</p>
<p>EXPORT_SYMBOL</p>
<p>EXPORT_SYMBOL_GPL</p>
<p>.ko      .o+内核相关文件</p>
<p>printk在内核中使用</p>
<p>printf在应用程序中使用</p>
<h4 id="3-11-4-7-模块中的问题"><a href="#3-11-4-7-模块中的问题" class="headerlink" title="3.11.4.7 模块中的问题"></a>3.11.4.7 模块中的问题</h4><p>[1] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qiaoliang328/article/details/5191821">rmmod: chdir(&#x2F;lib&#x2F;modules): No such file or directory 解决方法</a>  </p>
<h3 id="3-11-5-搭建NFS根文件系统"><a href="#3-11-5-搭建NFS根文件系统" class="headerlink" title="3.11.5 搭建NFS根文件系统"></a>3.11.5 搭建NFS根文件系统</h3><p>[1] 解压根文件系统源码包</p>
<p>[2] 配置NFS服务</p>
<p>i. 设置NFS共享目录</p>
<p>ii. 启动NFS服务</p>
<p>iii. 设置u-boot引导参数，启动内核挂载网络根文件系统</p>
<h3 id="3-11-6-基本脚本编程"><a href="#3-11-6-基本脚本编程" class="headerlink" title="3.11.6 基本脚本编程"></a>3.11.6 基本脚本编程</h3><p>[1] 使用Vi建立shell脚本文件</p>
<p>vi	hello.sh</p>
<p>[2] 脚本中应包括的内容：</p>
<p>Ø 脚本运行环境，指明使用的哪种shell来解释脚本</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>Ø 注释行以#开始</p>
<p>#</p>
<p>Ø 脚本语句</p>
<p>shell命令+系统命令</p>
<p>[3] 设置脚本文件为可执行属性（+x）</p>
<p>chmod  u+x  hello.sh</p>
<p>u+x  创建者具有可执行权限</p>
<p>chmod  +x	 hello.sh	   所有人都具有可执行权限</p>
<p>例:#!&#x2F;bin&#x2F;bash</p>
<p>​	#hello</p>
<p>​	cd</p>
<p>​	mkdir	test</p>
<p>​	cd		test</p>
<p>​	tauch	hello</p>
<p>​	echo”hello world”&gt;hello</p>
<p>​	cat		hello</p>
<h3 id="3-11-7-printk"><a href="#3-11-7-printk" class="headerlink" title="3.11.7 printk"></a>3.11.7 printk</h3><h2 id="3-12-应用程序的开发"><a href="#3-12-应用程序的开发" class="headerlink" title="3.12 应用程序的开发"></a>3.12 <a href="">应用程序的开发</a></h2><p>ARM环境下应用程序的开发——–编写helloworld程序</p>
<p>[1] 使用vi编写helloworld程序</p>
<p>[2] 使用arm-linux-gcc编译helloworld程序</p>
<p>[3] 通过串口下载可执行文件至开发板中并运行（rz指令）</p>
<p>注意：运行前，先设置为可执行权限，chmod  +x		hello</p>
<h3 id="3-12-1-概念"><a href="#3-12-1-概念" class="headerlink" title="3.12.1 概念"></a>3.12.1 概念</h3><h4 id="3-12-1-1-API"><a href="#3-12-1-1-API" class="headerlink" title="3.12.1.1 API"></a>3.12.1.1 API</h4><p>用户编程接口。</p>
<h3 id="3-12-2-helloworld"><a href="#3-12-2-helloworld" class="headerlink" title="3.12.2 helloworld"></a>3.12.2 helloworld</h3><h3 id="3-12-3-irqreturn-t"><a href="#3-12-3-irqreturn-t" class="headerlink" title="3.12.3 irqreturn_t"></a>3.12.3 irqreturn_t</h3><p>关于中断处理函数的返回值:中断程序的返回值是一个特殊类型—irqreturn_t。但是中断程序的返回值却只有两个—IRQ_NONE和IRQ_HANDLED。</p>
<p>#ifndef _LINUX_IRQRETURN_H</p>
<p>#define _LINUX_IRQRETURN_H</p>
<p>typedef int irqreturn_t;</p>
<p>#define IRQ_NONE       (0)</p>
<p>#define IRQ_HANDLED       (1)</p>
<p>#define IRQ_RETVAL(x)      ((x) !&#x3D; 0)  &#x2F;&#x2F;这个宏只是返回0或非0</p>
<h3 id="3-12-4-system函数"><a href="#3-12-4-system函数" class="headerlink" title="3.12.4 system函数"></a>3.12.4 system函数</h3><p>system(“kill -s STOP <code>pidof led-player</code>“);</p>
<p>pidof   命令，捕获led-player的进程号</p>
<h3 id="3-12-5-size-t-time-t"><a href="#3-12-5-size-t-time-t" class="headerlink" title="3.12.5 size_t  time_t"></a>3.12.5 size_t  time_t</h3><p>size_t是标准C库中定义的，应为unsigned int，在64位系统中为 long unsigned int。</p>
<p>time_t的单位是秒, time_t实际上是长整型. typedef  long   time_t</p>
<h2 id="3-13-Linux驱动程序"><a href="#3-13-Linux驱动程序" class="headerlink" title="3.13 Linux驱动程序"></a>3.13 <a href="">Linux驱动程序</a></h2><p>linux的外设可分为3类：字符设备（character device）、块设备（block device）和网络接口（network interface）。</p>
<p>字符设备是指能够像字节流一样被访问的设备，就是说对它的读写是以字节为单位的。</p>
<p>linux驱动在开发板运行时表现为一个设备即dev,所以通常使用open函数调用&#x2F;dev&#x2F;leds</p>
<h3 id="3-13-1-编写Linux驱动"><a href="#3-13-1-编写Linux驱动" class="headerlink" title="3.13.1 编写Linux驱动"></a>3.13.1 编写Linux驱动</h3><p>[1] 编写helloworld驱动程序</p>
<p>[2] 为驱动程序编写makefile</p>
<p>[3] 执行make，生成ARM版本的.ko模块文件</p>
<p>[4] 上电开发板，启动内核</p>
<p>[5] 通过串口下载.ko文件至开发板</p>
<p>[6] 在当前开发板运行的嵌入式linux内核中动态加载驱动模块文件</p>
<p>insmod   hello.ko</p>
<p>rmmod	  hello</p>
<p>lsmod	  查看</p>
<h3 id="3-13-2-加载内核中已有模块"><a href="#3-13-2-加载内核中已有模块" class="headerlink" title="3.13.2 加载内核中已有模块"></a>3.13.2 加载内核中已有模块</h3><p>[1] make menuconfig 重新编译内核，去掉即将要加载的内核选项</p>
<p>[2] 烧写内核</p>
<p>[3] 加载模块驱动</p>
<h3 id="3-13-3-函数"><a href="#3-13-3-函数" class="headerlink" title="3.13.3 函数"></a>3.13.3 函数</h3><h4 id="3-13-3-1-copy-to-user"><a href="#3-13-3-1-copy-to-user" class="headerlink" title="3.13.3.1 copy_to_user"></a>3.13.3.1 copy_to_user</h4><p>作用：从内核区中读取数据到用户区</p>
<p>简述：</p>
<p>#include &lt;linux&#x2F;uaccess.h&gt;</p>
<p>unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);</p>
<p>如果数据拷贝成功，则返回零；否则，返回没有拷贝成功的数据字节数。</p>
<p>*to是用户空间的指针，</p>
<p>*from是内核空间指针，</p>
<p>n表示从内核空间向用户空间拷贝数据的字节数</p>
<p>一、Copy_to_user( to, &amp;from, sizeof(from))</p>
<p>To:用户空间函数  （可以是数组）</p>
<p>From:内核空间函数（可以是数组）</p>
<p>sizeof(from)：内核空间要传递的数组的长度</p>
<p>二、Copy_from_user(&amp;from , to , sizeof(to) )</p>
<p>To:用户空间函数  （可以是数组）</p>
<p>From:内核空间函数（可以是数组）</p>
<p>sizeof(from)：内核空间要传递的数组的长度</p>
<p>成功返回0，</p>
<p>失败返回失败数目。</p>
<p>例子：</p>
<p>static ssize_t keys4_read(struct inode *inode, char *buf, unsigned long count,loff_t *ppos)</p>
<p>{     </p>
<p>​       int co;</p>
<p>​       char buff[2];</p>
<p>​       buff[0] &#x3D; times3;</p>
<p>​       buff[1] &#x3D; times4;</p>
<p>​       if((co&#x3D;copy_to_user(buf ,&amp;buff , sizeof(buff))))</p>
<p>​       return -EFAULT;</p>
<p>​       else printk(“copy to user is okn”);</p>
<p>Return 1;</p>
<p>}</p>
<h4 id="3-13-3-2-File-operations"><a href="#3-13-3-2-File-operations" class="headerlink" title="3.13.3.2 File_operations"></a>3.13.3.2 <a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_56332e1d0100crc8.html">File_operations</a></h4><h2 id="3-14-Linux生成动态库"><a href="#3-14-Linux生成动态库" class="headerlink" title="3.14 Linux生成动态库"></a>3.14 <a href="">Linux生成动态库</a></h2><p>附件：<a href="G:\学习笔记\笔记\附件\文档\Linux下生成静态动态库.doc">附件\文档\Linux下生成静态动态库.doc</a></p>
<p>附件：<a href="file:///G:\学习笔记\笔记\附件\文档\Linux下Gcc生成和使用静态库和动态库详解.pdf">附件\文档\Linux下Gcc生成和使用静态库和动态库详解.pdf</a></p>
<h3 id="3-14-1-生成动态链接库"><a href="#3-14-1-生成动态链接库" class="headerlink" title="3.14.1 生成动态链接库"></a>3.14.1 生成动态链接库</h3><p>gcc -shared -fpic -o libmyhello.so  hello.c</p>
<p>-fpic 使输出的对象模块是按照可重定位地址方式生成的。 </p>
<p>-shared指定把对应的源文件生成对应的动态链接库文件。 </p>
<p>静态库链接时搜索路径顺序：</p>
<p>\1. ld 会去找 GCC 命令中的参数-L</p>
<p>\2. 再找 gcc 的环境变量 LIBRARY_PATH</p>
<p>\3. 再找内定目录 &#x2F;lib &#x2F;usr&#x2F;lib &#x2F;usr&#x2F;local&#x2F;lib 这是当初 compile gcc 时写在程序内的</p>
<p>动态链接时、执行时搜索路径顺序:</p>
<p>\1. 编译目标代码时指定的动态库搜索路径；</p>
<p>\2. 环境变量 LD_LIBRARY_PATH 指定的动态库搜索路径；</p>
<p>\3. 配置文件&#x2F;etc&#x2F;ld.so.conf 中指定的动态库搜索路径；</p>
<p>\4. 默认的动态库搜索路径&#x2F;lib；</p>
<p>\5. 默认的动态库搜索路径&#x2F;usr&#x2F;lib。</p>
<p>有关环境变量：</p>
<p>LIBRARY_PATH 环境变量：指定程序静态链接库文件搜索路径</p>
<p>LD_LIBRARY_PATH 环境变量：指定程序动态链接库文件搜索路径</p>
<h3 id="3-14-2-linux-增加动态库的搜索路径"><a href="#3-14-2-linux-增加动态库的搜索路径" class="headerlink" title="3.14.2 linux 增加动态库的搜索路径"></a>3.14.2 linux 增加动态库的搜索路径</h3><ol>
<li><p>在&#x2F;etc&#x2F;ld.so.conf中加一行&#x2F;usr&#x2F;local&#x2F;lib，这是你要增加的动态库目录，然后运行ldconfig。</p>
</li>
<li><p>在&#x2F;etc&#x2F;ld.so.conf.d&#x2F;下加入一个文件，文件内容为so路径名</p>
</li>
</ol>
<h2 id="3-15-静态库的生成"><a href="#3-15-静态库的生成" class="headerlink" title="3.15 静态库的生成"></a>3.15 静态库的生成</h2><p>静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。 </p>
<p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。</p>
<p>ar -cr libmyhello.a hello.o</p>
<p>gcc -o t main.c libmyhello.a </p>
<p>ar rv libso.a hello.o</p>
<h3 id="3-15-1-几个Linux文件的作用"><a href="#3-15-1-几个Linux文件的作用" class="headerlink" title="3.15.1 几个Linux文件的作用"></a>3.15.1 <a href="">几个Linux文件的作用</a></h3><p>（1） &#x2F;etc&#x2F;profile： 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置。</p>
<p>（2） &#x2F;etc&#x2F;bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取（即每次新开一个终端，都会执行bashrc）。</p>
<p>（3） ~&#x2F;.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。默认情况下,设置一些环境变量,执行用户的.bashrc文件。</p>
<p>（4） ~&#x2F;.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</p>
<p>（5） <del>&#x2F;.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件. 另外,&#x2F;etc&#x2F;profile中设定的变量(全局)的可以作用于任何用户,而</del>&#x2F;.bashrc等中设定的变量(局部)只能继承 &#x2F;etc&#x2F;profile中的变量,他们是”父子”关系。</p>
<p>（6） <del>&#x2F;.bash_profile: 是交互式、login 方式进入 bash 运行的</del>&#x2F;.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。</p>
<h2 id="3-16-启动脚本"><a href="#3-16-启动脚本" class="headerlink" title="3.16 启动脚本"></a>3.16 <a href="">启动</a>脚本</h2><p>系统启动后会执行脚本&#x2F;etc&#x2F;rc.local它在服务&#x2F;etc&#x2F;init.d&#x2F;rc.local中被调用，可以在这里进行一些系统级的初始化工作。</p>
<h3 id="3-16-1-bash启动脚本"><a href="#3-16-1-bash启动脚本" class="headerlink" title="3.16.1 bash启动脚本"></a>3.16.1 bash启动脚本</h3><p>bash启动也会自动执行一些脚本</p>
<p>&#x2F;etc&#x2F;profile			全局登陆脚本，任何用户登陆都执行			</p>
<p>&#x2F;etc&#x2F;bash.bashrc	全局bash脚本，任何用户启动非登陆的交互式bash时执行</p>
<p>~&#x2F;.profile			用户登陆脚本，用户登陆时执行</p>
<p>~&#x2F;.bashrc			用户bash脚本，用户启动费登陆的交互式bash执行</p>
<h2 id="3-17-DHCP"><a href="#3-17-DHCP" class="headerlink" title="3.17 DHCP"></a>3.17 <a href="">DHCP</a></h2><p>&#x2F;etc&#x2F;dhcpd.conf</p>
<h2 id="3-18-Linux下清理内存和Cache方法"><a href="#3-18-Linux下清理内存和Cache方法" class="headerlink" title="3.18 Linux下清理内存和Cache方法"></a>3.18 Linux下清理内存和Cache方法</h2><p>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</p>
<p>频繁的文件访问会导致系统的Cache使用量大增</p>
<p>$ free -m</p>
<p>total used free shared buffers cached</p>
<p>Mem: 3955 3926 28 0 55 3459</p>
<p>-&#x2F;+ buffers&#x2F;cache: 411 3544</p>
<p>Swap: 5726 0 5726</p>
<p>free内存减少到几十兆，系统运行缓慢</p>
<p>运行sync将dirty的内容写回硬盘</p>
<p>$sync</p>
<p>通过修改proc系统的drop_caches清理free的cache</p>
<p>$echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</p>
<p>drop_caches的详细文档如下：</p>
<p>Writing to this will cause the kernel to drop clean caches, dentries and inodes from memory, causing that memory to become free.</p>
<p>To free pagecache:</p>
<p>* echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</p>
<p>To free dentries and inodes:</p>
<p>* echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</p>
<p>To free pagecache, dentries and inodes:</p>
<p>* echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</p>
<p>As this is a non-destructive operation, and dirty objects are notfreeable, the user should run “sync” first in order to make sure allcached objects are freed.</p>
<p>This tunable was added in 2.6.16.</p>
<p>本篇文章来源于 Linux公社网站(<a target="_blank" rel="noopener" href="http://www.linuxidc.com/">www.linuxidc.com</a>)  原文链接：<a target="_blank" rel="noopener" href="http://www.linuxidc.com/Linux/2010-03/24939.htm">http://www.linuxidc.com/Linux/2010-03/24939.htm</a></p>
<h1 id="第-4-章-Shell"><a href="#第-4-章-Shell" class="headerlink" title="第 4 章 Shell"></a>第 4 章 <a href="">Shell</a></h1><h2 id="4-1-shell语法"><a href="#4-1-shell语法" class="headerlink" title="4.1 shell语法"></a>4.1 shell语法</h2><h3 id="4-1-1-参数"><a href="#4-1-1-参数" class="headerlink" title="4.1.1 参数"></a>4.1.1 参数</h3><p>#!&#x2F;bin&#x2F;sh</p>
<p>#!用来指定</p>
<p>注释以“#”开头，所有变量没有类型也不用声明</p>
<p>$#:传入脚本的命令行参数个数，保存程序命令行参数的数目</p>
<p>$*:所有命令行参数值，在各个参数值之间留有空格</p>
<p>$0:命令本身（shell文件名）</p>
<p>$1:第一个命令行参数</p>
<p>$2:第二个命令行参数</p>
<p><strong>注意</strong>: 变量赋值时，“&#x3D;”左右两边都不能有空格, BASH 中的语句结尾不需要分号</p>
<p>$$:Shell本身的PID（ProcessID）</p>
<p>$!：Shell最后运行的后台Process的PID</p>
<p>$?：最后运行的命令的结束代码（返回值）</p>
<p>$-：使用Set命令设定的Flag一览</p>
<p>$<em>：所有参数列表。如”$</em>“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</p>
<p>$@：所有参数列表。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<p>$#：添加到Shell的参数个数</p>
<p>$0：Shell本身的文件名</p>
<p>$1～$n：添加到Shell的各参数值。$1是第1参数、$2是第2参数…。</p>
<p>e.g.</p>
<p>我们先写一个简单的脚本，执行以后再解释各个变量的意义</p>
<p># touch variable</p>
<p># vi variable</p>
<p>脚本内容如下：</p>
<p>#!&#x2F;bin&#x2F;sh</p>
<p>echo “number:$#”</p>
<p>echo “scname:$0”</p>
<p>echo “first :$1”</p>
<p>echo “second:$2”</p>
<p>echo “argume:$@”</p>
<p>保存退出</p>
<p>赋予脚本执行权限</p>
<p># chmod +x variable</p>
<p>执行脚本</p>
<p># .&#x2F;variable aa bb</p>
<p>number:2</p>
<p>scname:.&#x2F;variable</p>
<p>first: aa</p>
<p>second:bb</p>
<p>argume:aa bb</p>
<p>通过显示结果可以看到：</p>
<p>$# 是传给脚本的参数个数</p>
<p>$0 是脚本本身的名字</p>
<p>$1是传递给该shell脚本的第一个参数</p>
<p>$2是传递给该shell脚本的第二个参数</p>
<p>$@ 是传给脚本的所有参数的列表</p>
<h3 id="4-1-2-内部命令"><a href="#4-1-2-内部命令" class="headerlink" title="4.1.2 内部命令"></a>4.1.2 内部命令</h3><p>exit			终止当前shell的执行</p>
<p>export		设置一个环境变量，当前shell的所有子进程都可以访问这个环境变量</p>
<p>kill			终止某个进程的执行。</p>
<h3 id="4-1-3-bash功能"><a href="#4-1-3-bash功能" class="headerlink" title="4.1.3 bash功能"></a>4.1.3 bash功能</h3><p>A. 命令行编辑</p>
<p>B. 命令和文件不全功能（TAB）</p>
<p>C. 命令历史功能（history）</p>
<p>D. 命令别名功能（alias）</p>
<p>E. 作业控制</p>
<p>F. 自定义功能键</p>
<p>G. 灵活的shell脚本编程</p>
<p>注意：shell变量符号”&#x3D;”变量赋值时两边不能有空格，当变量有空格时要用“ </p>
<p>如：DAY&#x3D;Monday		DAY&#x3D;”Today  is  Monday”</p>
<p>引用：echo  $DAY		echo “$DAY”</p>
<h3 id="4-1-4-添加自定义命令"><a href="#4-1-4-添加自定义命令" class="headerlink" title="4.1.4 添加自定义命令"></a>4.1.4 添加自定义命令</h3><p>文件：&#x2F;root&#x2F;.bashrc，添加以下行：alias mycodedir &#x3D; “cd &#x2F;root&#x2F;Source_code”，保存，然后重新启动，以后在命令行输入mycodedir 即可执行命令“cd &#x2F;root&#x2F;Source_code”，省事又省力</p>
<p>echo $PATH</p>
<p>看一下自己的命令会去哪里搜索，然后把自定义命令放到其中一个文件夹里面就ok了。</p>
<h3 id="4-1-5-反引号"><a href="#4-1-5-反引号" class="headerlink" title="4.1.5 反引号"></a>4.1.5 反引号</h3><p>echo <code>date</code> 执行引号中的系统命令</p>
<h3 id="4-1-6-测试语句"><a href="#4-1-6-测试语句" class="headerlink" title="4.1.6 测试语句"></a>4.1.6 测试语句</h3><h3 id="4-1-7-if语句"><a href="#4-1-7-if语句" class="headerlink" title="4.1.7 if语句"></a>4.1.7 if语句</h3><p>if [ expression ]</p>
<p>then</p>
<p>#code block</p>
<p>fi </p>
<p>if [ expression ]</p>
<p>then</p>
<p>#code block</p>
<p>else</p>
<p>#code block</p>
<p>fi</p>
<p>if  [ expression]</p>
<p>then</p>
<p>#code block</p>
<p>elseif  [ expression]</p>
<p>then</p>
<p>#code block</p>
<p>else</p>
<p>#code block</p>
<p>fi</p>
<p>fi</p>
<h3 id="4-1-8-比较"><a href="#4-1-8-比较" class="headerlink" title="4.1.8 比较"></a>4.1.8 比较</h3><p>比较操作 整数操作 字符串操作</p>
<p>相同 		-eq 		&#x3D;</p>
<p>不同 		-ne 		!&#x3D;</p>
<p>大于 		-gt 		&gt;    	  greater than</p>
<p>小于 		-lt 			&lt;       less   than</p>
<p>大于或等于 -ge</p>
<p>小于或等于 -le</p>
<p>为空		 -z</p>
<p>不为空 	-n</p>
<p>例：</p>
<p>比较整数a和b是否相等：if [ $a &#x3D; $b ] （也可用eq）</p>
<p>判断整数a是否大于整数b：if [ $a-gt $b]</p>
<p>比较字符串a和b是否相等：if [ $a &#x3D; $b]</p>
<p>判断字符串a是否为空： if [-z $a]</p>
<p>判断整数变量a是否大于b：if [ $a-gt $b]</p>
<p>注意：</p>
<p><strong>1. 在“[”和“]”符号的左右都留有空格</strong>****</p>
<p><strong>2. “&#x3D;”左右都有空格</strong>****</p>
<h3 id="000011-1-判断"><a href="#000011-1-判断" class="headerlink" title="000011.1 判断"></a>000011.1 判断</h3><p>-e 文件已经存在</p>
<p>-f 文件是普通文件</p>
<p>-s 文件大小不为零</p>
<p>-d 文件是一个目录</p>
<p>-r 文件对当前用户可以读取</p>
<p>-w 文件对当前用户可以写入</p>
<p>-x 文件对当前用户可以执行</p>
<p>例S5：</p>
<p>#!&#x2F;bin&#x2F;sh </p>
<p>folder&#x3D;&#x2F;home </p>
<p>[ -r “$folder” ] &amp;&amp; echo “Can read $folder” </p>
<p>[ -f “$folder” ] || echo “thisis not file”</p>
<h3 id="4-1-9-case语句"><a href="#4-1-9-case语句" class="headerlink" title="4.1.9 case语句"></a>4.1.9 case语句</h3><p>#!&#x2F;bin&#x2F;bash </p>
<p>echo “Hit a key, then hit return.”</p>
<p>read Keypress </p>
<p>case “$Keypress”in</p>
<p>[A-Z] )  echo  “ Uppercaseletter”;;</p>
<p>[a-z] )  echo “ Lowercaseletter”;;</p>
<p>[0-9] )   echo “Digit”;;</p>
<p>* ) echo “Punctuation, whitespace, or other”;;</p>
<p>esac</p>
<h3 id="4-1-10-until循环"><a href="#4-1-10-until循环" class="headerlink" title="4.1.10 until循环"></a>4.1.10 until循环</h3><p>until 循环的基本结构是：</p>
<p>until [condition]</p>
<p>do</p>
<p>#code block</p>
<p>done</p>
<h3 id="4-1-11-while循环"><a href="#4-1-11-while循环" class="headerlink" title="4.1.11 while循环"></a>4.1.11 while循环</h3><p>while 循环的基本结构是：</p>
<p>while [ condition ]</p>
<p>do</p>
<p>#code block</p>
<p>done</p>
<h3 id="4-1-12-For循环"><a href="#4-1-12-For循环" class="headerlink" title="4.1.12 For循环"></a>4.1.12 For循环</h3><p>#!&#x2F;bin&#x2F;bash </p>
<p>for day in Sun Mon Tue Wed Thu Fri Sat</p>
<p>do</p>
<p>echo $day</p>
<p>done </p>
<p>如果列表被包含在一对双引中，则被认为是一个元素,如:</p>
<p>#!&#x2F;bin&#x2F;bash </p>
<p>for day in “Sun Mon Tue Wed Thu Fri Sat“</p>
<p>do</p>
<p>echo $day</p>
<p>done</p>
<h3 id="4-1-13-标准输入输出"><a href="#4-1-13-标准输入输出" class="headerlink" title="4.1.13 标准输入输出"></a>4.1.13 标准输入输出</h3><p>输入输出文件		文件描述符			默认设备</p>
<p>标准输入				0					键盘</p>
<p>标准输出				1				终端屏幕</p>
<p>标准错误输出			2				终端屏幕</p>
<p>输入重定向 &lt;	以只读方式打开文件，将命令中接收接入的途径由默认的键盘更改为指定的文件</p>
<p>输出重定向		&gt;	 以只写方式打开文件，文件原内容清空	</p>
<p>输出重定向		&gt;&gt;		追加到文件的末尾保存</p>
<p>错误重定向		2&gt;</p>
<p>wc		&lt;		&#x2F;bin&#x2F;passwd</p>
<p>统计passwd的行数</p>
<p>ls  &#x2F;etc&#x2F;   &gt; sh.bash				会覆盖</p>
<p>将标准输出和错误输出重定向到文件</p>
<p>ls	 afile	bfile	&amp;&gt;errfile</p>
<p>管道  “|”  左边的输出结果作为右边的输入</p>
<h2 id="4-2-Shell"><a href="#4-2-Shell" class="headerlink" title="4.2 Shell"></a>4.2 Shell</h2><h3 id="4-2-1-获取系统时间作为文件名"><a href="#4-2-1-获取系统时间作为文件名" class="headerlink" title="4.2.1 获取系统时间作为文件名"></a>4.2.1 获取系统时间作为文件名</h3><p>示例：</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>cd &#x2F;workspace&#x2F;projects&#x2F;im&#x2F;lte&#x2F;sgw&#x2F;build&#x2F;</p>
<p>FILE_NAME&#x3D;$(date +’%Y%m%d%H%M%S’)</p>
<p>#FILE_NAME&#x3D;$(date +’%T’)</p>
<p>FILE_PATH&#x3D;..&#x2F;PfMod&#x2F;compile</p>
<p>make cleanpf</p>
<p>make pf|tee ${FILE_PATH}&#x2F;${FILE_NAME}.log</p>
<h3 id="4-2-2-判断某个目录是否存在"><a href="#4-2-2-判断某个目录是否存在" class="headerlink" title="4.2.2 判断某个目录是否存在"></a>4.2.2 判断某个目录是否存在</h3><p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps48.jpg" alt="img"> </p>
<h3 id="4-2-3-延时"><a href="#4-2-3-延时" class="headerlink" title="4.2.3 延时"></a>4.2.3 延时</h3><p>sleep 5s</p>
<h3 id="4-2-4-获取程序id然后kill"><a href="#4-2-4-获取程序id然后kill" class="headerlink" title="4.2.4 获取程序id然后kill"></a>4.2.4 获取程序id然后kill</h3><p>a&#x3D;$(ps -a|awk ‘&#x2F;tcpdump&#x2F;{print $1}’)</p>
<p>echo $a</p>
<p>kill $a</p>
<h3 id="4-2-5-执行shell时，显示源代码"><a href="#4-2-5-执行shell时，显示源代码" class="headerlink" title="4.2.5 执行shell时，显示源代码"></a>4.2.5 执行shell时，显示源代码</h3><p>在 #！&#x2F;bin&#x2F;bash 后加入 +x</p>
<h3 id="4-2-6-shell脚本中引入其他文件定义采用source"><a href="#4-2-6-shell脚本中引入其他文件定义采用source" class="headerlink" title="4.2.6 shell脚本中引入其他文件定义采用source"></a>4.2.6 shell脚本中引入其他文件定义采用source</h3><p>source &#x2F;test&#x2F;hello.sh</p>
<h3 id="4-2-7-一行执行多条命令"><a href="#4-2-7-一行执行多条命令" class="headerlink" title="4.2.7 一行执行多条命令"></a>4.2.7 一行执行多条命令</h3><p>用;隔开即可</p>
<h3 id="4-2-8-从文件中得到-x2F-分离出IP地址"><a href="#4-2-8-从文件中得到-x2F-分离出IP地址" class="headerlink" title="4.2.8 从文件中得到&#x2F;分离出IP地址"></a>4.2.8 从文件中得到&#x2F;分离出IP地址</h3><p>ParamName&#x3D;EMS_IP</p>
<p>EMS_IP&#x3D;<code>cat $&#123;Path&#125;/$&#123;ConfigFile&#125; | grep $&#123;ParamName&#125; | head -n 1| cut -d &quot;=&quot; -f 2</code></p>
<h3 id="4-2-9-替换字符串中的点"><a href="#4-2-9-替换字符串中的点" class="headerlink" title="4.2.9 替换字符串中的点"></a>4.2.9 替换字符串中的点</h3><p>A&#x3D;1.1.1.1</p>
<p>echo $A|sed &#x2F;.&#x2F;,&#x2F;</p>
<h2 id="4-3-Shell加密"><a href="#4-3-Shell加密" class="headerlink" title="4.3 Shell加密"></a>4.3 Shell加密</h2><p>可以采用gzexe和shc两命令</p>
<p>Gzexe加密同时压缩脚本   gzexe  test.sh</p>
<p>Shc加密更为复杂.</p>
<p>Shc –e 2015&#x2F;2&#x2F;2 –m “please your lisence” –f test.sh</p>
<h3 id="4-3-1"><a href="#4-3-1" class="headerlink" title="4.3.1"></a>4.3.1</h3><p>采用shc工具加密Shell脚本，以提高shell脚本文件的安全性。</p>
<p> 介绍：当我们写的shell脚本，存在有敏感信息如账号密码，于是想加强脚本的安全性；还有不想让别人查看&#x2F;修改您的shell核心代码等等情况。都可使用以下工具进行加密。</p>
<p>shc是一个脚本编译工具, 使用RC4加密算法, 它能够把shell程序转换成二进制可执行文件(支持静态链接和动态链接)。</p>
<p>shc官网:<a target="_blank" rel="noopener" href="http://www.datsi.fi.upm.es/%7Efrosal/">http://www.datsi.fi.upm.es/%7Efrosal/</a></p>
<p>安装shc</p>
<p> wget <a target="_blank" rel="noopener" href="http://www.datsi.fi.upm.es/%7Efrosal/sources/shc-3.8.7.tgz">http://www.datsi.fi.upm.es/%7Efrosal/sources/shc-3.8.7.tgz</a></p>
<p> tar vxf shc-3.8.7.tgz </p>
<p> cd shc-3.8.7</p>
<p> make test</p>
<p> make strings</p>
<p> make install</p>
<p>若报错：</p>
<p>***     Installing shc and shc.1 on &#x2F;usr&#x2F;local</p>
<p> ***     ?Do you want to continue? y</p>
<p> install -c -s shc &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</p>
<p> install -c -m 644 shc.1 &#x2F;usr&#x2F;local&#x2F;man&#x2F;man1&#x2F;</p>
<p> install: target &#96;&#x2F;usr&#x2F;local&#x2F;man&#x2F;man1&#x2F;‘ is not a directory: No such file or directory</p>
<p> make: *** [install] Error 1</p>
<p>请创建 mkdir -p &#x2F;usr&#x2F;local&#x2F;man&#x2F;man1&#x2F;  ，然后运行make install</p>
<p>常用参数：</p>
<p>-e date （指定过期日期）</p>
<p>-m message （指定过期提示的信息） </p>
<p>-f script_name（指定要编译的shell的路径及文件名）</p>
<p>-r   Relax security. （可以相同操作系统的不同系统中执行）</p>
<p>-v   Verbose compilation（编译的详细情况）</p>
<p>使用方法：</p>
<p>shc -v -f abc.sh</p>
<p>-v 是现实加密过程</p>
<p>-f 后面跟需要加密的文件  </p>
<p>运行后会生成两个文件: </p>
<p>abc.sh.x 和 abc.sh.x.c</p>
<p> abc.sh.x为二进制文件，赋予执行权限后，可直接执行。更改名字mv abc.sh.x a.sh </p>
<p> abc.sh.x.c 是c源文件。基本没用，可以删除</p>
<p>另shc还提供了一种设定有效执行期限的方法，过期时间，如：</p>
<p># shc -e 28&#x2F;01&#x2F;2012 -m “过期了” -f abc.sh</p>
<p>选项“-e”指定过期时间，格式为“日&#x2F;月&#x2F;年”；选项“-m”指定过期后执行此shell程序的提示信息。</p>
<p> 如果在过期后执行，则会有如下提示：</p>
<p># .&#x2F;abc.sh.x  </p>
<p> .&#x2F;abc.sh.x: has expired!</p>
<p>过期了</p>
<p> 使用以上方法要注意，需防止用户更改系统时间，可以通过在程序中加入自动更新系统时间的命令来解决此问题。</p>
<h2 id="4-4-shell交互"><a href="#4-4-shell交互" class="headerlink" title="4.4 shell交互"></a>4.4 shell交互</h2><h3 id="4-4-1-自动交互方法一"><a href="#4-4-1-自动交互方法一" class="headerlink" title="4.4.1 自动交互方法一"></a>4.4.1 自动交互方法一</h3><p>自动交互最关键的就是交互信息的自动输入，首先联想到文件重定向，在shell编程中有这样一种用法(参考Linux与UNIX SHELL编程指南 chapt 5.7)：”command &lt;&lt; delimiter  从标准输入中读入，直至遇到delimiter分界符。”</p>
<p>重定向操作符command &lt;&lt; delimiter是一种非常有用的命令，shell将分界符delimiter之后直至下一个同样的分界符之前的所有内容都作为输入，遇到下一个分界符， shell就知道输入结束了。最常见的delimiter分界符是EOF，当然完全可以自定为其他字符。</p>
<p>对于需求1 要求的自动登陆ftp，并作系列操作，则可以用这种方法进行自动交互。代码如下：</p>
<p>1.#!&#x2F;bin&#x2F;bash  </p>
<p>2.ftp -i -n 192.168.167.187 &lt;&lt; EOF </p>
<p>3.user hzc 123456  </p>
<p>4.pwd  </p>
<p>5.cd test  </p>
<p>6.pwd  </p>
<p>7.close  </p>
<p>8.bye  </p>
<p>9.EOF </p>
<p>测试可以发现，如上代码使用帐号名hzc，密码123456成功登陆了ftp服务器，并进入目录，打印出了pwd。</p>
<h3 id="4-4-2-自动交互方法二"><a href="#4-4-2-自动交互方法二" class="headerlink" title="4.4.2 自动交互方法二"></a>4.4.2 自动交互方法二</h3><p>需求2中要求采用非交互的方式改变登录用户密码，尝试用方法1，无法实现。</p>
<p>这时候联想到交互信息的另一个自动输入方法，管道，通过echo + sleep + | 可以实现这个需求。</p>
<p>1.#!&#x2F;bin&#x2F;bash  </p>
<p>2.(echo “curpassword” </p>
<p>3.sleep 1  </p>
<p>4.echo “newpassword” </p>
<p>5.sleep 1  </p>
<p>6.echo “newpassword”)|passwd </p>
<p>测试通过，运行这个脚本，直接把当前用户的curpassword改成newpassword。</p>
<h3 id="4-4-3-自动交互方法三"><a href="#4-4-3-自动交互方法三" class="headerlink" title="4.4.3 自动交互方法三"></a>4.4.3 自动交互方法三</h3><p>需求3中要求自动登录root账号，尝试方法1和方法2，都出现错误提示standard in must be a tty。</p>
<p>这时候尝试寻找外部帮助，一个shell工具expect可以实现这个功能，其实expect就是一个专门用来实现自动交互功能的工具，expect的语法可以参考相关资料，代码如下：</p>
<p>1.#!&#x2F;usr&#x2F;bin&#x2F;expect  </p>
<p>2.spawn su root  </p>
<p>3.expect “password: “  </p>
<p>4.send “123456\r”  </p>
<p>5.expect eof  </p>
<p>6.exit </p>
<h3 id="4-4-4-方法总结"><a href="#4-4-4-方法总结" class="headerlink" title="4.4.4 方法总结"></a>4.4.4 方法总结</h3><p>方法一(重定向)简单直观，也经常有实际应用，但是在自动交互领域功能有限。方法二(管道)也很简单直观，有时甚至不用sleep配合就能展现强大的自动交互实力，但是在某些时候也束手无策。</p>
<p>方法三(expect)在功能上是最为强大的，expect本来就是为实现自动交互功能而生，但是缺点是需要安装expect包，在嵌入式等环境下难以安装。</p>
<h2 id="4-5-Shell函数返回值"><a href="#4-5-Shell函数返回值" class="headerlink" title="4.5 Shell函数返回值"></a>4.5 Shell函数返回值</h2><p>Shell函数返回值，常用的两种方式：return，echo</p>
<h3 id="4-5-1-return语句"><a href="#4-5-1-return语句" class="headerlink" title="4.5.1 return语句"></a>4.5.1 return语句</h3><p>shell函数的返回值，可以和其他语言的返回值一样，通过return语句返回。</p>
<p>示例：</p>
<p>#!&#x2F;bin&#x2F;sh  </p>
<p>function test()  </p>
<p>{  </p>
<p>​    echo “arg1 &#x3D; $1”  </p>
<p>​    if [ $1 &#x3D; “1” ] ;then  </p>
<p>​        return 1  </p>
<p>​    else  </p>
<p>​        return 0  </p>
<p>​    fi  </p>
<p>}  </p>
<p>echo   </p>
<p>echo “test 1”  </p>
<p>test 1  </p>
<p>echo $?         # print return result  </p>
<p>echo   </p>
<p>echo “test 0”  </p>
<p>test 0  </p>
<p>echo $?         # print return result  </p>
<p>echo   </p>
<p>echo “test 2”  </p>
<p>test 2  </p>
<p>echo $?         # print return result  </p>
<p>输出结果为：</p>
<p>test 1</p>
<p>arg1 &#x3D; 1</p>
<p>1</p>
<p>test 0</p>
<p>arg1 &#x3D; 0</p>
<p>0</p>
<p>test 2</p>
<p>arg1 &#x3D; 2</p>
<p>0</p>
<p>先定义了一个函数test，根据它输入的参数是否为1来return 1或者return 0。</p>
<p>获取函数的返回值通过调用函数，或者最后执行的值获得。</p>
<p>另外，可以直接用函数的返回值用作if的判断。</p>
<p>注意：return只能用来返回整数值，且和c的区别是返回为正确，其他的值为错误。</p>
<h3 id="4-5-2-echo-返回值"><a href="#4-5-2-echo-返回值" class="headerlink" title="4.5.2 echo 返回值"></a>4.5.2 echo 返回值</h3><p>其实在shell中，函数的返回值有一个非常安全的返回方式，即通过输出到标准输出返回。因为子进程会继承父进程的标准输出，因此，子进程的输出也就直接反应到父进程。</p>
<p>示例：</p>
<p>#!&#x2F;bin&#x2F;sh  </p>
<p>function test()  </p>
<p>{  </p>
<p>​    echo “arg1 &#x3D; $1”  </p>
<p>​    if [ $1 &#x3D; “1” ] ;then  </p>
<p>​        echo “1”  </p>
<p>​    else  </p>
<p>​        echo “0”  </p>
<p>​    fi  </p>
<p>}  </p>
<p>echo   </p>
<p>echo “test 1”  </p>
<p>test 1  </p>
<p>echo   </p>
<p>echo “test 0”  </p>
<p>test 0  </p>
<p>echo   </p>
<p>echo “test 2”  </p>
<p>test 2  </p>
<p>结果：</p>
<p>test 1</p>
<p>arg1 &#x3D; 1</p>
<p>1</p>
<p>test 0</p>
<p>arg1 &#x3D; 0</p>
<p>0</p>
<p>test 2</p>
<p>arg1 &#x3D; 2</p>
<p>0</p>
<h2 id="4-6-iptables"><a href="#4-6-iptables" class="headerlink" title="4.6 iptables"></a>4.6 iptables</h2><h3 id="4-6-1-前言"><a href="#4-6-1-前言" class="headerlink" title="4.6.1 前言"></a>4.6.1 前言</h3><p>防火墙，其实说白了讲，就是用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。而我们的任务就是需要去定义到底防火墙如何工作，这就是防火墙的策略，规则，以达到让它对出入网络的IP、数据进行检测。</p>
<p>目前市面上比较常见的有3、4层的防火墙，叫网络层的防火墙，还有7层的防火墙，其实是代理层的网关。</p>
<p>对于TCP&#x2F;IP的七层模型来讲，我们知道第三层是网络层，三层的防火墙会在这层对源地址和目标地址进行检测。但是对于七层的防火墙，不管你源端口或者目标端口，源地址或者目标地址是什么，都将对你所有的东西进行检查。所以，对于设计原理来讲，七层防火墙更加安全，但是这却带来了效率更低。所以市面上通常的防火墙方案，都是两者结合的。而又由于我们都需要从防火墙所控制的这个口来访问，所以防火墙的工作效率就成了用户能够访问数据多少的一个最重要的控制，配置的不好甚至有可能成为流量的瓶颈。</p>
<p>二：iptables 的历史以及工作原理</p>
<p>1.iptables的发展:</p>
<p>​	iptables的前身叫ipfirewall （内核1.x时代）,这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。但是ipfirewall工作功能极其有限(它需要将所有的规则都放进内核当中，这样规则才能够运行起来，而放进内核，这个做法一般是极其困难的)。当内核发展到2.x系列的时候，软件更名为ipchains，它可以定义多条规则，将他们串起来，共同发挥作用，而现在，它叫做iptables，可以将规则组成一个列表，实现绝对详细的访问控制功能。</p>
<p>​	他们都是工作在用户空间中，定义规则的工具，本身并不算是防火墙。它们定义的规则，可以让在内核空间当中的netfilter来读取，并且实现让防火墙工作。而放入内核的地方必须要是特定的位置，必须是tcp&#x2F;ip的协议栈经过的地方。而这个tcp&#x2F;ip协议栈必须经过的地方，可以实现读取规则的地方就叫做 netfilter.(网络过滤器)</p>
<p>​    作者一共在内核空间中选择了5个位置，</p>
<p>​    1.内核空间中：从一个网络接口进来，到另一个网络接口去的</p>
<p>​    2.数据包从内核流入用户空间的</p>
<p>​    3.数据包从用户空间流出的</p>
<p>​    4.进入&#x2F;离开本机的外网接口</p>
<p>​    5.进入&#x2F;离开本机的内网接口</p>
<p>​        </p>
<p>2.iptables的工作机制</p>
<p>​	从上面的发展我们知道了作者选择了5个位置，来作为控制的地方，但是你有没有发现，其实前三个位置已经基本上能将路径彻底封锁了，但是为什么已经在进出的口设置了关卡之后还要在内部卡呢？ 由于数据包尚未进行路由决策，还不知道数据要走向哪里，所以在进出口是没办法实现数据过滤的。所以要在内核空间里设置转发的关卡，进入用户空间的关卡，从用户空间出去的关卡。那么，既然他们没什么用，那我们为什么还要放置他们呢？因为我们在做NAT和DNAT的时候，目标地址转换必须在路由之前转换。所以我们必须在外网而后内网的接口处进行设置关卡。        </p>
<p>​	这五个位置也被称为五个钩子函数（hook functions）,也叫五个规则链。</p>
<p>​		1.PREROUTING (路由前)</p>
<p>​		2.INPUT (数据包流入口)</p>
<p>​		3.FORWARD (转发管卡)</p>
<p>​		4.OUTPUT(数据包出口)</p>
<p>​		5.POSTROUTING（路由后）</p>
<p>​        这是NetFilter规定的五个规则链，任何一个数据包，只要经过本机，必将经过这五个链中的其中一个链。       </p>
<p>3.防火墙的策略</p>
<p>​	防火墙策略一般分为两种，一种叫“通”策略，一种叫“堵”策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进。所以我们要定义，让进来的进来，让出去的出去，所以通，是要全通，而堵，则是要选择。当我们定义的策略的时候，要分别定义多条功能，其中：定义数据包中允许或者不允许的策略，filter过滤的功能，而定义地址转换的功能的则是nat选项。为了让这些功能交替工作，我们制定出了“表”这个定义，来定义、区分各种不同的工作功能和处理方式。</p>
<p>​	我们现在用的比较多个功能有3个：</p>
<p>​		1.filter 定义允许或者不允许的</p>
<p>​		2.nat 定义地址转换的 </p>
<p>​                3.mangle功能:修改报文原数据</p>
<p>​	我们修改报文原数据就是来修改TTL的。能够实现将数据包的元数据拆开，在里面做标记&#x2F;修改内容的。而防火墙标记，其实就是靠mangle来实现的。</p>
<p>小扩展:</p>
<p>​	对于filter来讲一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT</p>
<p>​	对于nat来讲一般也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING</p>
<p>​	而mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</p>
<p>​	iptables&#x2F;netfilter（这款软件）是工作在用户空间的，它可以让规则进行生效的，本身不是一种服务，而且规则是立即生效的。而我们iptables现在被做成了一个服务，可以进行启动，停止的。启动，则将规则直接生效，停止，则将规则撤销。 </p>
<p>​	iptables还支持自己定义链。但是自己定义的链，必须是跟某种特定的链关联起来的。在一个关卡设定，指定当有数据的时候专门去找某个特定的链来处理，当那个链处理完之后，再返回。接着在特定的链中继续检查。</p>
<p>注意：规则的次序非常关键，谁的规则越严格，应该放的越靠前，而检查规则的时候，是按照从上往下的方式进行检查的。</p>
<p>三．规则的写法:</p>
<p>​	iptables定义规则的方式比较复杂:</p>
<p>​	格式：iptables [-t table] COMMAND chain CRETIRIA -j ACTION</p>
<p>​		-t table ：3个filter nat mangle</p>
<p>​		COMMAND：定义如何对规则进行管理</p>
<p>​		chain：指定你接下来的规则到底是在哪个链上操作的，当定义策略的时候，是可以省略的</p>
<p>​		CRETIRIA:指定匹配标准</p>
<p>​		-j ACTION :指定如何进行处理</p>
<p>​	比如：不允许172.16.0.0&#x2F;24的进行访问。</p>
<p>​	iptables -t filter -A INPUT -s 172.16.0.0&#x2F;16 -p udp –dport 53 -j DROP</p>
<p>​	当然你如果想拒绝的更彻底：</p>
<p>​	iptables -t filter -R INPUT 1 -s 172.16.0.0&#x2F;16 -p udp –dport 53 -j REJECT</p>
<p>​	iptables -L -n -v	#查看定义规则的详细信息</p>
<p>四：详解COMMAND:</p>
<p>1.链管理命令（这都是立即生效的）</p>
<p>​	-P :设置默认策略的（设定默认门是关着的还是开着的）</p>
<p>​		默认策略一般只有两种</p>
<p>​		iptables -P INPUT (DROP|ACCEPT)  默认是关的&#x2F;默认是开的</p>
<p>​		比如：</p>
<p>​		iptables -P INPUT DROP 这就把默认规则给拒绝了。并且没有定义哪个动作，所以关于外界连接的所有规则包括Xshell连接之类的，远程连接都被拒绝了。</p>
<p>​        -F: FLASH，清空规则链的(注意每个链的管理权限)</p>
<p>​	    iptables -t nat -F PREROUTING</p>
<p>​	    iptables -t nat -F 清空nat表的所有链</p>
<p>​        -N:NEW 支持用户新建一个链</p>
<p>​            iptables -N inbound_tcp_web 表示附在tcp表上用于检查web的。</p>
<p>​        -X: 用于删除用户自定义的空链</p>
<p>​            使用方法跟-N相同，但是在删除之前必须要将里面的链给清空昂了</p>
<p>​        -E：用来Rename chain主要是用来给用户自定义的链重命名</p>
<p>​            -E oldname newname</p>
<p>​         -Z：清空链，及链中默认规则的计数器的（有两个计数器，被匹配到多少个数据包，多少个字节）</p>
<p>​            iptables -Z :清空</p>
<p>2.规则管理命令</p>
<p>​         -A：追加，在当前链的最后新增一个规则</p>
<p>​         -I num : 插入，把当前规则插入为第几条。</p>
<p>​            -I 3 :插入为第三条</p>
<p>​         -R num：Replays替换&#x2F;修改第几条规则</p>
<p>​            格式：iptables -R 3 …………</p>
<p>​         -D num：删除，明确指定删除第几条规则</p>
<p>​        </p>
<p>3.查看管理命令 “-L”</p>
<p>​	附加子命令</p>
<p>​	-n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名。</p>
<p>​	-v：显示详细信息</p>
<p>​	-vv</p>
<p>​	-vvv :越多越详细</p>
<p>​	-x：在计数器上显示精确值，不做单位换算</p>
<p>​	–line-numbers : 显示规则的行号</p>
<p>​	-t nat：显示所有的关卡的信息</p>
<p>五：详解匹配标准</p>
<p>1.通用匹配：源地址目标地址的匹配</p>
<p>​	-s：指定作为源地址匹配，这里不能指定主机名称，必须是IP</p>
<p>​		IP | IP&#x2F;MASK | 0.0.0.0&#x2F;0.0.0.0</p>
<p>​		而且地址可以取反，加一个“!”表示除了哪个IP之外</p>
<p>​	-d：表示匹配目标地址</p>
<p>​	-p：用于匹配协议的（这里的协议通常有3种，TCP&#x2F;UDP&#x2F;ICMP）</p>
<p>​	-i eth0：从这块网卡流入的数据</p>
<p>​		流入一般用在INPUT和PREROUTING上</p>
<p>​	-o eth0：从这块网卡流出的数据</p>
<p>​		流出一般在OUTPUT和POSTROUTING上</p>
<p>​        </p>
<p>2.扩展匹配</p>
<p>2.1隐含扩展：对协议的扩展</p>
<p>​    -p tcp :TCP协议的扩展。一般有三种扩展</p>
<p>​	–dport XX-XX：指定目标端口,不能指定多个非连续端口,只能指定单个端口，比如</p>
<p>​	–dport 21  或者 –dport 21-23 (此时表示21,22,23)</p>
<p>​	–sport：指定源端口</p>
<p>​	–tcp-fiags：TCP的标志位（SYN,ACK，FIN,PSH，RST,URG）</p>
<p>​	    对于它，一般要跟两个参数：</p>
<p>​		1.检查的标志位</p>
<p>​		2.必须为1的标志位</p>
<p>​		–tcpflags syn,ack,fin,rst syn   &#x3D;    –syn</p>
<p>​		表示检查这4个位，这4个位中syn必须为1，其他的必须为0。所以这个意思就是用于检测三次握手的第一次包的。对于这种专门匹配第一包的SYN为1的包，还有一种简写方式，叫做–syn</p>
<p>​    -p udp：UDP协议的扩展</p>
<p>​        –dport</p>
<p>​        –sport</p>
<p>​    -p icmp：icmp数据报文的扩展</p>
<p>​        –icmp-type：</p>
<p>​		echo-request(请求回显)，一般用8 来表示</p>
<p>​		所以 –icmp-type 8 匹配请求回显数据包</p>
<p>​		echo-reply （响应的数据包）一般用0来表示</p>
<p>​                  </p>
<p>2.2显式扩展（-m）</p>
<p>​     扩展各种模块</p>
<p>​      -m multiport：表示启用多端口扩展</p>
<p>​      之后我们就可以启用比如 –dports 21,23,80</p>
<p>​                  </p>
<p>​        </p>
<p>六：详解-j ACTION</p>
<p>​	常用的ACTION：</p>
<p>​	DROP：悄悄丢弃</p>
<p>​		一般我们多用DROP来隐藏我们的身份，以及隐藏我们的链表</p>
<p>​	REJECT：明示拒绝</p>
<p>​	ACCEPT：接受</p>
<p>​		custom_chain：转向一个自定义的链</p>
<p>​	DNAT</p>
<p>​	SNAT</p>
<p>​	MASQUERADE：源地址伪装</p>
<p>​	REDIRECT：重定向：主要用于实现端口重定向</p>
<p>​	MARK：打防火墙标记的</p>
<p>​	RETURN：返回</p>
<p>​		在自定义链执行完毕后使用返回，来返回原规则链。</p>
<p>练习题1：</p>
<p>​     只要是来自于172.16.0.0&#x2F;16网段的都允许访问我本机的172.16.100.1的SSHD服务</p>
<p>​     分析：首先肯定是在允许表中定义的。因为不需要做NAT地址转换之类的，然后查看我们SSHD服务，在22号端口上，处理机制是接受，对于这个表，需要有一来一回两个规则，如果我们允许也好，拒绝也好，对于访问本机服务，我们最好是定义在INPUT链上，而OUTPUT再予以定义就好。(会话的初始端先定义)，所以加规则就是：</p>
<p>​     定义进来的： iptables -t filter -A INPUT -s 172.16.0.0&#x2F;16 -d 172.16.100.1 -p tcp –dport 22 -j ACCEPT</p>
<p>​     定义出去的： iptables -t filter -A OUTPUT -s 172.16.100.1 -d 172.16.0.0&#x2F;16 -p tcp –dport 22 -j ACCEPT</p>
<p>​     将默认策略改成DROP:</p>
<p>​				 iptables -P INPUT DROP</p>
<p>​				 iptables -P OUTPUT DROP</p>
<p>​				 iptables -P FORWARD DROP</p>
<p>​        </p>
<p>七：状态检测：</p>
<p>​	是一种显式扩展，用于检测会话之间的连接关系的，有了检测我们可以实现会话间功能的扩展</p>
<p>​        什么是状态检测？对于整个TCP协议来讲，它是一个有连接的协议，三次握手中，第一次握手，我们就叫NEW连接，而从第二次握手以后的，ack都为1，这是正常的数据传输，和tcp的第二次第三次握手，叫做已建立的连接（ESTABLISHED）,还有一种状态，比较诡异的，比如：SYN&#x3D;1 ACK&#x3D;1 RST&#x3D;1,对于这种我们无法识别的，我们都称之为INVALID无法识别的。还有第四种，FTP这种古老的拥有的特征，每个端口都是独立的，21号和20号端口都是一去一回，他们之间是有关系的，这种关系我们称之为RELATED。</p>
<p>​	所以我们的状态一共有四种：</p>
<p>​        NEW</p>
<p>​        ESTABLISHED</p>
<p>​        RELATED</p>
<p>​        INVALID</p>
<p>​	所以我们对于刚才的练习题，可以增加状态检测。比如进来的只允许状态为NEW和ESTABLISHED的进来，出去只允许ESTABLISHED的状态出去，这就可以将比较常见的反弹式木马有很好的控制机制。</p>
<p>​        </p>
<p>对于练习题的扩展：</p>
<p>​	进来的拒绝出去的允许，进来的只允许ESTABLISHED进来，出去只允许ESTABLISHED出去。默认规则都使用拒绝</p>
<p>​		iptables -L -n –line-number  ：查看之前的规则位于第几行</p>
<p>​    改写INPUT</p>
<p>​        iptables -R INPUT 2 -s 172.16.0.0&#x2F;16 -d 172.16.100.1 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT</p>
<p>​        iptables -R OUTPUT 1 -m state –state ESTABLISHED -j ACCEPT</p>
<p>​    此时如果想再放行一个80端口如何放行呢？</p>
<p>​        iptables -A INPUT -d 172.16.100.1 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT</p>
<p>​        iptables -R INPUT 1 -d 172.16.100.1 -p udp –dport 53 -j ACCEPT</p>
<p>练习题2：</p>
<p>假如我们允许自己ping别人，但是别人ping自己ping不通如何实现呢？</p>
<p>分析：对于ping这个协议，进来的为8（ping），出去的为0(响应).我们为了达到目的，需要8出去,允许0进来</p>
<p>在出去的端口上：iptables -A OUTPUT -p icmp –icmp-type 8 -j ACCEPT</p>
<p>在进来的端口上：iptables -A INPUT -p icmp –icmp-type 0 -j ACCEPT</p>
<p>小扩展：对于127.0.0.1比较特殊，我们需要明确定义它</p>
<p>​			iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT</p>
<p>​			iptables -A OUTPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT</p>
<p>八：SNAT和DNAT的实现</p>
<p>​	由于我们现在IP地址十分紧俏，已经分配完了，这就导致我们必须要进行地址转换，来节约我们仅剩的一点IP资源。那么通过iptables如何实现NAT的地址转换呢？</p>
<p>1.SNAT基于原地址的转换</p>
<p>​	基于原地址的转换一般用在我们的许多内网用户通过一个外网的口上网的时候，这时我们将我们内网的地址转换为一个外网的IP，我们就可以实现连接其他外网IP的功能。</p>
<p>所以我们在iptables中就要定义到底如何转换：</p>
<p>定义的样式：</p>
<p>​	比如我们现在要将所有192.168.10.0网段的IP在经过的时候全都转换成172.16.100.1这个假设出来的外网地址：</p>
<p>​	iptables -t nat -A POSTROUTING -s 192.168.10.0&#x2F;24 -j SNAT –to-source 172.16.100.1</p>
<p>​	这样，只要是来自本地网络的试图通过网卡访问网络的，都会被统统转换成172.16.100.1这个IP.</p>
<p>​	那么，如果172.16.100.1不是固定的怎么办？</p>
<p>​	我们都知道当我们使用联通或者电信上网的时候，一般它都会在每次你开机的时候随机生成一个外网的IP，意思就是外网地址是动态变换的。这时我们就要将外网地址换成 MASQUERADE(动态伪装):它可以实现自动寻找到外网地址，而自动将其改为正确的外网地址。所以，我们就需要这样设置：</p>
<p>​         iptables -t nat -A POSTROUTING -s 192.168.10.0&#x2F;24 -j MASQUERADE</p>
<p>​         这里要注意：地址伪装并不适用于所有的地方。</p>
<p>2.DNAT目标地址转换</p>
<p>​	对于目标地址转换，数据流向是从外向内的，外面的是客户端，里面的是服务器端通过目标地址转换，我们可以让外面的ip通过我们对外的外网ip来访问我们服务器不同的服务器，而我们的服务却放在内网服务器的不同的服务器上。</p>
<p>​    如何做目标地址转换呢？：</p>
<p>​		iptables -t nat -A PREROUTING -d 192.168.10.18 -p tcp –dport 80 -j DNAT –todestination 172.16.100.2</p>
<p>​        目标地址转换要做在到达网卡之前进行转换,所以要做在PREROUTING这个位置上</p>
<p>九：控制规则的存放以及开启</p>
<p>​	注意：你所定义的所有内容，当你重启的时候都会失效，要想我们能够生效，需要使用一个命令将它保存起来</p>
<p>​	1.service iptables save 命令</p>
<p>​		它会保存在&#x2F;etc&#x2F;sysconfig&#x2F;iptables这个文件中</p>
<p>​    2.iptables-save 命令</p>
<p>​		iptables-save &gt; &#x2F;etc&#x2F;sysconfig&#x2F;iptables</p>
<p>​    3.iptables-restore 命令</p>
<p>​			开机的时候，它会自动加载&#x2F;etc&#x2F;sysconfig&#x2F;iptabels</p>
<p>​			如果开机不能加载或者没有加载，而你想让一个自己写的配置文件（假设为iptables.2）手动生效的话：</p>
<p>​			iptables-restore &lt; &#x2F;etc&#x2F;sysconfig&#x2F;iptables.2</p>
<p>​			则完成了将iptables中定义的规则手动生效</p>
<h3 id="4-6-2-总结"><a href="#4-6-2-总结" class="headerlink" title="4.6.2 总结"></a>4.6.2 总结</h3><p>Iptables是一个非常重要的工具，它是每一个防火墙上几乎必备的设置，也是我们在做大型网络的时候，为了很多原因而必须要设置的。学好Iptables,可以让我们对整个网络的结构有一个比较深刻的了解，同时，我们还能够将内核空间中数据的走向以及linux的安全给掌握的非常透彻。我们在学习的时候，尽量能结合着各种各样的项目，实验来完成，这样对你加深iptables的配置，以及各种技巧有非常大的帮助。</p>
<p>附加iptables比较好的文章：</p>
<p>netfilter&#x2F;iptables全攻略</p>
<h2 id="4-7-shell调试"><a href="#4-7-shell调试" class="headerlink" title="4.7 shell调试"></a>4.7 shell调试</h2><h3 id="4-7-1-使用trap"><a href="#4-7-1-使用trap" class="headerlink" title="4.7.1 使用trap"></a>4.7.1 使用trap</h3><p>trap [command] signal</p>
<h5 id="4-7-1-0-1-信号"><a href="#4-7-1-0-1-信号" class="headerlink" title="4.7.1.0.1 信号"></a>4.7.1.0.1 信号</h5><p>信号名	何时产生</p>
<p>EXIT	从一个函数中退出或整个脚本执行完毕</p>
<p>ERR	当一条命令返回非零状态时(代表命令执行不成功)</p>
<p>DEBUG	脚本中每一条命令执行之前</p>
<h3 id="4-7-2-使用tee命令"><a href="#4-7-2-使用tee命令" class="headerlink" title="4.7.2 使用tee命令"></a>4.7.2 使用tee命令</h3><p>ifconfig eth0 | cut –f 3 | tee temp.txt</p>
<h3 id="4-7-3-使用调试函数"><a href="#4-7-3-使用调试函数" class="headerlink" title="4.7.3 使用调试函数"></a>4.7.3 使用调试函数</h3><p>DEBUG()</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps49.png" alt="img"></p>
<h3 id="4-7-4-调试选项"><a href="#4-7-4-调试选项" class="headerlink" title="4.7.4 调试选项"></a>4.7.4 调试选项</h3><p>-n 只读取shell脚本，但不实际执行</p>
<p>-x 进入跟踪方式，显示所执行的每一条命令</p>
<p>-c “string” 从strings中读取命令</p>
<p>“-n”可用于测试shell脚本是否存在语法错误，但不会实际执行命令。在shell脚本编写完成之后，实际执行之前，首先使用“-n”选项来测试脚本是否存在语法错误是一个很好的习惯。因为某些shell脚本在执行时会对系统环境产生影响，比如生成或移动文件等，如果在实际执行才发现语法错误，您不得不手工做一些系统环境的恢复工作才能继续测试这个脚本。 </p>
<p>“-c”选项使shell解释器从一个字符串中而不是从一个文件中读取并执行shell命令。当需要临时测试一小段脚本的执行结果时，可以使用这个选项，如下所示：<br>sh -c ‘a&#x3D;1;b&#x3D;2;let c&#x3D;$a+$b;echo “c&#x3D;$c”‘ </p>
<p>“-x”选项可用来跟踪脚本的执行，是调试shell脚本的强有力工具。“-x”选项使shell在执行脚本的过程中把它实际执行的每一个命令行显示出来，并且在行首显示一个”+”号。 “+”号后面显示的是经过了变量替换之后的命令行的内容，有助于分析实际执行的是什么命令。 “-x”选项使用起来简单方便，可以轻松对付大多数的shell调试任务,应把其当作首选的调试手段。 </p>
<h3 id="4-7-5-对”-x”选项的增强"><a href="#4-7-5-对”-x”选项的增强" class="headerlink" title="4.7.5 对”-x”选项的增强"></a>4.7.5 对”-x”选项的增强</h3><p>“-x”执行选项是目前最常用的跟踪和调试shell脚本的手段，但其输出的调试信息仅限于进行变量替换之后的每一条实际执行的命令以及行首的一个”+”号提示符，居然连行号这样的重要信息都没有，对于复杂的shell脚本的调试来说，还是非常的不方便。幸运的是，我们可以巧妙地利用shell内置的一些环境变量来增强”-x”选项的输出信息，下面先介绍几个shell内置的环境变量： </p>
<p>$BASH_SOURCE</p>
<p>当前脚本名称</p>
<p>$LINENO<br>代表shell脚本的当前行号，类似于C语言中的内置宏__LINE__ </p>
<p>$FUNCNAME<br>函数的名字，类似于C语言中的内置宏__func__,但宏__func__只能代表当前所在的函数名，而$FUNCNAME的功能更强大，它是一个数组变量，其中包含了整个调用链上所有的函数的名字，故变量${FUNCNAME[0]}代表shell脚本当前正在执行的函数的名字，而变量${FUNCNAME[1]}则代表调用函数${FUNCNAME[0]}的函数的名字，余者可以依此类推。 </p>
<p>$PS4<br>主提示符变量$PS1和第二级提示符变量$PS2比较常见，但很少有人注意到第四级提示符变量$PS4的作用。我们知道使用“-x”执行选项将会显示shell脚本中每一条实际执行过的命令，而$PS4的值将被显示在“-x”选项输出的每一条命令的前面。在Bash Shell中，缺省的$PS4的值是”+”号。(现在知道为什么使用”-x”选项时，输出的命令前面有一个”+”号了吧？)。 </p>
<p>利用$PS4这一特性，通过使用一些内置变量来重定义$PS4的值，我们就可以增强”-x”选项的输出信息。例如先执行export PS4&#x3D;’+{$LINENO:${FUNCNAME[0]}} ‘, 然后再使用“-x”选项来执行脚本，就能在每一条实际执行的命令前面显示其行号以及所属的函数名。 </p>
<p>以下是一个存在bug的shell脚本的示例，本文将用此脚本来示范如何用“-n”以及增强的“-x”执行选项来调试shell脚本。这个脚本中定义了一个函数isRoot(),用于判断当前用户是不是root用户，如果不是，则中止脚本的执行 </p>
<p>$ cat –n exp4.sh</p>
<p>​     1  #!&#x2F;bin&#x2F;bash</p>
<p>​     2  isRoot()</p>
<p>​     3  {</p>
<p>​     4          if [ “$UID” -ne 0 ]</p>
<p>​     5                  return 1</p>
<p>​     6          else</p>
<p>​     7                  return 0</p>
<p>​     8          fi</p>
<p>​     9  }</p>
<p>​    10  isRoot</p>
<p>​    11  if [“$?” -ne 0 ]</p>
<p>​    12  then</p>
<p>​    13          echo “Must be root to run this script”</p>
<p>​    14          exit 1</p>
<p>​    15  else</p>
<p>​    16          echo “welcome root user”</p>
<p>​    17          #do something</p>
<p>​    18  fi</p>
<p>首先执行sh –n exp4.sh来进行语法检查，输出如下： </p>
<p>$ sh –n exp4.sh</p>
<p>exp4.sh: line 6: syntax error near unexpected token &#96;else’</p>
<p>exp4.sh: line 6: &#96;      else’</p>
<p>发现了一个语法错误，通过仔细检查第6行前后的命令，我们发现是第4行的if语句缺少then关键字引起的(写惯了C程序的人很容易犯这个错误)。我们可以把第4行修改为if [ “$UID” -ne 0 ]; then来修正这个错误。再次运行sh –n exp4.sh来进行语法检查，没有再报告错误。接下来就可以实际执行这个脚本了，执行结果如下： </p>
<p>$ sh exp4.sh</p>
<p>exp2.sh: line 11: [1: command not found</p>
<p>welcome root user</p>
<p>尽管脚本没有语法错误了，在执行时却又报告了错误。错误信息还非常奇怪“[1: command not found”。现在我们可以试试定制$PS4的值，并使用“-x”选项来跟踪： </p>
<p>$ export PS4&#x3D;’+{$LINENO:${FUNCNAME[0]}} ‘</p>
<p>$ sh –x exp4.sh</p>
<p>+{10:} isRoot</p>
<p>+{4:isRoot} ‘[‘ 503 -ne 0 ‘]’</p>
<p>+{5:isRoot} return 1</p>
<p>+{11:} ‘[1’ -ne 0 ‘]’</p>
<p>exp4.sh: line 11: [1: command not found</p>
<p>+{16:} echo ‘welcome root user’</p>
<p>welcome root user</p>
<p>从输出结果中，我们可以看到脚本实际被执行的语句，该语句的行号以及所属的函数名也被打印出来，从中可以清楚的分析出脚本的执行轨迹以及所调用的函数的内部执行情况。由于执行时是第11行报错，这是一个if语句，我们对比分析一下同为if语句的第4行的跟踪结果： </p>
<p>+{4:isRoot} ‘[‘ 503 -ne 0 ‘]’</p>
<p>+{11:} ‘[1’ -ne 0 ‘]’</p>
<p>可知由于第11行的[号后面缺少了一个空格，导致[号与紧挨它的变量$?的值1被shell解释器看作了一个整体，并试着把这个整体视为一个命令来执行，故有“[1: command not found”这样的错误提示。只需在[号后面插入一个空格就一切正常了。 </p>
<p>shell中还有其它一些对调试有帮助的内置变量，比如在Bash Shell中还有BASH_SOURCE, BASH_SUBSHELL等一批对调试有帮助的内置变量，您可以通过man sh或man bash来查看，然后根据您的调试目的,使用这些内置变量来定制$PS4，从而达到增强“-x”选项的输出信息的目的。 </p>
<h3 id="4-7-6-总结"><a href="#4-7-6-总结" class="headerlink" title="4.7.6 总结"></a>4.7.6 总结</h3><p>现在让我们来总结一下调试shell脚本的过程：<br>首先使用“-n”选项检查语法错误，然后使用“-x”选项跟踪脚本的执行，使用“-x”选项之前，别忘了先定制PS4变量的值来增强“-x”选项的输出信息，至少应该令其输出行号信息(先执行export PS4&#x3D;’+[$LINENO]’，更一劳永逸的办法是将这条语句加到您用户主目录的.bash_profile文件中去)，这将使你的调试之旅更轻松。也可以利用trap,调试钩子等手段输出关键调试信息，快速缩小排查错误的范围，并在脚本中使用“set -x”及“set +x”对某些代码块进行重点跟踪。这样多种手段齐下，相信您已经可以比较轻松地抓出您的shell脚本中的臭虫了。如果您的脚本足够复杂，还需要更强的调试能力，可以使用shell调试器bashdb，这是一个类似于GDB的调试工具，可以完成对shell脚本的断点设置，单步执行，变量观察等许多功能，使用bashdb对阅读和理解复杂的shell脚本也会大有裨益。关于bashdb的安装和使用，不属于本文范围，您可参阅<a target="_blank" rel="noopener" href="http://bashdb.sourceforge.net/%E4%B8%8A%E7%9A%84%E6%96%87%E6%A1%A3%E5%B9%B6%E4%B8%8B%E8%BD%BD%E8%AF%95%E7%94%A8%E3%80%82">http://bashdb.sourceforge.net/上的文档并下载试用。</a> </p>
<h2 id="4-8-shell多行注释"><a href="#4-8-shell多行注释" class="headerlink" title="4.8 shell多行注释"></a>4.8 shell多行注释</h2><h3 id="4-8-1-法一"><a href="#4-8-1-法一" class="headerlink" title="4.8.1 法一"></a>4.8.1 法一</h3><p>: ‘</p>
<p>语句1</p>
<p>语句2</p>
<p>语句3</p>
<p>语句4</p>
<p>‘</p>
<p>例如：</p>
<p>linux101:&#x2F;home&#x2F;wsj # sh dian<br>ni<br>ni<br>ni<br>ni<br>ni<br>ni</p>
<p>linux101:&#x2F;home&#x2F;wsj # more dian<br>#!&#x2F;bin&#x2F;ksh<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”</p>
<p>: ‘<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>‘</p>
<h3 id="4-8-2-法二"><a href="#4-8-2-法二" class="headerlink" title="4.8.2 法二"></a>4.8.2 法二</h3><p>if false; then</p>
<p>语句1</p>
<p>语句2</p>
<p>语句3</p>
<p>语句4</p>
<p>fi</p>
<p>linux101:&#x2F;home&#x2F;wsj # sh dian<br>ni<br>ni<br>ni<br>ni<br>ni<br>ni</p>
<p>linux101:&#x2F;home&#x2F;wsj # more dian<br>#!&#x2F;bin&#x2F;ksh<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”</p>
<p>if false; then<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>echo “ni”<br>fi</p>
<h3 id="4-8-3-法三"><a href="#4-8-3-法三" class="headerlink" title="4.8.3 法三"></a>4.8.3 法三</h3><p>: &lt;&lt; 字符  #这里的字符可以是数字或者是字符都可以</p>
<p>语句1</p>
<p>语句2</p>
<p>语句3</p>
<p>语句4</p>
<p>字符                         </p>
<h3 id="4-8-4-法四"><a href="#4-8-4-法四" class="headerlink" title="4.8.4 法四"></a>4.8.4 法四</h3><p>((0)) &amp; {</p>
<p>语句1</p>
<p>语句2</p>
<p>语句3</p>
<p>}</p>
<h2 id="4-9-expect"><a href="#4-9-expect" class="headerlink" title="4.9 expect"></a>4.9 expect</h2><h3 id="4-9-1-warning"><a href="#4-9-1-warning" class="headerlink" title="4.9.1 warning"></a>4.9.1 <a target="_blank" rel="noopener" href="http://blog.csdn.net/woyuditan26/article/details/41516359">warning</a></h3><p>[warning: here-document at line 17 delimited by end-of-file (wanted &#96;EOF’) ](<a target="_blank" rel="noopener" href="http://blog.csdn.net/woyuditan26/article/details/41516359">http://blog.csdn.net/woyuditan26/article/details/41516359</a>)</p>
<p>原因是末尾的EOF后面带有空格，EOF前后都不应有空格或其他符号</p>
<h3 id="4-9-2-expect实例详解"><a href="#4-9-2-expect实例详解" class="headerlink" title="4.9.2 expect实例详解****"></a>4.9.2 expect实例详解****</h3><p><strong>1. expect 是基于tcl 演变而来的，所以很多语法和tcl 类似，基本的语法如下</strong></p>
<p><strong>所示：</strong></p>
<p>1.1 首行加上&#x2F;usr&#x2F;bin&#x2F;expect</p>
<p>1.2 spawn: 后面加上需要执行的shell 命令，比如说spawn sudo touch testfile</p>
<p>1.3 expect: 只有spawn 执行的命令结果才会被expect 捕捉到，因为spawn 会启</p>
<p>动一个进程，只有这个进程的相关信息才会被捕捉到，主要包括：标准输入的提示信息，eof 和timeout。</p>
<p>1.4 send 和send_user：send 会将expect 脚本中需要的信息发送给spawn 启动</p>
<p>的那个进程，而send_user 只是回显用户发出的信息，类似于shell 中的echo 而</p>
<p>已。</p>
<p><strong>2. 一个小例子，用于linux 下账户的建立：</strong></p>
<p>filename: account.sh，可以使用.&#x2F;account.sh newaccout 来执行；</p>
<p>1 #!&#x2F;usr&#x2F;bin&#x2F;expect</p>
<p>2</p>
<p>3 set passwd “mypasswd”</p>
<p>4 set timeout 60</p>
<p>5</p>
<p>6 if {$argc !&#x3D; 1} {</p>
<p>7 send “usage .&#x2F;account.sh $newaccount\n”</p>
<p>8 exit</p>
<p>9 }</p>
<p>10</p>
<p>11 set user [lindex $argv [expr $argc-1]]</p>
<p>12</p>
<p>13 spawn sudo useradd -s &#x2F;bin&#x2F;bash -g mygroup -m $user</p>
<p>14</p>
<p>15 expect {</p>
<p>16 “assword” {</p>
<p>17 send_user “sudo now\n”</p>
<p>18 send “$passwd\n”</p>
<p>19 exp_continue</p>
<p>20 }</p>
<p>21 eof</p>
<p>22 {</p>
<p>23 send_user “eof\n”</p>
<p>24 }</p>
<p>25 }</p>
<p>26</p>
<p>27 spawn sudo passwd $user</p>
<p>28 expect {</p>
<p>29 “assword” {</p>
<p>30 send “$passwd\n”</p>
<p>31 exp_continue</p>
<p>32 }</p>
<p>33 eof</p>
<p>34 {</p>
<p>35 send_user “eof”</p>
<p>36 }</p>
<p>37 }</p>
<p>38</p>
<p>39 spawn sudo smbpasswd -a $user</p>
<p>40 expect {</p>
<p>41 “assword” {</p>
<p>42 send “$passwd\n”</p>
<p>43 exp_continue</p>
<p>44 }</p>
<p>45 eof</p>
<p>46 {</p>
<p>47 send_user “eof”</p>
<p>48 }</p>
<p>49 }</p>
<p><strong>3. 注意点：</strong></p>
<p>第3 行： 对变量赋值的方法；</p>
<p>第4 行： 默认情况下，timeout 是10 秒；</p>
<p>第6 行： 参数的数目可以用$argc 得到；</p>
<p>第11 行：参数存在$argv 当中，比如取第一个参数就是[lindex $argv 0]；并且</p>
<p>如果需要计算的话必须用expr，如计算2-1，则必须用[expr 2-1]；</p>
<p>第13 行：用spawn 来执行一条shell 命令，shell 命令根据具体情况可自行调整；</p>
<p>有文章说sudo 要加-S，经过实际测试，无需加-S 亦可；</p>
<p>第15 行：一般情况下，如果连续做两个expect，那么实际上是串行执行的，用。<strong>expect 与“{ ”之间直接必须有空格或则TAB间隔，否则会出麻烦，会报错invalid command name “expect{“</strong>** **</p>
<p>例子中的结构则是并行执行的，主要是看匹配到了哪一个；在这个例子中，如果</p>
<p>你写成串行的话，即</p>
<p>expect “assword”</p>
<p>send “$passwd\n”</p>
<p>expect eof</p>
<p>send_user “eof”</p>
<p>那么第一次将会正确运行，因为第一次sudo 时需要密码；但是第二次运行时由于</p>
<p>密码已经输过（默认情况下sudo 密码再次输入时间为5 分钟），则不会提示用户</p>
<p>去输入，所以第一个expect 将无法匹配到assword，而且必须注意的是如果是</p>
<p>spawn 命令出现交互式提问的但是expect 匹配不上的话，那么程序会按照timeout</p>
<p>的设置进行等待；可是如果spawn 直接发出了eof 也就是本例的情况，那么expect</p>
<p>“assword”将不会等待，而直接去执行expect eof。</p>
<p>这时就会报expect: spawn id exp6 not open，因为没有spawn 在执行，后面的</p>
<p>expect 脚本也将会因为这个原因而不再执行；所以对于类似sudo 这种命令分支</p>
<p>不定的情况，最好是使用并行的方式进行处理；</p>
<p>第17 行：仅仅是一个用户提示而已，可以删除；</p>
<p>第18 行：向spawn 进程发送password；</p>
<p>第19 行：使得spawn 进程在匹配到一个后再去匹配接下来的交互提示；</p>
<p>第21 行：eof 是必须去匹配的，在spawn 进程结束后会向expect 发送eof；如果</p>
<p>不去匹配，有时也能运行，比如sleep 多少秒后再去spawn 下一个命令，但是不</p>
<p>要依赖这种行为，很有可能今天还可以，明天就不能用了；</p>
<p><strong>4. 其他</strong></p>
<p>下面这个例子比较特殊，在整个过程中就不能expect eof 了：</p>
<p>1 #!&#x2F;usr&#x2F;bin&#x2F;expect</p>
<p>2</p>
<p>3 set timeout 30</p>
<p>4 spawn ssh 10.192.224.224</p>
<p>5 expect “password:”</p>
<p>6 send “mypassword\n”</p>
<p>7 expect “*$”</p>
<p>8 <strong>send “mkdir tmpdir\n” #远程执行命令用send发送，不用spawn</strong></p>
<p>9 expect “<em>$” #注意这个地方，要与操作系统上环境变量PS1相匹配，尤其是有PS1有空格的情况下，一定在expct “</em>$ “把空格加上，加不上你就完蛋了。我试过。</p>
<p>这个例子实际上是通过ssh 去登录远程机器，并且在远程机器上创佳一个目录，</p>
<p>我们看到在我们输入密码后并没有去expect eof，这是因为ssh 这个spawn 并没</p>
<p>有结束，而且手动操作时ssh 实际上也不会自己结束除非你exit；所以你只能</p>
<p>expect bash 的提示符，当然也可以是机器名等，这样才可以在远程创建一个目</p>
<p>录。</p>
<p>注意，请不要用spawn mkdir tmpdir，<strong>这样会使得上一个spawn 即ssh 结束，那</strong></p>
<p>么你的tmpdir 将在本机建立。</p>
<p>当然实际情况下可能会要你确认ssh key，可以通过并行的expect 进行处理，不</p>
<p>多赘述。</p>
<p>\5. 觉得bash 很多情况下已经很强大，所以可能用expect 只需要掌握这些就好了，</p>
<p>其他的如果用到可以再去google 了。</p>
<p>源代码图片：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps50.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps51.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps52.png" alt="img"> </p>
<p><strong>6 \实例：下面这个脚本是完成对单个服务器scp任务。</strong></p>
<p> 1: #!&#x2F;usr&#x2F;bin&#x2F;expect</p>
<p> 2: </p>
<p> 3: set timeout 10</p>
<p> 4: set host [lindex $argv 0]</p>
<p> 5: set username [lindex $argv 1]</p>
<p> 6: set password [lindex $argv 2]</p>
<p> 7: set src_file [lindex $argv 3]</p>
<p> 8: set dest_file [lindex $argv 4]</p>
<p> 9: </p>
<p>10: spawn scp  $src_file $username@$host:$dest_file</p>
<p> 11: expect {</p>
<p> 12:     “(yes&#x2F;no)?”</p>
<p> 13:         {</p>
<p> 14:             send “yes\n”</p>
<p> 15:             expect “*assword:” { send “$password\n”}</p>
<p> 16:         }</p>
<p> 17:     “*assword:”</p>
<p> 18:         {</p>
<p> 19:             send “$password\n”</p>
<p> 20:         }</p>
<p> 21:     }</p>
<p> 22: expect “100%”</p>
<p> 23: expect eof</p>
<p>参考源代码图片：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps53.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps54.png" alt="img"> </p>
<p>注意代码刚开始的第一行，指定了expect的路径，与shell脚本相同，这一句指定了程序在执行时到哪里去寻找相应的启动程序。代码刚开始还设定了timeout的时间为10秒，如果在执行scp任务时遇到了代码中没有指定的异常，则在等待10秒后该脚本的执行会自动终止。</p>
<p>spawn代表在本地终端执行的语句，在该语句开始执行后，expect开始捕获终端的输出信息，然后做出对应的操作。expect代码中的捕获的(yes&#x2F;no)内容用于完成第一次访问目标主机时保存密钥的操作。有了这一句，scp的任务减少了中断的情况。代码结尾的expect eof与spawn对应，表示捕获终端输出信息的终止。</p>
<p>有了这段expect的代码，还只能完成对单个远程主机的scp任务。如果需要<strong>实现批量scp的任务</strong>，则需要再写一个shell脚本来调用这个expect脚本。</p>
<p>1: #!&#x2F;bin&#x2F;sh</p>
<p> 2: </p>
<p> 3: list_file&#x3D;$1</p>
<p> 4: src_file&#x3D;$2</p>
<p> 5: dest_file&#x3D;$3</p>
<p> 6: </p>
<p>7: cat $list_file | while    read line</p>
<p> 8: do</p>
<p> 9:     host_ip&#x3D;<code>echo $line | awk &#39;&#123;print $1&#125;&#39;</code></p>
<p> 10:     username&#x3D;<code>echo $line | awk &#39;&#123;print $2&#125;&#39;</code></p>
<p> 11:     password&#x3D;<code>echo $line | awk &#39;&#123;print $3&#125;&#39;</code></p>
<p> 12:     echo “$host_ip”</p>
<p> 13:    ** .&#x2F;expect_scp $host_ip $username $password $src_file $dest_file**</p>
<p> 15: done</p>
<p>参考代码图片如下：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps55.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps56.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps57.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps58.png" alt="img"> </p>
<p>很简单的代码，指定了3个参数：列表文件的位置、本地源文件路径、远程主机目标文件路径。需要说明的是其中的列表文件指定了远程主机ip、用户名、密码，这些信息需要写成以下的格式：</p>
<p>IP username password</p>
<p>中间用空格或tab键来分隔，多台主机的信息需要写多行内容。</p>
<p>这样就指定了两台远程主机的信息。注意，如果远程<strong>主机密码中有“$”、“#”这类特殊字符</strong>的话，在编写列表文件时就需要在这些特殊字符前<strong>加上转义字符</strong>，否则expect在执行时会输入错误的密码。</p>
<p>对于这个shell脚本，保存为batch_scp.sh文件，与刚才保存的expect_scp文件和列表文件(就定义为hosts.list文件吧)放到同一目录下，执行时按照以下方式输入命令就可以了：</p>
<h2 id="4-10-Bash内建变量"><a href="#4-10-Bash内建变量" class="headerlink" title="4.10 Bash内建变量"></a>4.10 Bash内建变量</h2><h3 id="4-10-1-BASH"><a href="#4-10-1-BASH" class="headerlink" title="4.10.1 $BASH"></a>4.10.1 $BASH</h3><p>这个变量将指向Bash的二进制执行文件的位置.</p>
<h3 id="4-10-2-BASH-ENV"><a href="#4-10-2-BASH-ENV" class="headerlink" title="4.10.2 $BASH_ENV"></a>4.10.2 $BASH_ENV</h3><p>这个环境变量将指向一个Bash启动文件,这个启动文件将在调用一个脚本时被读取</p>
<h3 id="4-10-3-BASH-SUBSHELL"><a href="#4-10-3-BASH-SUBSHELL" class="headerlink" title="4.10.3 $BASH_SUBSHELL"></a>4.10.3 $BASH_SUBSHELL</h3><p>这个变量将提醒subshell的层次,这是一个在version3才被添加到Bash中的新特性</p>
<h3 id="4-10-4-BASH-VERSINFO-n"><a href="#4-10-4-BASH-VERSINFO-n" class="headerlink" title="4.10.4  $BASH_VERSINFO[n]"></a>4.10.4  $BASH_VERSINFO[n]</h3><p>记录Bash安装信息的一个6元素的数组.与下边的$BASH_VERSION很像,但这个更加详细.</p>
<p># BASH_VERSINFO[0] &#x3D; 3                       # 主版本号</p>
<p># BASH_VERSINFO[1] &#x3D;00                      # 次版本号</p>
<p># BASH_VERSINFO[2] &#x3D; 14                     # Patch 次数.</p>
<p># BASH_VERSINFO[3] &#x3D; 1                      # Build version.</p>
<p># BASH_VERSINFO[4] &#x3D; release                 # Release status.</p>
<p># BASH_VERSINFO[5] &#x3D; i386-redhat-Linux-gnu    # Architecture</p>
<h3 id="4-10-5-BASH-VERSION"><a href="#4-10-5-BASH-VERSION" class="headerlink" title="4.10.5 $BASH_VERSION"></a>4.10.5 $BASH_VERSION</h3><p>安装在系统上的Bash的版本号.</p>
<p>使用这个变量对于判断系统上到底运行的是那个shell来说是一种非常好的办法.$SHELL，有时将不能给出正确的答案. </p>
<h3 id="4-10-6-DIRSTACK"><a href="#4-10-6-DIRSTACK" class="headerlink" title="4.10.6 $DIRSTACK"></a>4.10.6 $DIRSTACK</h3><p>在目录栈中最上边的值(将受到pushd和popd的影响).这个内建的变量与dirs命令是保持一致的,但是dirs命令将显示目录栈的整个内容.</p>
<h3 id="4-10-7-EDITOR"><a href="#4-10-7-EDITOR" class="headerlink" title="4.10.7 $EDITOR"></a>4.10.7 $EDITOR</h3><p>脚本调用的默认编辑器,一般是vi或者是emacs.</p>
<h3 id="4-10-8-EUID"><a href="#4-10-8-EUID" class="headerlink" title="4.10.8 $EUID"></a>4.10.8 $EUID</h3><p>“effective”用户ID号，当前用户被假定的任何id号.可能在su命令中使用.</p>
<p>注意:$EUID并不一定与$UID相同.</p>
<h3 id="4-10-9-FUNCNAME"><a href="#4-10-9-FUNCNAME" class="headerlink" title="4.10.9 $FUNCNAME"></a>4.10.9 $FUNCNAME</h3><p>当前函数的名字.</p>
<h3 id="4-10-10-GLOBIGNORE"><a href="#4-10-10-GLOBIGNORE" class="headerlink" title="4.10.10 $GLOBIGNORE"></a>4.10.10 $GLOBIGNORE</h3><p>一个文件名的模式匹配列表,如果在file globbing中匹配到的文件包含这个列表中的</p>
<p>某个文件,那么这个文件将被从匹配到的文件中去掉.</p>
<h3 id="4-10-11-GROUPS"><a href="#4-10-11-GROUPS" class="headerlink" title="4.10.11 $GROUPS"></a>4.10.11 $GROUPS</h3><p>当前用户属于的组.</p>
<p>这是一个当前用户的组id列表(数组),就像在&#x2F;etc&#x2F;passwd中记录的一样.</p>
<h3 id="4-10-12-HOME"><a href="#4-10-12-HOME" class="headerlink" title="4.10.12 $HOME"></a>4.10.12 $HOME</h3><p>用户的home目录,一般都是&#x2F;home&#x2F;username</p>
<h3 id="4-10-13-HOSTNAME"><a href="#4-10-13-HOSTNAME" class="headerlink" title="4.10.13 $HOSTNAME"></a>4.10.13 $HOSTNAME</h3><p>hostname命令将在一个init脚本中,在启动的时候分配一个系统名字.，gethostname()函数将用来设置这个$HOSTNAME内部变量</p>
<h3 id="4-10-14-HOSTTYPE"><a href="#4-10-14-HOSTTYPE" class="headerlink" title="4.10.14 $HOSTTYPE"></a>4.10.14 $HOSTTYPE</h3><p>主机类型，就像$MACHTYPE,识别系统的硬件.</p>
<h3 id="4-10-15-IFS"><a href="#4-10-15-IFS" class="headerlink" title="4.10.15 $IFS"></a>4.10.15 $IFS</h3><p>内部域分隔符，这个变量用来决定Bash在解释字符串时如何识别域,或者单词边界.</p>
<p>$IFS默认为空白(空格,tab,和新行),但可以修改,比如在分析逗号分隔的数据文件时.</p>
<h3 id="4-10-16-IGNOREEOF"><a href="#4-10-16-IGNOREEOF" class="headerlink" title="4.10.16 $IGNOREEOF"></a>4.10.16 $IGNOREEOF</h3><p>忽略EOF: 告诉shell在log out之前要忽略多少文件结束符(control-D).</p>
<h3 id="4-10-17-LC-COLLATE"><a href="#4-10-17-LC-COLLATE" class="headerlink" title="4.10.17 $LC_COLLATE"></a>4.10.17 $LC_COLLATE</h3><p>常在.bashrc或&#x2F;etc&#x2F;profile中设置,这个变量用来在文件名扩展和模式匹配校对顺序.</p>
<p>如果$LC_COLLATE被错误的设置,那么将会在filename globbing中引起错误的结果.</p>
<p>注意:在2.05以后的Bash版本中,filename globbing将不在对[]中的字符区分大小写.</p>
<h3 id="4-10-18-LC-CTYPE"><a href="#4-10-18-LC-CTYPE" class="headerlink" title="4.10.18 $LC_CTYPE"></a>4.10.18 $LC_CTYPE</h3><p>这个内部变量用来控制globbing和模式匹配的字符串解释.</p>
<h3 id="4-10-19-LINENO"><a href="#4-10-19-LINENO" class="headerlink" title="4.10.19 $LINENO"></a>4.10.19 $LINENO</h3><p>这个变量记录它所在的shell脚本中它所在行的行号.这个变量一般用于调试目的</p>
<h3 id="4-10-20-MACHTYPE"><a href="#4-10-20-MACHTYPE" class="headerlink" title="4.10.20 $MACHTYPE"></a>4.10.20 $MACHTYPE</h3><p>系统类型，提示系统硬件</p>
<h3 id="4-10-21-OLDPWD"><a href="#4-10-21-OLDPWD" class="headerlink" title="4.10.21 $OLDPWD"></a>4.10.21 $OLDPWD</h3><p>老的工作目录(“OLD-print-working-directory”,你所在的之前的目录)</p>
<h3 id="4-10-22-OSTYPE"><a href="#4-10-22-OSTYPE" class="headerlink" title="4.10.22 $OSTYPE"></a>4.10.22 $OSTYPE</h3><p>操作系统类型.</p>
<h3 id="4-10-23-PATH"><a href="#4-10-23-PATH" class="headerlink" title="4.10.23 $PATH"></a>4.10.23 $PATH</h3><p>指向Bash外部命令所在的位置,一般为&#x2F;usr&#x2F;bin,&#x2F;usr&#x2F;X11R6&#x2F;bin,&#x2F;usr&#x2F;local&#x2F;bin等.</p>
<p>当给出一个命令时,Bash将自动对$PATH中的目录做一张hash表.$PATH中以”:”分隔的</p>
<p>目录列表将被存储在环境变量中.一般的,系统存储的$PATH定义在&#x2F;ect&#x2F;processed或PATH&#x3D;${PATH}:&#x2F;opt&#x2F;bin将把&#x2F;opt&#x2F;bin目录附加到$PATH变量中.在脚本中,这是一个添加目录到$PATH中的便捷方法.这样在这个脚本退出的时候,$PATH将会恢复(因为这个shell是个子进程,像这样的一个脚本是不会将它的父进程的环境变量修改的)</p>
<h3 id="4-10-24-PIPESTATUS"><a href="#4-10-24-PIPESTATUS" class="headerlink" title="4.10.24  $PIPESTATUS"></a>4.10.24  $PIPESTATUS</h3><p>数组变量将保存最后一个运行的前台管道的退出码.有趣的是,这个退出码和最后一个命令运行的退出码并不一定相同.</p>
<h3 id="4-10-25-PPID"><a href="#4-10-25-PPID" class="headerlink" title="4.10.25 $PPID"></a>4.10.25 $PPID</h3><p>一个进程的$PPID就是它的父进程的进程id(pid).[1]，使用pidof命令对比一下</p>
<h3 id="4-10-26-PROMPT-COMMAND"><a href="#4-10-26-PROMPT-COMMAND" class="headerlink" title="4.10.26 $PROMPT_COMMAND"></a>4.10.26 $PROMPT_COMMAND</h3><p>这个变量保存一个在主提示符($PS1)显示之前需要执行的命令.</p>
<h3 id="4-10-27-PS1"><a href="#4-10-27-PS1" class="headerlink" title="4.10.27 $PS1"></a>4.10.27 $PS1</h3><p>主提示符,具体见命令行上的显示.</p>
<h3 id="4-10-28-PS2"><a href="#4-10-28-PS2" class="headerlink" title="4.10.28 $PS2"></a>4.10.28 $PS2</h3><p>第2提示符,当你需要额外的输入的时候将会显示,默认为”&gt;”.</p>
<h3 id="4-10-29-PS3"><a href="#4-10-29-PS3" class="headerlink" title="4.10.29 $PS3"></a>4.10.29 $PS3</h3><p>第3提示符,在一个select循环中显示</p>
<h3 id="4-10-30-PS4"><a href="#4-10-30-PS4" class="headerlink" title="4.10.30 $PS4"></a>4.10.30 $PS4</h3><p>第4提示符,当使用-x选项调用脚本时,这个提示符将出现在每行的输出前边，默认为”+”.</p>
<h3 id="4-10-31-PWD"><a href="#4-10-31-PWD" class="headerlink" title="4.10.31 $PWD"></a>4.10.31 $PWD</h3><p>工作目录(你当前所在的目录).与pwd内建命令作用相同.</p>
<h3 id="4-10-32-REPLY"><a href="#4-10-32-REPLY" class="headerlink" title="4.10.32 $REPLY"></a>4.10.32 $REPLY</h3><p>read命令如果没有给变量,那么输入将保存在$REPLY中.在select菜单中也可用,但是只提供选择的变量的项数,而不是变量本身的值. $REPLY是’read’命令结果保存的默认变量</p>
<h3 id="4-10-33-SECONDS"><a href="#4-10-33-SECONDS" class="headerlink" title="4.10.33 $SECONDS"></a>4.10.33 $SECONDS</h3><p>这个脚本已经运行的时间(单位为秒).</p>
<h3 id="4-10-34-SHELLOPTS"><a href="#4-10-34-SHELLOPTS" class="headerlink" title="4.10.34 $SHELLOPTS"></a>4.10.34 $SHELLOPTS</h3><p>这个变量里保存shell允许的选项,这个变量是只读的.</p>
<h3 id="4-10-35-SHLVL"><a href="#4-10-35-SHLVL" class="headerlink" title="4.10.35 $SHLVL"></a>4.10.35 $SHLVL</h3><p>Shell层次,就是shell层叠的层次,如果是命令行那$SHLVL就是1,如果命令行执行的脚本中,$SHLVL就是2,以此类推</p>
<h3 id="4-10-36-TMOUT"><a href="#4-10-36-TMOUT" class="headerlink" title="4.10.36  $TMOUT"></a>4.10.36  $TMOUT</h3><p>如果$TMOUT环境变量被设置为一个非零的时间值,那么在过了这个指定的时间之后,shell提示符将会超时,这会引起一个logout.,在2.05b版本的Bash中,已经支持在一个带有read命令的脚本中使用$TMOUT变量.</p>
<h3 id="4-10-37-其他"><a href="#4-10-37-其他" class="headerlink" title="4.10.37 其他"></a>4.10.37 其他</h3><p>Bash shell中的位置参数$#,$*,$@,$0,$1,$2…及特殊参数$?,$-等的含义</p>
<p>在Bash shell中经常会见到一些比较特殊的符号</p>
<p>位置参数：</p>
<p>$1, $2, $3等等…</p>
<p>位置参数,从命令行传递给脚本,或者是传递给函数.或者赋值给一个变量.此数目可以任意多，但只有前9个可以被访问，使用shift命令可以改变这个限制。</p>
<p>$0表示当前执行的进程名,script 本身的名字,或者在正则表达式中表示整行输出</p>
<p>$#</p>
<p>命令行或者是位置参数的个数.(见Example 33-2)</p>
<p>$*</p>
<p>所有的位置参数,被作为一个单词.注意:”$*”必须被””引用.</p>
<p>$@</p>
<p>与$*同义,但是每个参数都是一个独立的””引用字串,这就意味着参数被完整地传递,</p>
<p>并没有被解释和扩展.这也意味着,每个参数列表中的每个参数都被当成一个独立的单词.</p>
<p>注意:”$@”必须被””引用.</p>
<p>其他的特殊参数</p>
<p>$-</p>
<p>传递给脚本的falg(使用set 命令).参考Example 11-15.</p>
<p>显示shell使用的当前选项，与set命令功能相同</p>
<p>注意:这起初是ksh 的特征,后来被引进到Bash 中,但不幸的是,在Bash 中它看上去也不</p>
<p>能可靠的工作.使用它的一个可能的方法就是让这个脚本进行自我测试(查看是否是交</p>
<p>互的).</p>
<p>$!</p>
<p>在后台运行的最后的工作的PID(进程ID).</p>
<p>$_</p>
<p>保存之前执行的命令的最后一个参数.</p>
<p>$?</p>
<p>命令,函数或者脚本本身的退出状态(见Example 23-7)</p>
<p>用于检查上一个命令,函数或者脚本执行是否正确。（在Linux中，命令退出状态为0表示该命令正确执行，任何非0值表示命令出错。）</p>
<p>$$</p>
<p>脚本自身的进程ID.这个变量经常用来构造一个”unique”的临时文件名.</p>
<p>(参考Example A-13,Example 29-6,Example 12-28 和Example 11-25).</p>
<p>这通常比调用mktemp 来得简单.</p>
<p>注意事项:</p>
<p>[1] 当前运行的脚本的PID 为$$.</p>
<p>[2] “argument”和”parameter”这两个单词经常不加区分的使用.在这整本书中,这两个</p>
<p>单词的意思完全相同.(在翻译的时候就未加区分,统统翻译成参数)</p>
<h2 id="4-11-字体颜色"><a href="#4-11-字体颜色" class="headerlink" title="4.11 字体颜色"></a>4.11 字体颜色</h2><p>#!&#x2F;bin&#x2F;bash</p>
<p>#</p>
<p>#下面是字体输出颜色及终端格式控制</p>
<p>#字体色范围：30-37</p>
<p>echo -e “\033[30m 黑色字 \033[0m”</p>
<p>echo -e “\033[31m 红色字 \033[0m”</p>
<p>echo -e “\033[32m 绿色字 \033[0m”</p>
<p>echo -e “\033[33m 黄色字 \033[0m”</p>
<p>echo -e “\033[34m 蓝色字 \033[0m”</p>
<p>echo -e “\033[35m 紫色字 \033[0m”</p>
<p>echo -e “\033[36m 天蓝字 \033[0m”</p>
<p>echo -e “\033[37m 白色字 \033[0m”</p>
<p>#字背景颜色范围：40-47</p>
<p>echo -e “\033[40;37m 黑底白字 \033[0m”</p>
<p>echo -e “\033[41;30m 红底黑字 \033[0m”</p>
<p>echo -e “\033[42;34m 绿底蓝字 \033[0m”</p>
<p>echo -e “\033[43;34m 黄底蓝字 \033[0m”</p>
<p>echo -e “\033[44;30m 蓝底黑字 \033[0m”</p>
<p>echo -e “\033[45;30m 紫底黑字 \033[0m”</p>
<p>echo -e “\033[46;30m 天蓝底黑字 \033[0m”</p>
<p>echo -e “\033[47;34m 白底蓝字 \033[0m”</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps59.png" alt="img"></p>
<h1 id="第-5-章-makefile"><a href="#第-5-章-makefile" class="headerlink" title="第 5 章 makefile"></a>第 5 章 makefile</h1><h2 id="5-1-基本语法"><a href="#5-1-基本语法" class="headerlink" title="5.1 基本语法"></a>5.1 基本语法</h2><p>变量名可以使用字母、数字和下划线。makefile中的第一个目标会被作为默认目标。</p>
<p><strong>Makefile文件中相应的命令行前一定要有一个制表符。</strong>****</p>
<h3 id="5-1-1-makefile规则"><a href="#5-1-1-makefile规则" class="headerlink" title="5.1.1 makefile规则"></a>5.1.1 makefile规则</h3><p>目标：依赖</p>
<p>​	命令</p>
<p>[1] 隐式规则</p>
<p>所有.o文件都可自动由.c文件使用命令$(CC) $(CPPFLAGS) $(CFLAGS) –c file.c –o file.o生成。注意：隐式规则只能查找相同文件名，不同后缀的文件。</p>
<p>隐式规则目录：</p>
<p>c编译器：.c变为.o                $(CC) –c $(CPPFLAGS) $(CFLAGS) </p>
<p>c++     : .cc或.C变为.o				$(CXX) –c $(CPPFLAGS) $(CXXFLAGS) </p>
<p>[2] 模式规则</p>
<h3 id="5-1-2-变量"><a href="#5-1-2-变量" class="headerlink" title="5.1.2 变量"></a>5.1.2 变量</h3><p>[1] 预定义变量</p>
<p>AR			库文件维护程序名称    默认值为ar</p>
<p>CC			c编译器的名称 默认值为gcc</p>
<p>CXX			c编译器的名称 默认值为g++</p>
<p>CFLAGS		c编译器选项   无默认值</p>
<p>CXXFLAGS	c++编译器选项   无默认值</p>
<p>[2] 简单变量：</p>
<p>定义：变量名：&#x3D;[文本]</p>
<p>添加：变量名+&#x3D;[文本]</p>
<p>object  :&#x3D;  main.o</p>
<p>object	+&#x3D;	import.o	output.o</p>
<p>引用：$(变量名)		c&#x3D;gcc</p>
<p>​	   ${变量名}		$c</p>
<p>​		$单字符变量	cc&#x3D;gcc		$(cc)</p>
<p>[3] 自动变量&#x2F;内置变量</p>
<p>在makefile中，存在系统默认的自动化变量</p>
<p>$^：用空格分开的所有的依赖文件</p>
<p>$@：当前目标的名称（代表目标列表）</p>
<p>$?:比当前目标更新的已修改的依赖性列表（代表所有已更新的依赖文件）	</p>
<p>$&lt;：比当前目标更新的已修改的当前依赖性名称（代表第一个依赖文件）</p>
<p>$%  如果目标是归档成员，则该变量表示目标的归档成员名称</p>
<p>例：hello: main.o func1.o func2.o</p>
<p>gcc main.o func1.o func2.o -o hello </p>
<p>&#x3D;》</p>
<p>hello: main.o func1.o func2.o</p>
<p>gcc  $^  -o  $@</p>
<p>[4] 其他</p>
<p>目标 依赖 命令</p>
<p>main.o: main.c </p>
<p>gcc  –c  main.c </p>
<p> makefile例：</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>hello:hello.o</p>
<p>​		gcc    hello.o  -o  hello</p>
<p>hello.o:hello.c</p>
<p>​		gcc	 -c  hello.c   </p>
<p>clean:</p>
<p>​		rm  *.o  hello</p>
<h3 id="5-1-3-函数"><a href="#5-1-3-函数" class="headerlink" title="5.1.3 函数"></a>5.1.3 函数</h3><h3 id="5-1-4-伪目标-x2F-虚目标"><a href="#5-1-4-伪目标-x2F-虚目标" class="headerlink" title="5.1.4 伪目标&#x2F;虚目标"></a>5.1.4 伪目标&#x2F;虚目标</h3><p>Makefile中把那些没有任何依赖只有执动作的目标称为“伪目标”（phony targets）。</p>
<p>常见虚目标列表：</p>
<p>all、clean、install、uninstall。</p>
<p>若本地已有目标文件则要用.PHONY</p>
<p>.PHONY :clean</p>
<p>clean : </p>
<p>rm –f hellomain.o func1.ofunc2.o</p>
<p>“.PHONY” 将“clean”目标声明为伪目标，虚目标允许同名文件存在</p>
<h3 id="5-1-5-makefile常见语法错误"><a href="#5-1-5-makefile常见语法错误" class="headerlink" title="5.1.5 makefile常见语法错误"></a>5.1.5 makefile常见语法错误</h3><p>[1] 缺少TAB键</p>
<p>可使用		cat  -t   makefile   查看TAB使用情况</p>
<p>其中使用了TAB键的以“^I”显示</p>
<p>[2] 在连接符’\’和换行符之间插入了空格</p>
<p>可用		cat  -e	 makefile  查看空格使用情况，一般结尾时以$结束</p>
<p>也可用		grep  ‘\[此处填一空格 ]$’  makefile 显示makefile中不正确的行</p>
<h3 id="5-1-6-命令行的使用和调试"><a href="#5-1-6-命令行的使用和调试" class="headerlink" title="5.1.6 命令行的使用和调试"></a>5.1.6 命令行的使用和调试</h3><p>[1] 使用非标准的makefile名称文件</p>
<p>make  -f  prog1.makefile</p>
<p>[2] 从标准输入读取</p>
<p>make  -f   -</p>
<p>[3] 显示makefile中所执行命令的顺序</p>
<p>make	 -n</p>
<h3 id="5-1-7-制作工程文件的makefile"><a href="#5-1-7-制作工程文件的makefile" class="headerlink" title="5.1.7 制作工程文件的makefile"></a>5.1.7 制作工程文件的makefile</h3><p>一般工程文件proc由以下部分组成：</p>
<p>[1] src：make.c  fun1.c		fun2.c</p>
<p>[2] include:fun1.h  fun2.h           fun2.h导出函数</p>
<p>[3] makefile</p>
<p>VPATH &#x3D; src:.&#x2F;headers</p>
<p>VPATH:指定依赖文件的搜索路径</p>
<p>src    第一搜索路径</p>
<p>.&#x2F;headers   第二搜索路径</p>
<h3 id="5-1-8-嵌套执行make"><a href="#5-1-8-嵌套执行make" class="headerlink" title="5.1.8 嵌套执行make"></a>5.1.8 嵌套执行make</h3><p>subsystem:</p>
<p>cd subdir  &amp;&amp;  $(MAKE)</p>
<h3 id="5-1-9-命令出错"><a href="#5-1-9-命令出错" class="headerlink" title="5.1.9 命令出错"></a>5.1.9 命令出错</h3><p>如果要忽略命令出错，我们可以在makefile的命令行前加一个减号“-”（在tab键之后），标记为不管命令是否出错都认为是成功的。</p>
<h3 id="5-1-10-杂项"><a href="#5-1-10-杂项" class="headerlink" title="5.1.10 杂项"></a>5.1.10 杂项</h3><p>Makefile中“#”字符后的内容被视作注释。</p>
<p>hello:hello.c</p>
<p>@gcc hello.c –o hello </p>
<h2 id="5-2-其他"><a href="#5-2-其他" class="headerlink" title="5.2 其他"></a>5.2 其他</h2><h3 id="5-2-1-定义宏"><a href="#5-2-1-定义宏" class="headerlink" title="5.2.1 定义宏"></a>5.2.1 定义宏</h3><p>DEFINES +&#x3D; -DTEST_DEF</p>
<h3 id="5-2-2-取消宏"><a href="#5-2-2-取消宏" class="headerlink" title="5.2.2 取消宏"></a>5.2.2 取消宏</h3><p>DEFINES +&#x3D; -UTEST_DEF</p>
<h3 id="5-2-3-注意TAB不能用4个空格代替"><a href="#5-2-3-注意TAB不能用4个空格代替" class="headerlink" title="5.2.3 注意TAB不能用4个空格代替"></a>5.2.3 注意TAB不能用4个空格代替</h3><h3 id="5-2-4-if语句"><a href="#5-2-4-if语句" class="headerlink" title="5.2.4 if语句"></a>5.2.4 if语句</h3><p>ifeq($VAR, “TEST”)</p>
<p>else ifeq($VAR,”TEST2”)</p>
<h3 id="5-2-5-得到已定义的宏"><a href="#5-2-5-得到已定义的宏" class="headerlink" title="5.2.5 得到已定义的宏"></a>5.2.5 得到已定义的宏</h3><p>make –p &gt;macro.txt 可以得到一些数据定义等</p>
<h2 id="5-3-项目构建Make-Automake-CMake"><a href="#5-3-项目构建Make-Automake-CMake" class="headerlink" title="5.3 项目构建Make,Automake,CMake"></a>5.3 项目构建Make,Automake,CMake</h2><p>在本系列文章<a target="_blank" rel="noopener" href="http://blog.csdn.net/dc_726/article/details/46475623">《C实战：强大的程序调试工具GDB》</a>中我们简要学习了流行的调试工具GDB的使用方法。本文继续“C实战”的主题，对同样非常流行的构建工具</p>
<h3 id="5-3-1-Automake"><a href="#5-3-1-Automake" class="headerlink" title="5.3.1 Automake"></a>5.3.1 Automake</h3><p>Automake其实是一系列工具集Autotools中的一员，要想发挥Automake的威力，需要配合使用Autotools中的其他工具，例如autoscan、aclocal、autoconf和autoheader。在下面的Automake构建流程中，能看到这些工具的身影。</p>
<ol>
<li><p><strong>autoscan</strong>：生成configure.scan</p>
</li>
<li><p><strong>configure.in</strong>：将configure.scan重命名为configure.in后，修改内容。重点是AM_INIT_AUTOMAKE和AC_CONFIG_FILES两项，如果没配置的话，下一步的aclocal是无法产生aclocal.m4的</p>
</li>
<li><p><strong>aclocal</strong>：生成aclocal.m4</p>
</li>
<li><p><strong>autoconf</strong>：生成configure</p>
</li>
<li><p><strong>autoheader</strong>：生成config.h.in，使程序可移植</p>
</li>
<li><p><strong>Makefile.am</strong>：手动编写Makefile.am。bin_PROGRAMS指定最终生成可执行文件的名称，helloworld_SOURCES指定所有源文件</p>
</li>
<li><p><strong>NEWS AUTHORS README ChangeLog</strong>：手动创建</p>
</li>
<li><p><strong>automake</strong>：执行automake -a生成Makefile.in</p>
</li>
<li><p><strong>configure</strong>：执行.&#x2F;configure生成Makefile</p>
</li>
</ol>
<p># Step 1:</p>
<p>[root@vm automaketest]# autoscan</p>
<p># Step 2:</p>
<p>[root@vm automaketest]# mv configure.scan configure.in</p>
<p>[root@vm automaketest]# cat configure.in</p>
<p>#                                               -<em>- Autoconf -</em>-</p>
<p># Process this file with autoconf to produce a configure script.</p>
<p>AC_PREREQ([2.63])</p>
<p>AC_INIT(main, 1.0)</p>
<p>AM_INIT_AUTOMAKE(main, 1.0)</p>
<p>AC_CONFIG_SRCDIR([main.c])</p>
<p>AC_CONFIG_HEADERS([config.h])</p>
<p># Checks for programs.</p>
<p>AC_PROG_CC</p>
<p># Checks for libraries.</p>
<p># Checks for header files.</p>
<p># Checks for typedefs, structures, and compiler characteristics.</p>
<p># Checks for library functions.</p>
<p>AC_CONFIG_FILES([Makefile])</p>
<p>AC_OUTPUT</p>
<p># Step 3:</p>
<p>[root@vm automaketest]# aclocal</p>
<p># Step 4:</p>
<p>[root@vm automaketest]# autoconf</p>
<p># Step 5:</p>
<p>[root@vm automaketest]# autoheader</p>
<p># Step 6:</p>
<p>[root@vm automaketest]# cat Makefile.am </p>
<p>bin_PROGRAMS&#x3D;main</p>
<p>main_SOURCES&#x3D;main.c hello.c</p>
<p># Step 7:</p>
<p>[root@vm automaketest]# touch NEWS README AUTHORS ChangeLog</p>
<p># Step 8:</p>
<p>[root@vm automaketest]# automake -a</p>
<p>configure.in:6: installing ‘.&#x2F;install-sh’</p>
<p>configure.in:6: installing ‘.&#x2F;missing’</p>
<p>Makefile.am: installing ‘.&#x2F;INSTALL’</p>
<p>Makefile.am: installing ‘.&#x2F;COPYING’ using GNU General Public License v3 file</p>
<p>Makefile.am:     Consider adding the COPYING file to the version control system</p>
<p>Makefile.am:     for your code, to avoid questions about which license your project uses.</p>
<p>Makefile.am: installing ‘.&#x2F;depcomp’</p>
<p># Step 9:</p>
<p>[root@BC-VM-edce4ac67d304079868c0bb265337bd4 automaketest]# .&#x2F;configure </p>
<p>checking for a BSD-compatible install… &#x2F;usr&#x2F;bin&#x2F;install -c</p>
<p>checking whether build environment is sane… yes</p>
<p>checking for a thread-safe mkdir -p… &#x2F;bin&#x2F;mkdir -p</p>
<p>checking for gawk… gawk</p>
<p>checking whether make sets $(MAKE)… yes</p>
<p>checking for gcc… gcc</p>
<p>checking for C compiler default output file name… a.out</p>
<p>checking whether the C compiler works… yes</p>
<p>checking whether we are cross compiling… no</p>
<p>checking for suffix of executables… </p>
<p>checking for suffix of object files… o</p>
<p>checking whether we are using the GNU C compiler… yes</p>
<p>checking whether gcc accepts -g… yes</p>
<p>checking for gcc option to accept ISO C89… none needed</p>
<p>checking for style of include used by make… GNU</p>
<p>checking dependency style of gcc… gcc3</p>
<p>configure: creating .&#x2F;config.status</p>
<p>config.status: creating Makefile</p>
<p>config.status: creating config.h</p>
<p>config.status: executing depfiles commands**</p>
<p>这样Makefile就生成好了，看一下当前目录发现已经这么多文件了！如果想清理一下怎么办呢？其实Automake早为我们想好了，它生成的Makefile功能很多： </p>
<ul>
<li><p><strong>make</strong>：编译源代码，生成目标文件 </p>
</li>
<li><p><strong>make clean</strong>：清理之前make产生的临时文件 </p>
</li>
<li><p><strong>make install</strong>：将编译好的可执行文件安装到系统目录，一般为&#x2F;usr&#x2F;local&#x2F;bin </p>
</li>
<li><p><strong>make dist</strong>：生成软件发布包，将可执行文件及相关文件打包成”PACKAGE-VERSION.tar.gz”的tarball。其中PACKAGE和VERSION可以在configure.in中通过AM_INIT_AUTOMAKE(PACKAGE, VERSION)定义。对于我们的例子，执行后会生成main-1.0.tar.gz </p>
</li>
<li><p><strong>make distcheck</strong>：查看发布包是否正确，解压开执行configure和make来确认 </p>
</li>
<li><p><strong>make distclean</strong>：不仅将make生的文件，同时将configure生成的文件也都删除，包括Makefile</p>
</li>
</ul>
<p>[root@vm automaketest]# make dist</p>
<p>{ test ! -d “main-1.0” || { find “main-1.0” -type d ! -perm -200 -exec chmod u+w {} ‘;’ &amp;&amp; rm -fr “main-1.0”; }; }</p>
<p>test -d “main-1.0” || mkdir “main-1.0”</p>
<p>test -n “” \</p>
<p>​    || find “main-1.0” -type d ! -perm -755 \</p>
<p>​        -exec chmod u+rwx,go+rx {} ; -o \</p>
<p>​      ! -type d ! -perm -444 -links 1 -exec chmod a+r {} ; -o \</p>
<p>​      ! -type d ! -perm -400 -exec chmod a+r {} ; -o \</p>
<p>​      ! -type d ! -perm -444 -exec &#x2F;bin&#x2F;sh &#x2F;root&#x2F;Temp&#x2F;automaketest&#x2F;install-sh -c -m a+r {} {} ; \</p>
<p>​    || chmod -R a+r “main-1.0”</p>
<p>tardir&#x3D;main-1.0 &amp;&amp; &#x2F;bin&#x2F;sh &#x2F;root&#x2F;Temp&#x2F;automaketest&#x2F;missing –run tar chof - “$tardir” | GZIP&#x3D;–best gzip -c &gt;main-1.0.tar.gz</p>
<p>{ test ! -d “main-1.0” || { find “main-1.0” -type d ! -perm -200 -exec chmod u+w {} ‘;’ &amp;&amp; rm -fr “main-1.0”; }; }</p>
<p>[root@vm automaketest]# tree -L 1</p>
<p>.</p>
<p>├── aclocal.m4</p>
<p>├── AUTHORS</p>
<p>├── autom4te.cache</p>
<p>├── autoscan.log</p>
<p>├── ChangeLog</p>
<p>├── config.h</p>
<p>├── config.h.in</p>
<p>├── config.log</p>
<p>├── config.status</p>
<p>├── configure</p>
<p>├── configure.in</p>
<p>├── COPYING -&gt; &#x2F;usr&#x2F;share&#x2F;automake-1.11&#x2F;COPYING</p>
<p>├── depcomp -&gt; &#x2F;usr&#x2F;share&#x2F;automake-1.11&#x2F;depcomp</p>
<p>├── hello.c</p>
<p>├── hello.h</p>
<p>├── INSTALL -&gt; &#x2F;usr&#x2F;share&#x2F;automake-1.11&#x2F;INSTALL</p>
<p>├── install-sh -&gt; &#x2F;usr&#x2F;share&#x2F;automake-1.11&#x2F;install-sh</p>
<p>├── main.c</p>
<p>├── main-1.0.tar.gz</p>
<p>├── Makefile</p>
<p>├── Makefile.am</p>
<p>├── Makefile.in</p>
<p>├── missing -&gt; &#x2F;usr&#x2F;share&#x2F;automake-1.11&#x2F;missing</p>
<p>├── NEWS</p>
<p>├── README</p>
<p>└── stamp-h1</p>
<p>1 directory, 24 files</p>
<p>[root@vm automaketest]# make distclean</p>
<p>test -z “main” || rm -f main</p>
<p>rm -f *.o</p>
<p>rm -f *.tab.c</p>
<p>test -z “” || rm -f </p>
<p>test . &#x3D; “.” || test -z “” || rm -f </p>
<p>rm -f config.h stamp-h1</p>
<p>rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags</p>
<p>rm -f config.status config.cache config.log configure.lineno config.status.lineno</p>
<p>rm -rf .&#x2F;.deps</p>
<p>rm -f Makefile</p>
<p>测试一下，看看Automake生成的Makefile是否能正常工作。</p>
<p>[root@vm automaketest]# make</p>
<p>make  all-am</p>
<p>make[1]: Entering directory ‘&#x2F;root&#x2F;Temp&#x2F;automaketest’</p>
<p>gcc -DHAVE_CONFIG_H -I.     -g -O2 -MT main.o -MD -MP -MF .deps&#x2F;main.Tpo -c -o main.o main.c</p>
<p>mv -f .deps&#x2F;main.Tpo .deps&#x2F;main.Po</p>
<p>gcc -DHAVE_CONFIG_H -I.     -g -O2 -MT hello.o -MD -MP -MF .deps&#x2F;hello.Tpo -c -o hello.o hello.c</p>
<p>mv -f .deps&#x2F;hello.Tpo .deps&#x2F;hello.Po</p>
<p>gcc  -g -O2   -o main main.o hello.o  </p>
<p>make[1]: Leaving directory ‘&#x2F;root&#x2F;Temp&#x2F;automaketest’</p>
<p>[root@vm automaketest]# .&#x2F;main </p>
<p>Hello, Make!</p>
<h3 id="5-3-2-CMake"><a href="#5-3-2-CMake" class="headerlink" title="5.3.2 CMake"></a>5.3.2 CMake</h3><p>前面我们已经见识了Automake的强大和复杂。现在我们重新用CMake生成Makefile，<strong>Automake中的9步被压缩到了只需要2步</strong>！</p>
<ol>
<li><p>编写CMakeLists.txt</p>
</li>
<li><p>执行cmake .</p>
</li>
</ol>
<h4 id="5-3-2-1-CMakeLists-txt"><a href="#5-3-2-1-CMakeLists-txt" class="headerlink" title="5.3.2.1 CMakeLists.txt"></a>5.3.2.1 CMakeLists.txt</h4><p>对于我们示例中这种简单的项目，CMakeLists.txt简单得不能再简单了。指定好项目名称和最终生成的可执行文件名称后，就完成了！</p>
<p># CMake 最低版本号要求</p>
<p>cmake_minimum_required (VERSION 2.8)</p>
<p># 项目信息</p>
<p>project (main)</p>
<p># 查找当前目录下的所有源文件</p>
<p># 并将名称保存到 DIR_SRCS 变量</p>
<p>aux_source_directory(. DIR_SRCS)</p>
<p># 指定生成目标</p>
<p>add_executable(main ${DIR_SRCS})</p>
<h4 id="5-3-2-2-cmakes"><a href="#5-3-2-2-cmakes" class="headerlink" title="5.3.2.2 cmakes"></a>5.3.2.2 cmakes</h4><p>现在执行cmake .就能得到一个CMake为我们自动生成的Makefile。这个Makefile比我们手写的要复杂得多，这里就不深入分析了。除了Makefile外，CMake还产生了一些缓存文件和临时文件，目前还不清楚具体是做什么的。</p>
<p>[root@vm cmaketest]# cmake .</p>
<p>– The C compiler identification is GNU 4.4.7</p>
<p>– The CXX compiler identification is GNU 4.4.7</p>
<p>– Check for working C compiler: &#x2F;usr&#x2F;bin&#x2F;cc</p>
<p>– Check for working C compiler: &#x2F;usr&#x2F;bin&#x2F;cc – works</p>
<p>– Detecting C compiler ABI info</p>
<p>– Detecting C compiler ABI info - done</p>
<p>– Check for working CXX compiler: &#x2F;usr&#x2F;bin&#x2F;c++</p>
<p>– Check for working CXX compiler: &#x2F;usr&#x2F;bin&#x2F;c++ – works</p>
<p>– Detecting CXX compiler ABI info</p>
<p>– Detecting CXX compiler ABI info - done</p>
<p>– Configuring done</p>
<p>– Generating done</p>
<p>– Build files have been written to: &#x2F;root&#x2F;Temp&#x2F;cmaketest</p>
<p>[root@vm cmaketest]# tree -L 1</p>
<p>.</p>
<p>├── CMakeCache.txt</p>
<p>├── CMakeFiles</p>
<p>├── cmake_install.cmake</p>
<p>├── CMakeLists.txt</p>
<p>├── hello.c</p>
<p>├── hello.h</p>
<p>├── main.c</p>
<p>└── Makefile</p>
<p>1 directory, 7 files</p>
<p>[root@vm cmaketest]# make</p>
<p>Scanning dependencies of target main</p>
<p>[ 50%] Building C object CMakeFiles&#x2F;main.dir&#x2F;main.c.o</p>
<p>[100%] Building C object CMakeFiles&#x2F;main.dir&#x2F;hello.c.o</p>
<p>Linking C executable main</p>
<p>[100%] Built target main**</p>
<h3 id="5-3-3-附：参考资料"><a href="#5-3-3-附：参考资料" class="headerlink" title="5.3.3 附：参考资料"></a>5.3.3 附：参考资料</h3><ol>
<li><p><a href="#SEC_Contents">make官方手册</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/machine/archive/2012/11/21/2781508.html">make学习记录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://hahack.com/codes/cmake/">CMake入门实战</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/flatfoosie/archive/2010/12/21/1912946.html">使用autotools生成makefile文件入门</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/guomei/article/details/7315510">automake&#x2F;autoconf入门</a></p>
</li>
</ol>
<h3 id="5-3-4-CMake快速使用教程"><a href="#5-3-4-CMake快速使用教程" class="headerlink" title="5.3.4 CMake快速使用教程"></a>5.3.4 CMake快速使用教程</h3><h4 id="5-3-4-1-实例HelloWorld"><a href="#5-3-4-1-实例HelloWorld" class="headerlink" title="5.3.4.1 实例HelloWorld"></a>5.3.4.1 实例HelloWorld</h4><p>首先创建一个test1文件夹，里面创建一个main.c文件，内容如下：</p>
<p>#include &lt;stdio.h&gt;<br>int main()</p>
<p>{ printf(“Hello World!\n”);<br> return 0;}</p>
<p>再创建一个CMakeLists.txt</p>
<p>PROJECT (HELLO)<br>SET(SRC_LIST main.c)<br>ADD_EXECUTABLE(hello ${SRC_LIST})</p>
<p>第一行：设置项目名称；</p>
<p>第二行：将SRC_LIST值设置为main.c</p>
<p>第三行：生成可执行文件 hello。 ${} 是引用某个值。</p>
<p>Terminal中cd进入到test1目录，创建一个build目录用于外部构建（编译所产生的文件都生成在build目录），依次执行下面三条命令：</p>
<p>cmake ..<br>make<br>.&#x2F;hello</p>
<p>得到的结果如下：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps60.jpg" alt="img"> </p>
<p>如果要引用内部库的话，比如是关于SDL和opengl的程序，需要在CMakeLists.txt中添加</p>
<p>TARGET_LINK_LIBRARIES(hello SDL)</p>
<p>TARGET_LINK_LIBRARIES(hello GLU)</p>
<p>对应终端的编译命令就是：</p>
<p>-lSDL -lGLU</p>
<p>若不是引用内部库，则需要将相应目录添加进来，用到的是INCLUDE_DIRECTORIES命令。</p>
<h5 id="5-3-4-1-1-库的构建与安装"><a href="#5-3-4-1-1-库的构建与安装" class="headerlink" title="5.3.4.1.1 库的构建与安装"></a>5.3.4.1.1 库的构建与安装</h5><p>这次我们的目标是：</p>
<p>1,建立一个静态库和动态库,提供 HelloFunc 函数供其他程序编程使用,HelloFunc 向终端输出</p>
<p>Hello World 字符串。</p>
<p>2,安装头文件与共享库。</p>
<p>目录安排如下：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps61.jpg" alt="img"> </p>
<p>build-用于外部编译；</p>
<p>libhello-hello库的源文件；</p>
<p>src-主程序</p>
<p>首先看libhello里的文件：</p>
<p>&#x2F;<em>filename:hello.h</em>&#x2F;<br>#ifndef DBZHANG_HELLO_<br>#define DBZHANG_HELLO_<br>void hello(const char* name);<br>#endif &#x2F;&#x2F;DBZHANG_HELLO_</p>
<p>&#x2F;<em>filename:hello.c</em>&#x2F;<br>#include &lt;stdio.h&gt;<br>#include “hello.h”</p>
<p>void hello(const char * name)<br>{<br>​    printf (“Hello %s!\n”, name);<br>}</p>
<p>CMakeLists.txt</p>
<p>cmake_minimum_required(VERSION 2.8)<br>set(LIB_SRC hello.c)<br>add_library(libhello STATIC ${LIB_SRC})<br>set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}&#x2F;lib)<br>set_target_properties(libhello PROPERTIES OUTPUT_NAME “hello”)<br>install(TARGETS libhello<br>LIBRARY DESTINATION lib<br>ARCHIVE DESTINATION lib)<br>install(FILES hello.h DESTINATION include&#x2F;hello)</p>
<p>src文件夹</p>
<p>&#x2F;<em>filename:main.c</em>&#x2F;<br>#include “hello.h”<br>int main()<br>{<br>​    hello(“Jack”);<br>​    return 0;<br>}</p>
<p>CMakeLists.txt</p>
<p>cmake_minimum_required(VERSION 2.8)<br>include_directories(${PROJECT_SOURCE_DIR}&#x2F;libhello)<br>set(APP_SRC main.c)<br>set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}&#x2F;bin)<br>add_executable(main ${APP_SRC})<br>target_link_libraries(main libhello)</p>
<p>最外面的CMakeLists.txt</p>
<p>project(HELLO)<br>add_subdirectory(src)<br>add_subdirectory(libhello)</p>
<p>解释：</p>
<p>除build目录外每一个目录都要建立一个CMakeLists.txt.</p>
<p>生成库的语句：add_library(libhello STATIC ${LIB_SRC})</p>
<p>这条语句是建立静态库，若要建立动态库的话将STATIC改成SHARED.</p>
<p>install命令负责库的安装。</p>
<p>make一下，结果就像这样：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps62.jpg" alt="img"> </p>
<p>再sudo make install.</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps63.jpg" alt="img"> </p>
<p>安装好库之后，我们在想使用hello方法的时候，只要添加头文件#include就可以了，编译的时候</p>
<p>g++ main .c -o main –lhello</p>
<h3 id="5-3-5-Automake快速上手"><a href="#5-3-5-Automake快速上手" class="headerlink" title="5.3.5 Automake快速上手"></a>5.3.5 Automake快速上手</h3><p>GNU make允许将一个软件项目的代码分开放在不同的源文件里，有改动的时候可以只对改动的文件重新编译，然后重新连接，这种编译管理方法提高了生成目标的效率。make要调用一个makefile文件来实现。 </p>
<p>Makefile的编写是使用make的关键问题。当工程里面包含的很多源文件，库，文件放在不同的子目录时，手动书写makefile文件不方便且容易出错。一般情况下我们用autoconf和automake自动生成makefile文件。</p>
<h4 id="5-3-5-1-自动生成makefile流程"><a href="#5-3-5-1-自动生成makefile流程" class="headerlink" title="5.3.5.1 自动生成makefile流程"></a>5.3.5.1 自动生成makefile流程</h4><p>如图所示为automake,autoconf生成makefile的过程（简化）。 </p>
<p>​                               程序源码<br>​                                           |<br>​                                     autoscan*<br>​                                           |<br>​                                configure.scan<br>​                                           |<br>​                                    编译修改*<br>​                                            |<br>​             makefile.am   configure.in –aclocal*–&gt; aclocal.m4<br>​                           \  ____  &#x2F;           \  __________  &#x2F;<br>​                                 \ &#x2F;                           \ &#x2F;<br>​                         automake*             autoconf*<br>​                               |                              |<br>​                            makefile.in       configure<br>​                                          \  ____  &#x2F; </p>
<p>​                                               \  &#x2F;<br>​                                        .&#x2F;configure*<br>​                                                |<br>​                                          makefile </p>
<p>为一个项目源文件生成makefile并make的步骤如下： </p>
<p>操作在包含源文件的项目目录下进行。 </p>
<ol>
<li><p>运行autoscan，生成文件configure.scan。 </p>
</li>
<li><p>修改configure.scan，改名为configure.in。 </p>
</li>
<li><p>运行autoheader，生成文件configure.h.in（现在一般改为configure.ac）。configure.in里有宏AC_CONFIG_HEADER()时用。 </p>
</li>
<li><p>运行libtoolize，生成一些支持文件，ltmain.sh。需要用libtool生成共享库用。 </p>
</li>
<li><p>运行allocal，生成aclocal.m4。 </p>
</li>
<li><p>运行autoconf，生成configure。 </p>
</li>
<li><p>为源文件编写makefie.am，每一个包含源文件的目录和子目录都有一个makefile.am。 </p>
</li>
<li><p>运行automake，生成makefile.in，每个包含makefile.am的子目录都生成makefile.in。</p>
</li>
</ol>
<p>automake -a选项可以补齐文件config.guess，config.sub，install-sh，missing，depcomp。 </p>
<ol start="9">
<li><p>运行.&#x2F;configure，生成config.status，config.h，makefile。 </p>
</li>
<li><p>运行make，生成中间文件对象文件，库文件，最后生成可执行文件。 </p>
</li>
<li><p>运行make install，相应的可执行文件，库文件，头文件拷贝到系统相应位置。</p>
</li>
</ol>
<h4 id="5-3-5-2-自动生成makefile例子"><a href="#5-3-5-2-自动生成makefile例子" class="headerlink" title="5.3.5.2 自动生成makefile例子"></a>5.3.5.2 自动生成makefile例子</h4><p>这个例子共有三个C文件，main.c，add&#x2F;add.c和sub&#x2F;sub.c。源代码如下： </p>
<p>&#x2F;<em>main.c</em>&#x2F;<br>#include<br>int main(void)<br>{<br>printf(“%d\n”,add(sub(100,5),1));<br>return 0;<br>} </p>
<p>&#x2F;* add&#x2F;add.c *&#x2F;<br>int add(int x,int y)<br>{<br>return x+y;<br>} </p>
<p>&#x2F;* sub&#x2F;sub.c *&#x2F;<br>int sub(int x,int y)<br>{<br>return x-y;<br>} </p>
<p>这个例子中add.c和sub.c被编译成动态连接库，然后main.c与这两个库连接生成可执行文件。 </p>
<p><strong>1.手动输入configure.in和makefile.am</strong> </p>
<p>Q：自动生成makefile需要手动输入什么文件，作用是什么？ </p>
<p>按照上面的步骤执行，需要手动输入的文件只有两类configure.in和makefile.am。 </p>
<p><strong>(1).手动修改configure.in</strong> </p>
<p>autoscan运行后configure.scan文件为（系统不一样可能略有会不同） </p>
<p># -<em>- Autoconf -</em>-<br># Process this file with autoconf to produce a configure script. </p>
<p>AC_PREREQ([2.63])<br>AC_INIT([FULL-PACKAGE-NAME],[VERSION],[BUG-REPORT-ADDRESS])<br>AC_CONFIG_SRCDIR([main.c])<br>AC_CONFIG_HEADERS([config.h]) </p>
<p># Checks for programs.<br>AC_PROG_CC </p>
<p># Checks for header files. </p>
<p># Checks for typedefs, structures, and compiler characteristics. </p>
<p># Checks for library functions. </p>
<p>AC_OUTPUT </p>
<p>手动修改为configure.in： </p>
<p># -<em>- Autoconf -</em>-<br># Process this file with autoconf to produce a configure script. </p>
<p>AC_PREREQ([2.63])<br>AC_INIT(hellobb,1.0,[])<br>AM_INIT_AUTOMAKE(hellobb,1.0) </p>
<p>AC_CONFIG_SRCDIR([main.c])<br>AC_CONFIG_HEADERS([config.h]) </p>
<p># Checks for programs.<br>AC_PROG_CC<br>AC_PROG_LIBTOOL </p>
<p># Checks for header files. </p>
<p># Checks for typedefs, structures, and compiler characteristics. </p>
<p># Checks for library functions. </p>
<p>AC_OUTPUT(Makefile add&#x2F;Makefile sub&#x2F;Makefile)</p>
<p>其中宏AC_INIT和AC_OUTPUT是必需的，AC_INIT放在开头，AC_OUTPUT放在结尾。 </p>
<p>AC_INIT：说明软件包的名字，版本等。 </p>
<p>AC_OUTPUT：说明生成的shell脚本文件configure运行后输出的文件。 </p>
<p>AM_INIT_AUTOMAKE：用automake需要的宏。 </p>
<p>AC_PROG_CC：决定要使用的C编译器。如果环境变量CC没有值，检查gcc和cc，别的C编译器。设置变量CC的值为找到的编译器名称。 </p>
<p>AC_PROG_LIBTOOL：检查LIBTOOL。 </p>
<p>AC_CONFIG_SRCDIR([main.c])：.&#x2F;configure检查在给它的目录里是否有main.c文件。 </p>
<p>AC_CONFIG_HEADER([config.h])：.&#x2F;configure从config.h.in中生成config.h文件，config.h文件是包含了很多#define宏的c头文件。当编译文件的时候，用一个宏-DHAVE_CONFIG_H代替原来需要用-Dmacro传递的所有预处理宏集合。 </p>
<p>例如屏蔽掉这句#AC_CONFIG_HEADER([config.h])，make时编译main.c的命令是 </p>
<p>gcc -DPACKAGE_NAME&#x3D;&quot;hellobb&quot; -DPACKAGE_TARNAME&#x3D;&quot;hellobb&quot; -DPACKAGE-VERSION&#x3D;&quot;1.0&quot; -DPACKAGE_STRING&#x3D;&quot;hellobb\ 1.0&quot; -DPACKAGE_BUGREPORT&#x3D;&quot;&quot; -DPACKAGE&#x3D;&quot;hellobb&quot; -DVERSION&#x3D;&quot;1.0&quot; -DSTDC_HEADERS&#x3D;1 _DHAVE_SYS_TYPES_H&#x3D;1 -DHAVE_UNISTDLIB_H&#x3D;1 -DHAVE_STING_H&#x3D;1 -DHAVE_MEMORY_H&#x3D;1 -dHAVE_STRINGS_H&#x3D;1 -DHAVE_INTTYPES_H&#x3D;1 -DHAVE_STDINT_H&#x3D;1 -DHAVE_UNISTD_H&#x3D;1 -DHAVE_DLFCN_H&#x3D;1 -DLT_OBJDIR&#x3D;&quot;.&#x2F;libs&#x2F;&quot; -I. -g -O2 -MT main.o -MD -MP -MF .deps&#x2F;main.Tpo -c -o main.c main.c </p>
<p>如果启用AC_CONFIG_HEADER([config.h])，make时编译main.c的命令是 </p>
<p>gcc -DHAVE_CONFIG_H -I. -g -O2 -MT main.o -MD -MP -MF .deps&#x2F;main.Tpo -c -o main.o main.c </p>
<p>上面那些宏-Dmacro都包含在config.h里了，我们只需要给编译器传递-DHAVE_CONFIG_H就行了。 </p>
<p><strong>(2). 手动输入makefile.am</strong> </p>
<p>每个包含源文件的子目录下都需要一个makefile.am。 </p>
<p>add&#x2F;makefile.am是（sub&#x2F;makefile.am类似）： </p>
<p>lib_LTLIBRARIES &#x3D; libadd.la &#x2F;&#x2F;生成共享库libadd.la<br>libadd_la_SOURCES &#x3D; add.c &#x2F;&#x2F;共享库libadd.la依赖的源文件 </p>
<p>项目根目录下的makefile.am是： </p>
<p>AUTOMAKE_OPTIONS &#x3D; foreign<br>SUBDIRS &#x3D; add sub &#x2F;&#x2F;子目录，递归处理子目录的makefile.am<br>bin_PROGRAMS &#x3D; main &#x2F;&#x2F;生成可执行文件main<br>main_SOURCES &#x3D; main.c &#x2F;&#x2F;可执行文                  件main依赖的源文件<br>main_LDADD &#x3D; add&#x2F;libadd.la sub&#x2F;libsub.la &#x2F;&#x2F;可执行文件main连接时需要的库文件 </p>
<p><strong>(3).automake时运行automake -a：</strong> </p>
<p>automake -a即 automake -add-missing：如果目录下缺少文件config.guess,config.sub,missing,depcomp,install-sh，automake会自动从系统中获取这些文件，这里是创建这些文件，让它们是指向系统中对应文件的连接文件。 </p>
<p><strong>2.过程中的输入输出文件</strong> </p>
<p>Q：.&#x2F;configure需要什么输入文件，生成什么文件？ </p>
<p>Q：make需要什么输入文件，中间生成的文件放哪？ </p>
<p>为了更清楚整个处理过程autoscan,autoheader,automake,autoconf做了什么事情，观察每一步执行过程中需要的输入文件和产生的输出文件。 </p>
<p>输入源文件：main.c add&#x2F;add.c sub&#x2F;sub.c </p>
<p>输入makefile.am ：makefile.am add&#x2F;makefile.am sub&#x2F;makefile.am </p>
<p>autoscan ：configure.scan </p>
<p>autoscan.log </p>
<p>手动修改：(入：configure.scan) </p>
<p>configure.in &#x2F;&#x2F;指出生成的包名字和版本号，.&#x2F;configure输出文件，配置预处理头文件，<br>指出需要检查的程序、头文件、类型和结构、库函数等。 </p>
<p>autoheader ：config.h.in </p>
<p>libtoolize ：ltmain.sh </p>
<p>aclocal ：aclocal.m4 &#x2F;&#x2F;autoconf相关的宏，在本地m4中定义好的。 </p>
<p>autom4te.cache </p>
<p>autoconf ： (入：configure.in, aclocal.m4) </p>
<p>configure </p>
<p>automake -a ：(入：configure.in makefile.am add&#x2F;makefile.am sub&#x2F;makefile.am) </p>
<p>config.guess &#x2F;&#x2F;猜测出一个规范的系统名字。 </p>
<p>config.sub &#x2F;&#x2F;把平台和系统别名映射成规范形式：<br>CPU_TYPE_MANUFACTORER-KERNEL-OPERATING-SYSTEM。 </p>
<p>install-sh &#x2F;&#x2F;安装程序，脚本或数据文件。 </p>
<p>missing &#x2F;&#x2F; Common stub for a few missing GNU program while installing. </p>
<p>depcomp &#x2F;&#x2F;Compile a program generating depedencies as side-effects. </p>
<p>makefile.in add&#x2F;makefile.in sub&#x2F;makefile.in </p>
<p>.&#x2F;configure ：(入：configure makefile.in add&#x2F;makefile.in sub&#x2F;makefile.in config.h.in ) </p>
<p>(入：config.guess config.sub install-sh missing depcomp ltmainsh) </p>
<p>config.status &#x2F;&#x2F;configure运行时找到的系统相关变量都存放在这里，<br>.&#x2F;configure的最后就是运行shell脚本config.status </p>
<p>config.h &#x2F;&#x2F;包含编译时要传给编译器的所有预处理宏 </p>
<p>config.log &#x2F;&#x2F;包含了.&#x2F;configure运行时生成的所有信息，供调试时查看 </p>
<p>makefile add&#x2F;makefile sub&#x2F;makefile </p>
<p>.&#x2F;deps&#x2F;main.Po add&#x2F;.deps&#x2F;add.Plo sub&#x2F;.deps.sub.Plo &#x2F;&#x2F;空的dummy依赖文件 </p>
<p>stamp-h1 </p>
<p>make ：(入：config.status config.h makefile add&#x2F;makefile sub&#x2F;makefile) </p>
<p>libtool </p>
<p>add.lo add.o libadd.la </p>
<p>add&#x2F;.libs下add.o libadd.a libadd.la libsub.lai libadd.so libadd.so.0 libadd.so.0.0.0 </p>
<p>sub.lo sub.o libsub.la </p>
<p>sub&#x2F;.libs下sub.o libsub.a libsub.la libsub.lai libsub.so libsub.so.0 libsub.so.0.0.0 </p>
<p>.&#x2F;deps&#x2F;main.Po add&#x2F;.deps&#x2F;add.Plo sub&#x2F;.deps.sub.Plo &#x2F;&#x2F;更新依赖文件，由于gcc有-MT,-MD,-MP,-MF选项 </p>
<p>main.o </p>
<p>main </p>
<p><strong>3.configure和make执行过程</strong> </p>
<p>Q：.&#x2F;configure都作了些什么事情，输入的文件都用来做什么，config.status的作用？ </p>
<p>Q：make的运行过程，生成的文件放在哪里有谁来指定？ </p>
<p><strong>configure运行</strong> </p>
<p>configure是一个shell脚本文件，由autoconf生成，它自动为源码包配置编译连接选项，适应不同的硬件平台和POSIX操作系统，输出所需要的Makefile。 </p>
<p>上面的例子中.&#x2F;configure运行期间输出如下图。 </p>
<p>configure.in中宏对configure的影响： </p>
<p>宏AC_INIT,AM_INIT_AUTOMAKE,AC_PROG_CC对应图中的白色部分。 </p>
<p>宏AC_PROG_LIBTOOL对应图中的灰色部分。 </p>
<p>宏AC_OUTPUT在图中的桃红色部分。 </p>
<p>桃红色部分为最后configure生成config.status文件，并执行它。configure主管检查你的系统，把结果存放到config.status中，config.status根据它的检查结果实际执行正确的动作。 </p>
<p>configure检查与系统相关的一系列变量，这些变量存储到文件config.status中，供makefile调用。这些变量包括编译连接时需要的程序，这些程序在系统中的位置（目录），调用这些程序的选项，比如编译器的目录，编译器的选项-g是否支持等。 </p>
<p>configure能猜出它运行的系统的规范名字cpu-vendor-os，它通过运行脚本文件config.guess输出变量uname来猜出。 </p>
<p>configure能识别很多系统名字的别名，它通过运行脚本文件config.sub把系统名字变成规范名字。 </p>
<p># .&#x2F;configure<br>checking for a BSD-compatible install… &#x2F;usr&#x2F;bin&#x2F;install -c<br>checking whether build environment is sane… yes<br>checking for a thread-safe mkdir -p… &#x2F;bin&#x2F;mkdir -p<br>checking for gawk… gawk<br>checking whether make sets $(MAKE)… yes<br>checking for gcc… gcc<br>checking for C compiler default output file name… a.out<br>checking whether the C compiler works… yes<br>checking whether we are cross compiling… no<br>checking for suffix of executables…<br>checking for suffix of object files… o<br>checking whether we are using the GNU C compiler… yes<br>checking whether gcc accepts -g… yes<br>checking for gcc option to accept ISO C89… none needed<br>checking for style of include used by make… GNU<br>checking dependency style of gcc… gcc3<br>checking build system type… i686-pc-linux-gnu<br>checking host system type… i686-pc-linux-gnu<br>checking how to print strings… printf<br>checking for a sed that does not truncate output… &#x2F;bin&#x2F;sed<br>checking for grep that handles long lines and -e… &#x2F;bin&#x2F;grep<br>checking for egrep… &#x2F;bin&#x2F;grep -E<br>checking for fgrep… &#x2F;bin&#x2F;grep -F<br>checking for ld used by gcc… &#x2F;usr&#x2F;bin&#x2F;ld<br>checking if the linker (&#x2F;usr&#x2F;bin&#x2F;ld) is GNU ld… yes<br>checking for BSD- or MS-compatible name lister (nm)… &#x2F;usr&#x2F;bin&#x2F;nm -B<br>checking the name lister (&#x2F;usr&#x2F;bin&#x2F;nm -B) interface… BSD nm<br>checking whether ln -s works… yes<br>checking the maximum length of command line arguments… 1966080<br>checking whether the shell understands some XSI constructs… yes<br>checking whether the shell understands “+&#x3D;”… yes<br>checking for &#x2F;usr&#x2F;bin&#x2F;ld option to reload object files… -r<br>checking for objdump… objdump<br>checking how to recognize dependent libraries… pass_all<br>checking for ar… ar<br>checking for strip… strip<br>checking for ranlib… ranlib<br>checking command to parse &#x2F;usr&#x2F;bin&#x2F;nm -B output from gcc object… ok<br>checking how to run the C preprocessor… gcc -E<br>checking for ANSI C header files… yes<br>checking for sys&#x2F;types.h… yes<br>checking for sys&#x2F;stat.h… yes<br>checking for stdlib.h… yes<br>checking for string.h… yes<br>checking for memory.h… yes<br>checking for strings.h… yes<br>checking for inttypes.h… yes<br>checking for stdint.h… yes<br>checking for unistd.h… yes<br>checking for dlfcn.h… yes<br>checking for objdir… .libs<br>checking if gcc supports -fno-rtti -fno-exceptions… no<br>checking for gcc option to produce PIC… -fPIC -DPIC<br>checking if gcc PIC flag -fPIC -DPIC works… yes<br>checking if gcc static flag -static works… no<br>checking if gcc supports -c -o file.o… yes<br>checking if gcc supports -c -o file.o… (cached) yes<br>checking whether the gcc linker (&#x2F;usr&#x2F;bin&#x2F;ld) supports shared libraries… yes<br>checking whether -lc should be explicitly linked in… no<br>checking dynamic linker characteristics… GNU&#x2F;Linux ld.so<br>checking how to hardcode library paths into programs… immediate<br>checking whether stripping libraries is possible… yes<br>checking if libtool supports shared libraries… yes<br>checking whether to build shared libraries… yes<br>checking whether to build static libraries… yes<br>configure: creating .&#x2F;config.status<br>config.status: creating Makefile<br>config.status: creating add&#x2F;Makefile<br>config.status: creating sub&#x2F;Makefile<br>config.status: creating config.h<br>config.status: executing depfiles commands<br>config.status: executing libtool commands</p>
<p><strong>make运行</strong> </p>
<p>make运行期间输出如下图。 </p>
<p>makefile.am对makefile的影响： </p>
<p>它根据SUBDIRS &#x3D; add sub让make递归进入每个子目录处理子目录的Makefile。 </p>
<p>根据main_LDADD &#x3D; add&#x2F;libadd.la sub&#x2F;libsub.la为main连接libadd.la和libsub.la库。 </p>
<p>configure.in对makefile的影响： </p>
<p>根据AC_PROG_LIBTOOL让libtool完成编译连接工作。 </p>
<p>根据AC_CONFIG_HEADERS([config.h])只需传递预处理宏-DHAVE_CONFIG_H给编译器。 </p>
<p>makefile中很多与系统相关的信息都是通过变量获取的，这些变量之前已经由configure检查好存放在config.status里面，预处理宏存放在config.h里面。比如我们要用到的编译器CC，编译器选项CFLAGS等。makefile中的变量完成替换后，开始实际执行命令，它会递归执行每一个子目录下的makefile，生成对象文件，连接库文件，最后连接成可执行文件。 </p>
<p># make<br>make all-recursive<br>make[1]: Entering directory <code>/root/program/hello_autoconf2&#39; Making all in add make[2]: Entering directory </code>&#x2F;root&#x2F;program&#x2F;hello_autoconf2&#x2F;add’<br>&#x2F;bin&#x2F;sh ..&#x2F;libtool –tag&#x3D;CC –mode&#x3D;compile gcc -DHAVE_CONFIG_H -I. -I.. -g -O2 -MT add.lo -MD -MP -MF .deps&#x2F;add.Tpo -c -o add.lo add.c<br>libtool: compile: gcc -DHAVE_CONFIG_H -I. -I.. -g -O2 -MT add.lo -MD -MP -MF .deps&#x2F;add.Tpo -c add.c -fPIC -DPIC -o .libs&#x2F;add.o<br>libtool: compile: gcc -DHAVE_CONFIG_H -I. -I.. -g -O2 -MT add.lo -MD -MP -MF .deps&#x2F;add.Tpo -c add.c -o add.o &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br>mv -f .deps&#x2F;add.Tpo .deps&#x2F;add.Plo<br>&#x2F;bin&#x2F;sh ..&#x2F;libtool –tag&#x3D;CC –mode&#x3D;link gcc -g -O2 -o libadd.la -rpath &#x2F;usr&#x2F;local&#x2F;lib add.lo<br>libtool: link: gcc -shared .libs&#x2F;add.o -Wl,-soname -Wl,libadd.so.0 -o .libs&#x2F;libadd.so.0.0.0<br>libtool: link: (cd “.libs” &amp;&amp; rm -f “libadd.so.0” &amp;&amp; ln -s “libadd.so.0.0.0” “libadd.so.0”)<br>libtool: link: (cd “.libs” &amp;&amp; rm -f “libadd.so” &amp;&amp; ln -s “libadd.so.0.0.0” “libadd.so”)<br>libtool: link: ar cru .libs&#x2F;libadd.a add.o<br>libtool: link: ranlib .libs&#x2F;libadd.a<br>libtool: link: ( cd “.libs” &amp;&amp; rm -f “libadd.la” &amp;&amp; ln -s “..&#x2F;libadd.la” “libadd.la” )<br>make[2]: Leaving directory <code>/root/program/hello_autoconf2/add&#39; Making all in sub make[2]: Entering directory </code>&#x2F;root&#x2F;program&#x2F;hello_autoconf2&#x2F;sub’<br>&#x2F;bin&#x2F;sh ..&#x2F;libtool –tag&#x3D;CC –mode&#x3D;compile gcc -DHAVE_CONFIG_H -I. -I.. -g -O2 -MT sub.lo -MD -MP -MF .deps&#x2F;sub.Tpo -c -o sub.lo sub.c<br>libtool: compile: gcc -DHAVE_CONFIG_H -I. -I.. -g -O2 -MT sub.lo -MD -MP -MF .deps&#x2F;sub.Tpo -c sub.c -fPIC -DPIC -o .libs&#x2F;sub.o<br>libtool: compile: gcc -DHAVE_CONFIG_H -I. -I.. -g -O2 -MT sub.lo -MD -MP -MF .deps&#x2F;sub.Tpo -c sub.c -o sub.o &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br>mv -f .deps&#x2F;sub.Tpo .deps&#x2F;sub.Plo<br>&#x2F;bin&#x2F;sh ..&#x2F;libtool –tag&#x3D;CC –mode&#x3D;link gcc -g -O2 -o libsub.la -rpath &#x2F;usr&#x2F;local&#x2F;lib sub.lo<br>libtool: link: gcc -shared .libs&#x2F;sub.o -Wl,-soname -Wl,libsub.so.0 -o .libs&#x2F;libsub.so.0.0.0<br>libtool: link: (cd “.libs” &amp;&amp; rm -f “libsub.so.0” &amp;&amp; ln -s “libsub.so.0.0.0” “libsub.so.0”)<br>libtool: link: (cd “.libs” &amp;&amp; rm -f “libsub.so” &amp;&amp; ln -s “libsub.so.0.0.0” “libsub.so”)<br>libtool: link: ar cru .libs&#x2F;libsub.a sub.o<br>libtool: link: ranlib .libs&#x2F;libsub.a<br>libtool: link: ( cd “.libs” &amp;&amp; rm -f “libsub.la” &amp;&amp; ln -s “..&#x2F;libsub.la” “libsub.la” )<br>make[2]: Leaving directory <code>/root/program/hello_autoconf2/sub&#39; make[2]: Entering directory </code>&#x2F;root&#x2F;program&#x2F;hello_autoconf2’<br>gcc -DHAVE_CONFIG_H -I. -g -O2 -MT main.o -MD -MP -MF .deps&#x2F;main.Tpo -c -o main.o main.c<br>mv -f .deps&#x2F;main.Tpo .deps&#x2F;main.Po<br>&#x2F;bin&#x2F;sh .&#x2F;libtool –tag&#x3D;CC –mode&#x3D;link gcc -g -O2 -o main main.o add&#x2F;libadd.la sub&#x2F;libsub.la<br>libtool: link: gcc -g -O2 -o .libs&#x2F;main main.o add&#x2F;.libs&#x2F;libadd.so sub&#x2F;.libs&#x2F;libsub.so -Wl,-rpath -Wl,&#x2F;usr&#x2F;local&#x2F;lib<br>make[2]: Leaving directory <code>/root/program/hello_autoconf2&#39; make[1]: Leaving directory </code>&#x2F;root&#x2F;program&#x2F;hello_autoconf2’ </p>
<p>Q: 编译main.c的命令：gcc -DHAVE_CONFIG_H -I. -g -O2 -MT main.o -MD -MP -MF .deps&#x2F;main.Tpo -c -o main.o main.c 中，选项-MT,-MD,-MP,-MF什么意思？ </p>
<p>选项-MT,-MD,-MP,-MF是跟依赖关系文件相关的，相当于往文件里加makefile格式的rule,简化形式：<br>targets : dependency。<br>-MF .deps&#x2F;main.Tpo 指定把依赖关系的rule写到文件.deps&#x2F;main.Tpo 里，跟-MD一起用，如果跟-M一起用将在预处理后结束不编译。<br>-MT 指定target。<br>-MP 在依赖关系文件中加入每个依赖文件的phony target。如<br>test.o:test.c test.h<br>test.h: #phony target </p>
<p>这里生成的依赖文件main.Po，add.Plo如图。 </p>
<p>main.Po: </p>
<p>main.o: main.c &#x2F;usr&#x2F;include&#x2F;stdio.h &#x2F;usr&#x2F;include&#x2F;features.h <br>&#x2F;usr&#x2F;include&#x2F;sys&#x2F;cdefs.h &#x2F;usr&#x2F;include&#x2F;bits&#x2F;wordsize.h <br>&#x2F;usr&#x2F;include&#x2F;gnu&#x2F;stubs.h &#x2F;usr&#x2F;include&#x2F;gnu&#x2F;stubs-32.h <br>&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;i686-redhat-linux&#x2F;4.5.1&#x2F;include&#x2F;stddef.h <br>&#x2F;usr&#x2F;include&#x2F;bits&#x2F;types.h &#x2F;usr&#x2F;include&#x2F;bits&#x2F;typesizes.h <br>&#x2F;usr&#x2F;include&#x2F;libio.h &#x2F;usr&#x2F;include&#x2F;_G_config.h &#x2F;usr&#x2F;include&#x2F;wchar.h <br>&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;i686-redhat-linux&#x2F;4.5.1&#x2F;include&#x2F;stdarg.h <br>&#x2F;usr&#x2F;include&#x2F;bits&#x2F;stdio_lim.h &#x2F;usr&#x2F;include&#x2F;bits&#x2F;sys_errlist.h <br>&#x2F;usr&#x2F;include&#x2F;bits&#x2F;stdio.h<br>&#x2F;usr&#x2F;include&#x2F;stdio.h:<br>&#x2F;usr&#x2F;include&#x2F;features.h:<br>&#x2F;usr&#x2F;include&#x2F;sys&#x2F;cdefs.h:<br>&#x2F;usr&#x2F;include&#x2F;bits&#x2F;wordsize.h:<br>&#x2F;usr&#x2F;include&#x2F;gnu&#x2F;stubs.h:<br>&#x2F;usr&#x2F;include&#x2F;gnu&#x2F;stubs-32.h:<br>&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;i686-redhat-linux&#x2F;4.5.1&#x2F;include&#x2F;stddef.h:<br>&#x2F;usr&#x2F;include&#x2F;bits&#x2F;types.h:<br>&#x2F;usr&#x2F;include&#x2F;bits&#x2F;typesizes.h:<br>&#x2F;usr&#x2F;include&#x2F;libio.h:<br>&#x2F;usr&#x2F;include&#x2F;_G_config.h:<br>&#x2F;usr&#x2F;include&#x2F;wchar.h:<br>&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;i686-redhat-linux&#x2F;4.5.1&#x2F;include&#x2F;stdarg.h:<br>&#x2F;usr&#x2F;include&#x2F;bits&#x2F;stdio_lim.h:<br>&#x2F;usr&#x2F;include&#x2F;bits&#x2F;sys_errlist.h:<br>&#x2F;usr&#x2F;include&#x2F;bits&#x2F;stdio.h: </p>
<p>add.Plo: </p>
<p>add.lo: add.c </p>
<p><strong>交叉编译 Cross-compiling</strong> </p>
<p>Q：为别的平台编译可执行程序怎么做？ </p>
<p>交叉编译就是在目前的平台上为别的目标平台生成可执行程序或库。可以在运行configure时通过–build，–host，–target参数实现交叉编译。默认情况下 target&lt;&#x3D;host&lt;&#x3D;build&lt;&#x3D;config.guess给出的平台名称。 </p>
<p>例如.&#x2F;configure –build&#x3D;i686-pc-linux-gnu –host&#x3D;m68k-coff。 </p>
<p>–build&#x3D;build-type ：configure和compile软件包的系统类型。默认情况等于config.guess给出的系统类型。 </p>
<p>–host&#x3D;host-type ：运行软件包的系统类型。默认情况等于build类型 </p>
<p>–target&#x3D;target-type ：很少用，默认情况等于host类型。 </p>
<p>交叉编译时，如果编译器，连接器，汇编器名字不是以host_type为前缀，configure都会发出警告。 </p>
<p>要搭建交叉变异环境，如交叉编译用的编译器，连接器，汇编器跟本地的不一样，一般以host_type为前缀，如arm-pc-linux-gcc。 </p>
<p><strong>安装目录</strong> </p>
<p>Q：make install时，文件都安装到哪里去了？ </p>
<p>prefix：安装目录的前缀。默认情况下&#x2F;usr&#x2F;local 。 </p>
<p>bindir：安装时拷贝可执行文件到此目录。默认情况下&#x2F;usr&#x2F;local&#x2F;bin 。 </p>
<p>includir：安装时拷贝头文件到此目录。默认情况下&#x2F;usr&#x2F;local&#x2F;include 。 </p>
<p>libdir：安装时拷贝库文件到此目录。默认情况下&#x2F;usr&#x2F;local&#x2F;libs 。 </p>
<p>定制自己的安装目录，可以–prefix 和 –exec-prefix 给configure。 </p>
<p>例如：.&#x2F;configure –prefix&#x3D;&#x2F;usr 。 </p>
<p><strong>GUN build system</strong> </p>
<p>autoconf </p>
<p>automake </p>
<p>libtool </p>
<p>autoheader </p>
<p>检查你的系统安装了以下软件：(whereis ,which) </p>
<p>GNU gcc<br>GNU make<br>GNU automake<br>GNU Autoconf<br>GNU m4<br>perl<br>GNU tar<br>GNU zip ( gzip )<br>GNU Libtool ( 如果你需要產生 shared library ) </p>
<p>参考： </p>
<p>automake,陳雍穆,<a target="_blank" rel="noopener" href="http://netlab.cse.yzu.edu.tw/~armor/columns/automake/automake.htm">http://netlab.cse.yzu.edu.tw/~armor/columns/automake/automake.htm</a> </p>
<p>Autoconf,<a href="#The-GNU-Build-System">http://www.gnu.org/software/autoconf/manual/autoconf.html</a> </p>
<p>GNU Automake,<a target="_blank" rel="noopener" href="http://www.gnu.org/software/automake/manual/automake.html">http://www.gnu.org/software/automake/manual/automake.html</a> </p>
<h3 id="5-3-6-Myself-tool"><a href="#5-3-6-Myself-tool" class="headerlink" title="5.3.6 Myself tool"></a>5.3.6 Myself tool</h3><p>参考上述资料整理成一个脚本自动生成。</p>
<h2 id="5-4-Makefile调试方法"><a href="#5-4-Makefile调试方法" class="headerlink" title="5.4 Makefile调试方法"></a>5.4 Makefile调试方法</h2><h3 id="5-4-1-执行选项"><a href="#5-4-1-执行选项" class="headerlink" title="5.4.1 执行选项"></a>5.4.1 执行选项</h3><ol>
<li>-n选项</li>
</ol>
<p>make –n常用于调试makefile，该选项可以实现只打印执行过程，而不具体执行。</p>
<ol start="2">
<li>-p选项</li>
</ol>
<p>–print-datebase</p>
<ol start="3">
<li><p>–warn-undefined-variables</p>
</li>
<li><p>-debug&#x3D;all</p>
</li>
</ol>
<p>-debug&#x3D;all,basic</p>
<h3 id="5-4-2-echo显示"><a href="#5-4-2-echo显示" class="headerlink" title="5.4.2 echo显示"></a>5.4.2 echo显示</h3><h2 id="5-5-附件"><a href="#5-5-附件" class="headerlink" title="5.5 附件"></a>5.5 附件</h2><p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps64.png" alt="img"></p>
<h1 id="第-6-章-Linux应用程序开发"><a href="#第-6-章-Linux应用程序开发" class="headerlink" title="第 6 章 Linux应用程序开发"></a>第 6 章 Linux应用程序开发</h1><p>Linux是多任务、支持多种文件系统、采用虚拟内存管理技术、良好的可移植性、设备独立性、丰富的网络功能、提供全部源代码。</p>
<h2 id="6-1-Linux文件编程"><a href="#6-1-Linux文件编程" class="headerlink" title="6.1 Linux文件编程"></a>6.1 <a href="">Linux文件编程</a></h2><h3 id="6-1-1-系统调用文件访问"><a href="#6-1-1-系统调用文件访问" class="headerlink" title="6.1.1 系统调用文件访问"></a>6.1.1 系统调用文件访问</h3><h4 id="6-1-1-1-创建"><a href="#6-1-1-1-创建" class="headerlink" title="6.1.1.1 创建"></a>6.1.1.1 创建</h4><p>Ø int creat(const char *filename, mode_t mode)</p>
<p>filename:要创建的文件名(包含路径，缺省为当前路径)</p>
<p>mode:创建模式</p>
<p>常见创建模式：</p>
<p>S_IRUSR     可读</p>
<p>S_IWUSR     可写</p>
<p>S_IXUSR     可执行</p>
<p>S_IRWXU     可读、写、执行</p>
<p>可执行  1</p>
<p>v可写  2</p>
<p>v可读  4</p>
<p>v上述值的和，如可写可读  6</p>
<p>*#include &lt;stdio.h&gt; ***</p>
<p>*#include &lt;stdlib.h&gt; ***</p>
<p>*#include &lt;sys&#x2F;types.h&gt; ***</p>
<p>*#include &lt;sys&#x2F;stat.h&gt; ***</p>
<p>*#include &lt;fcntl.h&gt; ***</p>
<p>*void  create_file(char *filename){ ***</p>
<p><em>&#x2F;*创建的文件具有什么样的属性？</em>&#x2F;**	***</p>
<ul>
<li><p>if(creat(filename,0755)&lt;0){ ***</p>
</li>
<li><pre><code>   printf(&quot;create file %s failure!\n&quot;,filename); ***
</code></pre>
</li>
<li><pre><code>   exit(EXIT_FAILURE); ***
</code></pre>
</li>
<li><p>}else{ ***</p>
</li>
<li><pre><code>   printf(&quot;create file %s success!\n&quot;,filename); ***
</code></pre>
</li>
<li><p>} ***</p>
</li>
</ul>
<p>*} ***</p>
<p>*int main(int argc,char *argv[]){ ***</p>
<ul>
<li><p>int i; ***</p>
</li>
<li><p>if(argc&lt;2){ ***</p>
</li>
<li><pre><code>   perror(&quot;you haven&#39;t input the filename,please try again!\n&quot;); ***
</code></pre>
</li>
<li><pre><code>   exit(EXIT_FAILURE); ***
</code></pre>
</li>
<li><p>} ***</p>
</li>
<li><p>for(i&#x3D;1;i&lt;argc;i++){ ***</p>
</li>
<li><pre><code>   create_file(argv[i]);    ***
</code></pre>
</li>
<li><p>} ***</p>
</li>
<li><p>exit(EXIT_SUCCESS); ***</p>
</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<h4 id="6-1-1-2-打开"><a href="#6-1-1-2-打开" class="headerlink" title="6.1.1.2 打开"></a>6.1.1.2 打开</h4><p>int open(const char *pathname, int flags)</p>
<p>int open(const char *pathname, int flags, mode_t mode)</p>
<p>pathname：要打开的文件名(包含路径，缺省为当前路径)</p>
<p>flags：打开标志</p>
<p>常见的打开标志：</p>
<p>O_RDONLY     只读方式打开</p>
<p>O_WRONLY    只写方式打开</p>
<p>O_RDWR      读写方式打开</p>
<p>O_APPEND     追加方式打开</p>
<p>O_CREAT      创建一个文件</p>
<p>O_NOBLOCK   非阻塞方式打开</p>
<p>如果使用了O_CREATE标志，则使用的函数是：</p>
<p>int open(const char *pathname,int flags, mode_t mode); 这时需要指定mode来表示文件的访问权限。</p>
<p><a target="_blank" rel="noopener" href="http://kalogen.iteye.com/blog/670841">socket阻塞和非阻塞的区别</a></p>
<p>阻塞就是干不完不准回来，   </p>
<p>非组赛就是你先干，我现看看有其他事没有，完了告诉我一声</p>
<h4 id="6-1-1-3-关闭"><a href="#6-1-1-3-关闭" class="headerlink" title="6.1.1.3 关闭"></a>6.1.1.3 关闭</h4><p>当我们操作完文件以后,需要关闭文件：int close(int fd)</p>
<p>fd: 文件描述符</p>
<h4 id="6-1-1-4-读"><a href="#6-1-1-4-读" class="headerlink" title="6.1.1.4 读"></a>6.1.1.4 读</h4><p>int read(int fd, const void *buf, size_t length)</p>
<p>功能：从文件描述符fd所指定的文件中读取length个字节到buf所指向的缓冲区中，返回值为实际读取的字节数。</p>
<p>注： read函数只是一个通用的读文件设备的接口。是否阻塞需要由设备的属性和设定所决定。一般来说，读字符终端、网络的socket描述字，管道文件等，这些文件的缺省read都是阻塞的方式。如果是读磁盘上的文件，一般不会是阻塞方式的。但使用锁和fcntl设置取消文件O_NOBLOCK状态，也会产生阻塞的read效果。</p>
<p>file_cp.c</p>
<p><em>#include &lt;sys&#x2F;types.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;stat.h&gt;</em>**</p>
<p><em>#include &lt;fcntl.h&gt;</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p>*#include &lt;errno.h&gt; ***</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p>*#define BUFFER_SIZE 1024 ***</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p>*int main(int argc,char **argv) ***</p>
<p>*{ ***</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
<li><p>   **int from_fd,to_fd; ***</p>
</li>
<li><p>   **int bytes_read,bytes_write; ***</p>
</li>
<li><p>   **char buffer[BUFFER_SIZE]; ***</p>
</li>
<li><p>   **char *ptr; ***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>   **if(argc!&#x3D;3) ***</p>
</li>
<li><p>   **{ ***</p>
</li>
<li><p>   **	**fprintf(stderr,”Usage:%s fromfile tofile&#x2F;n&#x2F;a”,argv[0]); ***</p>
</li>
<li><p>   **	**exit(1); ***</p>
</li>
<li><p>   **} ***</p>
</li>
<li><p>   **&#x2F;* 打开源文件 *&#x2F; ***</p>
</li>
<li><p>   **if((from_fd&#x3D;open(argv[1],O_RDONLY))&#x3D;&#x3D;-1) ***</p>
</li>
<li><p>   **{ ***</p>
</li>
<li><p>   **	**fprintf(stderr,”Open %s Error:%s&#x2F;n”,argv[1],strerror(errno)); ***</p>
</li>
<li><p>   **	**exit(1); ***</p>
</li>
<li><p>   **} ***</p>
</li>
<li><p>   **&#x2F;* 创建目的文件 *&#x2F; ***</p>
</li>
<li><p>   **if((to_fd&#x3D;open(argv[2],O_WRONLY|O_CREAT,S_IRUSR|S_IWUSR))&#x3D;&#x3D;-1) ***</p>
</li>
<li><p>   **{ ***</p>
</li>
<li><p>   **	**fprintf(stderr,”Open %s Error:%s&#x2F;n”,argv[2],strerror(errno)); ***</p>
</li>
<li><p>   **	**exit(1); ***</p>
</li>
<li><p>   **} ***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>   **&#x2F;* 以下代码是一个经典的拷贝文件的代码 *&#x2F; ***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>   **while(bytes_read&#x3D;read(from_fd,buffer,BUFFER_SIZE)) ***</p>
</li>
<li><p>   **{ ***</p>
</li>
<li><p>   **	**&#x2F;* 一个致命的错误发生了 *&#x2F; ***</p>
</li>
<li><p>   **	**if((bytes_read&#x3D;&#x3D;-1)&amp;&amp;(errno!&#x3D;EINTR)) break; ***</p>
</li>
<li><p>   **	**else if(bytes_read&gt;0) ***</p>
</li>
<li><p>   **	**{ ***</p>
</li>
<li><p>   **	**	**ptr&#x3D;buffer; ***</p>
</li>
<li><p>   **	**	**while(bytes_write&#x3D;write(to_fd,ptr,bytes_read)) ***</p>
</li>
<li><p>   **	**	**{ ***</p>
</li>
<li><p>   **	**	**	**&#x2F;* 一个致命错误发生了 *&#x2F; ***</p>
</li>
<li><p>   **	**	**	**if((bytes_write&#x3D;&#x3D;-1)&amp;&amp;(errno!&#x3D;EINTR))break; ***</p>
</li>
<li><p>   **	**	**	**&#x2F;* 写完了所有读的字节 *&#x2F; ***</p>
</li>
<li><p>   **	**	**	**else if(bytes_write&#x3D;&#x3D;bytes_read) break; ***</p>
</li>
<li><p>   **	**	**	**&#x2F;* 只写了一部分,继续写 *&#x2F; ***</p>
</li>
<li><p>   **	**	**	**else if(bytes_write&gt;0) ***</p>
</li>
<li><p>   **	**	**	**{ ***</p>
</li>
<li><p>   **	**	**	**ptr+&#x3D;bytes_write; ***</p>
</li>
<li><p>   **	**	**	**bytes_read-&#x3D;bytes_write; ***</p>
</li>
<li><p>   **	**	**	**} ***</p>
</li>
<li><p>   **	**	**} ***</p>
</li>
<li><p>   **	**	**&#x2F;* 写的时候发生的致命错误 *&#x2F; ***</p>
</li>
<li><p>   **	**	**if(bytes_write&#x3D;&#x3D;-1)break; ***</p>
</li>
<li><p>   **	**} ***</p>
</li>
<li><p>   **} ***</p>
</li>
<li><p>   **close(from_fd); ***</p>
</li>
<li><p>   **close(to_fd); ***</p>
</li>
<li><p>   **exit(0); ***</p>
</li>
</ul>
<p><em>}</em>**</p>
<h4 id="6-1-1-5-写"><a href="#6-1-1-5-写" class="headerlink" title="6.1.1.5 写"></a>6.1.1.5 写</h4><p>int write(int fd, const void *buf, size_t length)</p>
<p>功能：把length个字节从buf指向的缓冲区中写到文件描述符fd所指向的文件中，返回值为实际写入的字节数。</p>
<h4 id="6-1-1-6-read-与-fread-的区别的误解"><a href="#6-1-1-6-read-与-fread-的区别的误解" class="headerlink" title="6.1.1.6  read 与 fread 的区别的误解"></a>6.1.1.6  read 与 fread 的区别的误解</h4><p>缓冲</p>
<p><a href="file:///G:\学习笔记\笔记\附件\文档\read%20与%20fread%20的区别的误解.docx">链接1</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_93b45b0f01014qyb.html">链接2</a></p>
<h4 id="6-1-1-7-读写二进制文件"><a href="#6-1-1-7-读写二进制文件" class="headerlink" title="6.1.1.7 读写二进制文件"></a>6.1.1.7 读写二进制文件</h4><p><em>#include<fstream></em>**</p>
<p><em>#include<string></em>**</p>
<p><em>#include<iostream></em>**</p>
<p><em>using namespace std;</em>**</p>
<p><em>struct Point</em>**</p>
<p><em>{   string user;</em>**</p>
<ul>
<li>string password;};***</li>
</ul>
<p><em>int main()</em>**</p>
<p><em>{</em>*   &#x2F;&#x2F;写入文件***</p>
<ul>
<li><p>ofstream  file;***</p>
</li>
<li><p>file.open(“user.bin”,ios::out|ios::binary);   ***</p>
</li>
<li><p>Point user1;***</p>
</li>
<li><p>user1.user&#x3D;”admin”;***</p>
</li>
<li><p>user1.password&#x3D;”admin”;   ***</p>
</li>
<li><p>file.write((char *)&amp;user1,sizeof(Point));   ***</p>
</li>
<li><p>file.close();***</p>
</li>
</ul>
<hr>
<ul>
<li><p>&#x2F;&#x2F;读取文件***</p>
</li>
<li><p>ifstream rfile;***</p>
</li>
<li><p>rfile.open(“user.bin”,ios::in|ios::binary);***</p>
</li>
<li><p>Point user2;***</p>
</li>
<li><p>&#x2F;&#x2F;while(true)***</p>
</li>
<li><p>{rfile.read((char *) &amp;user2,sizeof(Point));***</p>
</li>
<li><p>** <strong>if(!rfile)</strong>*</p>
</li>
<li><p>rfile.close();<strong>}</strong> cout&lt;&lt;user2.user&lt;&lt;”,”&lt;&lt;user2.password&lt;&lt;endl;***</p>
</li>
<li><p>system(“pause”);***</p>
</li>
<li><p>return 0;***</p>
</li>
</ul>
<p><em>}</em>**</p>
<h4 id="6-1-1-8-定位"><a href="#6-1-1-8-定位" class="headerlink" title="6.1.1.8 定位"></a>6.1.1.8 定位</h4><p>intlseek(int fd, offset_t offset, int whence)</p>
<p>功能：将文件读写指针相对whence移动offset个字节。操作成功时，返回文件指针相对于文件头的位置。</p>
<p>whence可使用下述值：</p>
<p>SEEK_SET：相对文件开头</p>
<p>SEEK_CUR：相对文件读写指针的当前位置</p>
<p>SEEK_END：相对文件末尾</p>
<p>offset可取负值，表示向前移动。例如下述调用可将文件指针相对当前位置向前移动5个字节：lseek(fd, -5, SEEK_CUR)</p>
<p>由于lseek函数的返回值为文件指针相对于文件头的位置，因此下面调用的返回值就是文件的长度：lseek(fd, 0, SEEK_END)</p>
<p><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-26663150-id-3171484.html">用lseek计算文件长度</a> </p>
<h4 id="6-1-1-9-文件锁定"><a href="#6-1-1-9-文件锁定" class="headerlink" title="6.1.1.9 文件锁定"></a>6.1.1.9 文件锁定</h4><h5 id="6-1-1-9-1-flock（）"><a href="#6-1-1-9-1-flock（）" class="headerlink" title="6.1.1.9.1 flock（）"></a>6.1.1.9.1 flock（）</h5><p>int flock(int fd,int operation);</p>
<p><strong>#include</strong> &lt;stdio.h&gt;</p>
<p><strong>#include</strong> &lt;unistd.h&gt;</p>
<p><strong>#include</strong> &lt;sys&#x2F;types.h&gt;</p>
<p><strong>#include</strong> &lt;sys&#x2F;stat.h&gt;</p>
<p><strong>#include</strong> &lt;fcntl.h&gt;</p>
<p><strong>#include</strong> &lt;errno.h&gt;							&#x2F;<em>包含头文件。</em>&#x2F;</p>
<p><strong>main</strong>()</p>
<p>{ </p>
<p>   <strong>int</strong> fd,i;									&#x2F;<em>定义变量。</em>&#x2F;</p>
<p>   <strong>char</strong> path[]&#x3D;”&#x2F;root&#x2F;txt1.txt”;			&#x2F;<em>要访问的文件。</em>&#x2F;</p>
<p>   <strong>extern</strong> <strong>int</strong> errno; 						&#x2F;<em>定义错误号。</em>&#x2F;</p>
<p>   fd&#x3D;open(path,O_WRONLY|O_CREAT);			&#x2F;<em>打开文件。</em>&#x2F;</p>
<p>   <strong>if</strong>(fd!&#x3D;-1)								&#x2F;<em>打开成功。</em>&#x2F;</p>
<p>   {</p>
<p>​      printf(“opened file %s  .\n”,path);</p>
<p>​      printf(“please input a number to lock the file.\n”);	&#x2F;<em>输入一个数字。</em>&#x2F;</p>
<p>​      scanf(“%d”,&amp;i);						&#x2F;<em>输入。</em>&#x2F;</p>
<p>​      <strong>if</strong>(flock(fd,LOCK_EX)&#x3D;&#x3D;0)				&#x2F;<em>锁定文件。</em>&#x2F;</p>
<p>​      {</p>
<p>​         printf(“the file was locked.\n”);			&#x2F;<em>输出信息。</em>&#x2F;</p>
<p>​	  }</p>
<p>​	  <strong>else</strong></p>
<p>​	  {</p>
<p>​	     printf(“the file was not locked.\n”);		&#x2F;<em>文件锁定失败。</em>&#x2F;</p>
<p>​	  }</p>
<p>​      printf(“please input a number to unlock the file.\n”);	&#x2F;<em>提示输入。</em>&#x2F;</p>
<p>​      scanf(“%d”,&amp;i);								&#x2F;<em>输入。</em>&#x2F;</p>
<p>​      <strong>if</strong>(flock(fd,LOCK_UN)&#x3D;&#x3D;0)						&#x2F;<em>解除文件锁定。</em>&#x2F;</p>
<p>​      {</p>
<p>​         printf(“the file was unlocked.\n”);			&#x2F;<em>输出解除锁定成功。</em>&#x2F;</p>
<p>​	  }</p>
<p>​	  <strong>else</strong></p>
<p>​	  {</p>
<p>​	     printf(“the file was not unlocked.\n”);	&#x2F;<em>输出解除锁定失败。</em>&#x2F;</p>
<p>​	  }</p>
<p>​      close(fd);										&#x2F;<em>关闭文件。</em>&#x2F;</p>
<p>   }</p>
<p>   <strong>else</strong></p>
<p>   {</p>
<p>​      printf(“cant’t open file %s.\n”,path);		&#x2F;<em>不能打开文件的情况。</em>&#x2F;</p>
<pre><code>     printf(&quot;errno：%d\n&quot;,errno);					/*显示错误号。*/

     printf(&quot;ERR  ：%s\n&quot;,strerror(errno));		/*显示错误信息。*/
</code></pre>
<p>   }</p>
<p>}</p>
<h5 id="6-1-1-9-2-fcntl"><a href="#6-1-1-9-2-fcntl" class="headerlink" title="6.1.1.9.2 fcntl()"></a>6.1.1.9.2 fcntl()</h5><p>文件锁包括建议性锁和强制性锁。建议性锁要求每个上锁文件的进程都要检查是否有锁存在。</p>
<p>其中lockf（）用于对文件施加建议性锁，而fcntl（）不仅可以施加建议性锁，也可以施加强制性锁。同时fcntl（）还能对文件的某一记录上锁，也就是记录锁。</p>
<p>记录锁又分为读取锁和写入锁。读取锁又称共享锁，能够使多个进程能在同一部分建立读取锁。写入锁又称排斥锁，任何时刻只能有一个进程在文件的某个部分建立写入锁。</p>
<p>int  fcntl(int fd, int cmd, struct  flock *lock);</p>
<p>lock的结构</p>
<p>struct  flock</p>
<p>{	short  l_type;</p>
<p>​	off_t  l_start;</p>
<p>​	short  l_whence;</p>
<p>​	off_t  l_len;</p>
<p>​	pid_t  l_pid;}</p>
<h5 id="6-1-1-9-3-lockf"><a href="#6-1-1-9-3-lockf" class="headerlink" title="6.1.1.9.3 lockf()"></a>6.1.1.9.3 lockf()</h5><h4 id="6-1-1-10-文件的移动与复制"><a href="#6-1-1-10-文件的移动与复制" class="headerlink" title="6.1.1.10 文件的移动与复制"></a>6.1.1.10 文件的移动与复制</h4><p>文件的复制，是打开源文件—读取内容—写入目标文件</p>
<p>errno!&#x3D;EINTR</p>
<p>注意read（）如果读到数据为0，那么就表示文件结束了，如果在读的过程中遇到了中断那么会返回-1，同时置errno为EINTR。</p>
<h5 id="6-1-1-10-1-文件复制1"><a href="#6-1-1-10-1-文件复制1" class="headerlink" title="6.1.1.10.1 文件复制1"></a>6.1.1.10.1 文件复制1</h5><p><em>#include &lt;sys&#x2F;types.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;stat.h&gt;</em>**</p>
<p><em>#include &lt;fcntl.h&gt;</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p>*#include &lt;errno.h&gt; ***</p>
<p>*#define BUFFER_SIZE 1024 ***</p>
<p>*int main(int argc,char **argv) ***</p>
<p>*{ ***</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p>*int from_fd,to_fd; ***</p>
<p>*int bytes_read,bytes_write; ***</p>
<p>*char buffer[BUFFER_SIZE]; ***</p>
<p>*char *ptr; ***</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p>*if(argc!&#x3D;3) ***</p>
<p>*{ ***</p>
<p>*fprintf(stderr,”Usage:%s fromfile tofile&#x2F;n&#x2F;a”,argv[0]); ***</p>
<p>*exit(1); ***</p>
<p>*} ***</p>
<p>*&#x2F;* 打开源文件 *&#x2F; ***</p>
<p>*if((from_fd&#x3D;open(argv[1],O_RDONLY))&#x3D;&#x3D;-1) ***</p>
<p>*{ ***</p>
<p>*fprintf(stderr,”Open %s Error:%s&#x2F;n”,argv[1],strerror(errno)); ***</p>
<p>*exit(1); ***</p>
<p>*} ***</p>
<p>*&#x2F;* 创建目的文件 *&#x2F; ***</p>
<p>*if((to_fd&#x3D;open(argv[2],O_WRONLY|O_CREAT,S_IRUSR|S_IWUSR))&#x3D;&#x3D;-1) ***</p>
<p>*{ ***</p>
<p>*fprintf(stderr,”Open %s Error:%s&#x2F;n”,argv[2],strerror(errno)); ***</p>
<p>*exit(1); ***</p>
<p>*} ***</p>
<p>*&#x2F;* 以下代码是一个经典的拷贝文件的代码 *&#x2F; ***</p>
<p>*while(bytes_read&#x3D;read(from_fd,buffer,BUFFER_SIZE)) ***</p>
<p>*{ ***</p>
<p>*&#x2F;* 一个致命的错误发生了 *&#x2F; ***</p>
<p>*if((bytes_read&#x3D;&#x3D;-1)&amp;&amp;(errno!&#x3D;EINTR)) break; ***</p>
<p>*else if(bytes_read&gt;0) ***</p>
<p>*{ ***</p>
<p>*ptr&#x3D;buffer; ***</p>
<p>*while(bytes_write&#x3D;write(to_fd,ptr,bytes_read)) ***</p>
<p>*{ ***</p>
<p>*&#x2F;* 一个致命错误发生了 *&#x2F; ***</p>
<p>*if((bytes_write&#x3D;&#x3D;-1)&amp;&amp;(errno!&#x3D;EINTR))break; ***</p>
<p>*&#x2F;* 写完了所有读的字节 *&#x2F; ***</p>
<p>*else if(bytes_write&#x3D;&#x3D;bytes_read) break; ***</p>
<p>*&#x2F;* 只写了一部分,继续写 *&#x2F; ***</p>
<p>*else if(bytes_write&gt;0) ***</p>
<p>*{ ***</p>
<p>*ptr+&#x3D;bytes_write; ***</p>
<p>*bytes_read-&#x3D;bytes_write; ***</p>
<p>*} ***</p>
<p>*} ***</p>
<p>*&#x2F;* 写的时候发生的致命错误 *&#x2F; ***</p>
<p>*if(bytes_write&#x3D;&#x3D;-1)break; } ***</p>
<p>*} ***</p>
<p>*close(from_fd); ***</p>
<p>*close(to_fd); ***</p>
<p>*exit(0); ***</p>
<p><em>}</em>**</p>
<h5 id="6-1-1-10-2-文件复制2"><a href="#6-1-1-10-2-文件复制2" class="headerlink" title="6.1.1.10.2 文件复制2"></a>6.1.1.10.2 文件复制2</h5><p><strong>#include</strong> &lt;stdio.h&gt;</p>
<p><strong>#include</strong> &lt;errno.h&gt;								&#x2F;<em>包含头文件。</em>&#x2F;</p>
<p><strong>main</strong>()</p>
<p>{ </p>
<p>   <strong>char</strong> path[]&#x3D;”&#x2F;root&#x2F;a.txt”;						&#x2F;<em>原文件。</em>&#x2F;</p>
<p>   <strong>char</strong> path1[]&#x3D;”&#x2F;root&#x2F;a11.txt”;					&#x2F;<em>目录文件。</em>&#x2F;</p>
<p>   <strong>char</strong> newpath[]&#x3D;”&#x2F;tmp&#x2F;b.txt”;						&#x2F;<em>一个不存在的文件。</em>&#x2F;</p>
<p>   <strong>extern</strong> <strong>int</strong> errno;								&#x2F;<em>错误号。</em>&#x2F;</p>
<p>   <strong>if</strong>(rename(path,newpath)&#x3D;&#x3D;0)						&#x2F;<em>移动文件。</em>&#x2F;</p>
<p>   {</p>
<p>​      printf(“the file %s was moved to %s .\n”,path,newpath);	&#x2F;<em>移动成功。</em>&#x2F;</p>
<p>   }</p>
<p>   <strong>else</strong></p>
<p>   {</p>
<p>​      printf(“can’t move the file %s .\n”,path);	&#x2F;<em>显示移动失败。</em>&#x2F;</p>
<pre><code>     printf(&quot;errno：%d\n&quot;,errno);					/*显示错误号。*/

     printf(&quot;ERR  ：%s\n&quot;,strerror(errno));		/*显示错误信息。*/
</code></pre>
<p>   }</p>
<p>   <strong>if</strong>(rename(path1,newpath)&#x3D;&#x3D;0)						&#x2F;<em>移动一个不存在的文件。</em>&#x2F;</p>
<p>   {</p>
<p>​      printf(“the file %s was moved to %s .\n”,path1,newpath);	&#x2F;<em>显示结果。</em>&#x2F;</p>
<p>   }</p>
<p>   <strong>else</strong></p>
<p>   {</p>
<p>​      printf(“can’t move the file %s .\n”,path1);	&#x2F;<em>显示移动不成功能。</em>&#x2F;</p>
<pre><code>     printf(&quot;errno：%d\n&quot;,errno);					/*显示错误号。*/

     printf(&quot;ERR  ：%s\n&quot;,strerror(errno));		/*显示错误信息。*/
</code></pre>
<p>   }</p>
<p>} </p>
<h4 id="6-1-1-11-同一分区中文件移动函数rename"><a href="#6-1-1-11-同一分区中文件移动函数rename" class="headerlink" title="6.1.1.11  同一分区中文件移动函数rename"></a>6.1.1.11  同一分区中文件移动函数rename</h4><p>int  rename(char *oldpath,char *newpath);</p>
<p><strong>#include</strong> &lt;stdio.h&gt;</p>
<p><strong>#include</strong> &lt;errno.h&gt;								&#x2F;<em>包含头文件。</em>&#x2F;</p>
<p><strong>main</strong>()</p>
<p>{ </p>
<p>   <strong>char</strong> path[]&#x3D;”&#x2F;root&#x2F;a.txt”;						&#x2F;<em>原文件。</em>&#x2F;</p>
<p>   <strong>char</strong> path1[]&#x3D;”&#x2F;root&#x2F;a11.txt”;					&#x2F;<em>目录文件。</em>&#x2F;</p>
<p>   <strong>char</strong> newpath[]&#x3D;”&#x2F;tmp&#x2F;b.txt”;						&#x2F;<em>一个不存在的文件。</em>&#x2F;</p>
<p>   <strong>extern</strong> <strong>int</strong> errno;								&#x2F;<em>错误号。</em>&#x2F;</p>
<p>   <strong>if</strong>(rename(path,newpath)&#x3D;&#x3D;0)						&#x2F;<em>移动文件。</em>&#x2F;</p>
<p>   {</p>
<p>​      printf(“the file %s was moved to %s .\n”,path,newpath);	&#x2F;<em>移动成功。</em>&#x2F;</p>
<p>   }</p>
<p>   <strong>else</strong></p>
<p>   {</p>
<p>​      printf(“can’t move the file %s .\n”,path);	&#x2F;<em>显示移动失败。</em>&#x2F;</p>
<pre><code>     printf(&quot;errno：%d\n&quot;,errno);					/*显示错误号。*/

     printf(&quot;ERR  ：%s\n&quot;,strerror(errno));		/*显示错误信息。*/
</code></pre>
<p>   }</p>
<p>   <strong>if</strong>(rename(path1,newpath)&#x3D;&#x3D;0)						&#x2F;<em>移动一个不存在的文件。</em>&#x2F;</p>
<p>   {</p>
<p>​      printf(“the file %s was moved to %s .\n”,path1,newpath);	&#x2F;<em>显示结果。</em>&#x2F;</p>
<p>   }</p>
<p>   <strong>else</strong></p>
<p>   {</p>
<p>​      printf(“can’t move the file %s .\n”,path1);	&#x2F;<em>显示移动不成功能。</em>&#x2F;</p>
<pre><code>     printf(&quot;errno：%d\n&quot;,errno);					/*显示错误号。*/

     printf(&quot;ERR  ：%s\n&quot;,strerror(errno));		/*显示错误信息。*/
</code></pre>
<p>   }</p>
<p>} </p>
<h4 id="6-1-1-12-访问判断"><a href="#6-1-1-12-访问判断" class="headerlink" title="6.1.1.12 访问判断"></a>6.1.1.12 访问判断</h4><p>有时我们需要判断文件是否可以进行某种操作(读,写等)，这时可以使用access函数：</p>
<p>int access(const char*pathname,int mode)</p>
<p>pathname：文件名称</p>
<p>mode：要判断的访问权限。可以取以下值或者是他们的组合。R_OK：文件可读，W_OK：文件可写，X_OK：文件可执行，F_OK文件存在。</p>
<p>返回值：当我们测试成功时,函数返回0,否则如果一个条件不符时,返回-1。</p>
<p>例：</p>
<p>#include&lt;unistd.h&gt;</p>
<p>int main()</p>
<p>{</p>
<p>if (access(“&#x2F;etc&#x2F;passwd”,R_OK) &#x3D;&#x3D;0)</p>
<p>printf(“&#x2F;etc&#x2F;passwd can be read!\n”);</p>
<p>}</p>
<h3 id="6-1-2-库函数-文件访问"><a href="#6-1-2-库函数-文件访问" class="headerlink" title="6.1.2 库函数-文件访问"></a>6.1.2 库函数-文件访问</h3><h4 id="6-1-2-1-创建和打开"><a href="#6-1-2-1-创建和打开" class="headerlink" title="6.1.2.1 创建和打开"></a>6.1.2.1 创建和打开</h4><p>FILE *fopen(const char *filename, const char *mode)</p>
<p>vfilename:打开的文件名(包含路径，缺省为当前路径)</p>
<p>vmode:打开模式</p>
<p>常见打开模式：</p>
<p>r, rb               只读方式打开</p>
<p>w, wb            只写方式打开，如果文件不存在，则创建该文件</p>
<p>a, ab             追加方式打开，如果文件不存 在，则创建该文件</p>
<p>r+, r+b, rb+       读写方式打开</p>
<p>w+, w+b, wh+   读写方式打开，如果文件不存在，则创建该文件</p>
<p>a+, a+b, ab+       读和追加方式打开。如果文件不存在，则创建该文件</p>
<h4 id="6-1-2-2-读"><a href="#6-1-2-2-读" class="headerlink" title="6.1.2.2 读"></a>6.1.2.2 读</h4><p><a href="">size_t fread(void *ptr, size_t size, size_t n, FILE </a> *stream)</p>
<p>功能：从stream指向的文件中读取n个字段，每个字段为size字节，并将读取的数据放入ptr所指的字符数组中，返回实际已读取的字节数。</p>
<h4 id="6-1-2-3-写"><a href="#6-1-2-3-写" class="headerlink" title="6.1.2.3 写"></a>6.1.2.3 写</h4><p><a href="">size_t fwrite (const void *ptr, size_t size, size_t</a> n, FILE *stream)</p>
<p>功能：从缓冲区ptr所指的数组中把n个字段写到stream指向的文件中，每个字段长为size个字节，返回实际写入的字段数。</p>
<h4 id="6-1-2-4-库函数-读字符"><a href="#6-1-2-4-库函数-读字符" class="headerlink" title="6.1.2.4 库函数-读字符"></a>6.1.2.4 库函数-读字符</h4><p>int fgetc(FILE *stream)   从指定的文件中读一个字符</p>
<p>#include&lt;stdio.h&gt; </p>
<p>main() </p>
<p>{ </p>
<p>FILE *fp; </p>
<p>char ch; </p>
<p>if((fp&#x3D;fopen(“c1.txt”,”rt”))&#x3D;&#x3D;NULL) </p>
<p>{ </p>
<p>printf(“\nCannot open file strike any key exit! “); </p>
<p>getch(); </p>
<p>exit(1); </p>
<p>} </p>
<p>ch&#x3D;fgetc(fp); </p>
<p>while(ch!&#x3D;EOF) </p>
<p>{ </p>
<p>putchar(ch); </p>
<p>ch&#x3D;fgetc(fp); </p>
<p>}</p>
<p>fclose(fp); </p>
<p>}</p>
<p><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_590be5290100kaeg.html">C语言的get函数汇总</a></p>
<p>int getc(FILE *stream);</p>
<p>​    从指定输入流 stream 的当前位置读取一个字符，若读到文件尾而无数据时便返回EOF。</p>
<p>main()</p>
<p>{</p>
<p> int c;</p>
<p> FILE *fp&#x3D; fopen(“d:\a.txt”,”r”);</p>
<p> fpos_t p&#x3D;4;</p>
<p> fsetpos(fp,&amp;p);</p>
<p> c&#x3D;getc(fp);</p>
<p> putchar(c);</p>
<p>}</p>
<p>文件内容为：123456回车，输出：5</p>
<h4 id="6-1-2-5-库函数-写字符"><a href="#6-1-2-5-库函数-写字符" class="headerlink" title="6.1.2.5 库函数-写字符"></a>6.1.2.5 库函数-写字符</h4><p>int fputc(int c, FILE *stream)</p>
<p>向指定的文件中写入一个字符</p>
<p>#include&lt;stdio.h&gt; </p>
<p>main() </p>
<p>{ </p>
<p>FILE *fp; </p>
<p>char ch; </p>
<p>if((fp&#x3D;fopen(“string”,”wt+”))&#x3D;&#x3D;NULL) { </p>
<p>printf(“Cannot open file，strike any key exit!”); </p>
<p>getch(); </p>
<p>exit(1); </p>
<p>} </p>
<p>printf(“input a string:\n”); </p>
<p>ch&#x3D;getchar(); </p>
<p>while (ch!&#x3D;’\n’) { </p>
<p>fputc(ch,fp); </p>
<p>ch&#x3D;getchar(); </p>
<p>} </p>
<p>printf(“\n”);</p>
<p>fclose(fp); </p>
<p>}</p>
<h4 id="6-1-2-6-库函数进行文件复制"><a href="#6-1-2-6-库函数进行文件复制" class="headerlink" title="6.1.2.6 库函数进行文件复制"></a>6.1.2.6 库函数进行文件复制</h4><p>#include &lt;string.h&gt;</p>
<p>#include &lt;strings.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#define BUFFER_SIZE 1024 </p>
<p>int main(int argc,char **argv) </p>
<p>{ </p>
<p>​	FILE *from_fd;</p>
<p>​	FILE *to_fd; </p>
<p>​	long file_len&#x3D;0;</p>
<p>​	char buffer[BUFFER_SIZE]; </p>
<p>​	char *ptr; </p>
<p>​	</p>
<p>​	&#x2F;<em>判断入参</em>&#x2F;</p>
<p>​	if(argc!&#x3D;3) </p>
<p>​	{ </p>
<p>​		printf(“Usage:%s fromfile tofile\n”,argv[0]); </p>
<p>​		exit(1); </p>
<p>​	} </p>
<p>&#x2F;* 打开源文件 *&#x2F; </p>
<p>if((from_fd&#x3D;fopen(argv[1],”rb”))&#x3D;&#x3D;NULL) </p>
<p>{ </p>
<p>​	printf(“Open %s Error\n”,argv[1]); </p>
<p>​	exit(1); </p>
<p>} </p>
<p>&#x2F;* 创建目的文件 *&#x2F; </p>
<p>if((to_fd&#x3D;fopen(argv[2],”wb”))&#x3D;&#x3D;NULL) </p>
<p>{ </p>
<p>​	printf(“Open %s Error\n”,argv[2]); </p>
<p>​	exit(1); </p>
<p>} </p>
<p>&#x2F;<em>测得文件大小</em>&#x2F;</p>
<p>fseek(from_fd,0L,SEEK_END);</p>
<p>file_len&#x3D;ftell(from_fd);</p>
<p>fseek(from_fd,0L,SEEK_SET);</p>
<p>printf(“from file size is&#x3D;%d\n”,file_len);</p>
<p>&#x2F;<em>进行文件拷贝</em>&#x2F;</p>
<p>while(!feof(from_fd)) </p>
<p>{ </p>
<p>​	fread(buffer,BUFFER_SIZE,1,from_fd);</p>
<p>​	if(BUFFER_SIZE&gt;&#x3D;file_len)</p>
<p>​	{</p>
<p>​		fwrite(buffer,file_len,1,to_fd);</p>
<p>​	}</p>
<p>​	else </p>
<p>​	{</p>
<p>​		fwrite(buffer,BUFFER_SIZE,1,to_fd);</p>
<p>​		file_len&#x3D;file_len-BUFFER_SIZE;</p>
<p>​	}</p>
<p>​	bzero(buffer,BUFFER_SIZE);</p>
<p>} </p>
<p>fclose(from_fd); </p>
<p>fclose(to_fd); </p>
<p>exit(0); </p>
<p>}</p>
<h4 id="6-1-2-7-库函数-格式化读"><a href="#6-1-2-7-库函数-格式化读" class="headerlink" title="6.1.2.7 库函数-格式化读"></a>6.1.2.7 库函数-格式化读</h4><p>fscanf(FILE *stream, char *format[,argument…])</p>
<p>从一个流中进行格式化输入</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(void)</p>
<p>{</p>
<p>int i; </p>
<p>printf(“Input an integer: “); </p>
<p>if(fscanf(stdin, “%d”, &amp;i)) </p>
<p>printf(“Theinteger read was: %i\n”, i);</p>
<p>return 0;</p>
<p>}</p>
<h4 id="6-1-2-8-库函数-格式化写"><a href="#6-1-2-8-库函数-格式化写" class="headerlink" title="6.1.2.8 库函数-格式化写"></a>6.1.2.8 库函数-格式化写</h4><p>int fprintf(FILE <em>stream, char</em> format[,argument,…])</p>
<p>格式化输出到一个流中</p>
<p>#include &lt;stdio.h&gt; </p>
<p>#include &lt;process.h&gt;</p>
<p>FILE *stream; </p>
<p>void main( void ) </p>
<p>{ </p>
<p>inti &#x3D; 10; </p>
<p>double fp &#x3D; 1.5; </p>
<p>char s[] &#x3D; “this is a string”; </p>
<p>char c &#x3D; ‘\n’; </p>
<p>stream &#x3D; fopen( “fprintf.out”, “w” ); </p>
<p>fprintf( stream, “%s%c”, s, c ); </p>
<p>fprintf( stream, “%d\n”, i ); </p>
<p>fprintf( stream, “%f\n”, fp ); </p>
<p>fclose( stream ); }</p>
<h4 id="6-1-2-9-库函数-定位"><a href="#6-1-2-9-库函数-定位" class="headerlink" title="6.1.2.9 库函数-定位"></a>6.1.2.9 库函数-定位</h4><p>int fseek(FILE *stream, long offset, int whence)</p>
<p>whence:</p>
<p>SEEK_SET 从文件的开始处开始搜索</p>
<p>SEEK_CUR 从当前位置开始搜索</p>
<p>SEEK_END 从文件的结束处开始搜索</p>
<h4 id="6-1-2-10-路径获取"><a href="#6-1-2-10-路径获取" class="headerlink" title="6.1.2.10 路径获取"></a>6.1.2.10 路径获取</h4><p>在编写程序的时候，有时候需要得到当前路径。C库函数提供了getcwd来解决这个问题。</p>
<p>char <em>getcwd(char</em>buffer,size_t size)我们提供一个size大小的buffer,getcwd会把当前的路径名copy 到buffer中.如果buffer太小,函数会返回-1。</p>
<p>#include&lt;unistd.h&gt;</p>
<p>main()</p>
<p>{</p>
<p>char buf[80];</p>
<p>getcwd(buf,sizeof(buf));</p>
<p>printf(“current working directory : %sn”,buf);</p>
<p>}</p>
<h4 id="6-1-2-11-创建目录"><a href="#6-1-2-11-创建目录" class="headerlink" title="6.1.2.11 创建目录"></a>6.1.2.11 创建目录</h4><p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>int mkdir(char * dir, int mode)</p>
<p>功能：创建一个新目录。</p>
<p>返回值：0表示成功，-1表述出错。</p>
<h4 id="6-1-2-12-linux下清空文件内容"><a href="#6-1-2-12-linux下清空文件内容" class="headerlink" title="6.1.2.12 linux下清空文件内容"></a>6.1.2.12 <a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-23095063-id-379364.html">linux下清空文件内容</a></h4><p>1.truncate()函数<br>#include   &lt;unistd.h&gt;<br>int   truncate(const   char   *path,off_t   length);<br>truncate()函数会将参数path指定的文件大小该为参数length指定的大小。如果原来的文件比length大，则删除超出的部分。所以，将length设为0，则清空原文件了。</p>
<p>2.用写文件方式打开文件，然后关闭，文件就已经被清除了。</p>
<h4 id="6-1-2-13-ftell函数"><a href="#6-1-2-13-ftell函数" class="headerlink" title="6.1.2.13 ftell函数"></a>6.1.2.13 ftell函数</h4><p>函数 ftell 用于得到文件位置指针当前位置相对于文件首的偏移字节数。在随机方式存取文件时，由于文件位置频繁的前后移动，程序不容易确定文件的当前位置。</p>
<h4 id="6-1-2-14-bzero"><a href="#6-1-2-14-bzero" class="headerlink" title="6.1.2.14 bzero"></a>6.1.2.14 bzero</h4><p>原型：extern void bzero（void *s, int n）;</p>
<p>参数说明：s 要置零的数据的起始地址； n 要置零的数据字节个数。</p>
<p>用法：#include &lt;string.h&gt;</p>
<p>功能：置字节字符串s的前n个字节为零且包括‘\0’。</p>
<p>说明：bzero无返回值，并且使用string.h头文件，string.h曾经是posix标准的一部分，但是在POSIX.1-2001标准里面，这些函数被标记为了遗留函数而不推荐使用。在POSIX.1-2008标准里已经没有这些函数了。推荐使用memset替代bzero。</p>
<h3 id="6-1-3-IO处理模型"><a href="#6-1-3-IO处理模型" class="headerlink" title="6.1.3 IO处理模型"></a>6.1.3 IO处理模型</h3><p>阻塞I&#x2F;O模型</p>
<p>非阻塞模型</p>
<p>I&#x2F;O多路转接模型</p>
<p>信号驱动I&#x2F;O模型</p>
<p>异步I&#x2F;O模型</p>
<h3 id="6-1-4-多路复用"><a href="#6-1-4-多路复用" class="headerlink" title="6.1.4 多路复用"></a>6.1.4 多路复用</h3><h4 id="6-1-4-1-select"><a href="#6-1-4-1-select" class="headerlink" title="6.1.4.1 select()"></a>6.1.4.1 select()</h4><p>int  select(int numfds,fd_set *readfds, fd_set *writefds, fd_set *exeptfds,struct  timeval *timeout)</p>
<p>numfds:要监视的文件描述符的最大值加1；</p>
<p>readfds：由select（）监视的读文件描述符集合。</p>
<p>writefds：由select（）监视的写文件描述符集合。</p>
<p>exeptfds：由select（）监视的异常处理文件描述符集合。</p>
<p>timeout： null永远等待</p>
<p>0 从不等待。</p>
<p>函数返回值：大于0，成功，返回准备好的文件描述符的数目</p>
<p>​             0，超时</p>
<p>​				-1，出错</p>
<p>FD_ZERO(&amp;set); &#x2F;<em>将set清零使集合中不含任何fd</em>&#x2F;</p>
<p>FD_SET(fd, &amp;set); &#x2F;<em>将fd加入set集合</em>&#x2F;</p>
<p>FD_CLR(fd, &amp;set); &#x2F;<em>将fd从set集合中清除</em>&#x2F;</p>
<p>FD_ISSET(fd, &amp;set); &#x2F;<em>在调用select()函数后，用FD_ISSET来检测fd在fdset集合中的状态是否变化返回整型，当检测到fd状态发生变化时返回真，否则，返回假（0）</em>&#x2F;</p>
<p>FD_CLR(inr fd,fd_set* set)；用来清除描述词组set中相关fd 的位<br>FD_ISSET(int fd,fd_set <em>set)；用来测试描述词组set中相关fd 的位是否为真<br>FD_SET（int fd,fd_set</em>set）；用来设置描述词组set中相关fd的位<br>FD_ZERO（fd_set *set）； 用来清除描述词组set的全部位  </p>
<h4 id="6-1-4-2-pool（）"><a href="#6-1-4-2-pool（）" class="headerlink" title="6.1.4.2 pool（）"></a>6.1.4.2 pool（）</h4><p>int  poll(struct  pollfd *fds,int numfds,int timeout)</p>
<h4 id="6-1-4-3-epool"><a href="#6-1-4-3-epool" class="headerlink" title="6.1.4.3 epool"></a>6.1.4.3 epool</h4><p>epoll - I&#x2F;O event notification facility</p>
<p>在linux的网络编程中，很长的时间都在使用select来做事件触发。在linux新的内核中，有了一种替换它的机制，就是epoll。<br>相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。并且，在linux&#x2F;posix_types.h头文件有这样的声明：<br>#define __FD_SETSIZE    1024</p>
<p>表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。</p>
<p>epoll的接口非常简单，一共就三个函数：</p>
<p>\1. int epoll_create(int size);</p>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看&#x2F;proc&#x2F;进程id&#x2F;fd&#x2F;，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p>\2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<p>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：</p>
<p>EPOLL_CTL_ADD：注册新的fd到epfd中；</p>
<p>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</p>
<p>EPOLL_CTL_DEL：从epfd中删除一个fd；</p>
<p>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：</p>
<p>typedef union epoll_data {</p>
<p>​    void *ptr;</p>
<p>​    int fd;</p>
<p>​    __uint32_t u32;</p>
<p>​    __uint64_t u64;</p>
<p>} epoll_data_t;</p>
<p>struct epoll_event {</p>
<p>​    __uint32_t events; &#x2F;* Epoll events *&#x2F;</p>
<p>​    epoll_data_t data; &#x2F;* User data variable *&#x2F;</p>
<p>};</p>
<p>events可以是以下几个宏的集合：</p>
<p>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br>EPOLLOUT：表示对应的文件描述符可以写；</p>
<p>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</p>
<p>EPOLLERR：表示对应的文件描述符发生错误；</p>
<p>EPOLLHUP：表示对应的文件描述符被挂断；</p>
<p>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</p>
<p>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<p>\3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<p>4、关于ET、LT两种工作模式：</p>
<p>可以得出这样的结论:ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,也就是说,如果要采用ET模式,需要一直read&#x2F;write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样;而LT模式是只要有数据没有处理就会一直通知下去的.那么究竟如何来使用epoll呢？其实非常简单。<br>通过在包含一个头文件#include &lt;sys&#x2F;epoll.h&gt; 以及几个简单的API将可以大大的提高你的网络服务器的支持人数。</p>
<p>首先通过create_epoll(int maxfds)来创建一个epoll的句柄，其中maxfds为你epoll所支持的最大句柄数。这个函数会返回一个新的epoll句柄，之后的所有操作将通过这个句柄来进行操作。在用完之后，记得用close()来关闭这个创建出来的epoll句柄。</p>
<p>之后在你的网络主循环里面，每一帧的调用epoll_wait(int epfd, epoll_event events, int max events, int timeout)来查询所有的网络接口，看哪一个可以读，哪一个可以写了。基本的语法为：</p>
<p>nfds &#x3D; epoll_wait(kdpfd, events, maxevents, -1);</p>
<p>其中kdpfd为用epoll_create创建之后的句柄，events是一个epoll_event*的指针，当epoll_wait这个函数操作成功之后，epoll_events里面将储存所有的读写事件。max_events是当前需要监听的所有socket句柄数。最后一个timeout是 epoll_wait的超时，为0的时候表示马上返回，为-1的时候表示一直等下去，直到有事件范围，为任意正整数的时候表示等这么长的时间，如果一直没有事件，则范围。一般如果网络主循环是单独的线程的话，可以用-1来等，这样可以保证一些效率，如果是和主逻辑在同一个线程的话，则可以用0来保证主循环的效率。</p>
<p>epoll_wait范围之后应该是一个循环，遍利所有的事件。</p>
<p>几乎所有的epoll程序都使用下面的框架：</p>
<p>for( ; ; )</p>
<p>{</p>
<p>​        nfds &#x3D; epoll_wait(epfd,events,20,500);</p>
<p>​        for(i&#x3D;0;i&lt;nfds;++i)</p>
<p>​        {</p>
<p>​            if(events[i].data.fd&#x3D;&#x3D;listenfd) &#x2F;&#x2F;有新的连接</p>
<p>​            {</p>
<p>​                connfd &#x3D; accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); &#x2F;&#x2F;accept这个连接</p>
<p>​          ev.data.fd&#x3D;connfd;</p>
<p>​         ev.events&#x3D;EPOLLIN|EPOLLET;</p>
<p>​        epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); &#x2F;&#x2F;将新的fd添加到epoll的监听队列中</p>
<p>​            }</p>
<p>​            else if( events[i].events&amp;EPOLLIN ) &#x2F;&#x2F;接收到数据，读socket<br>​            {</p>
<p>​                n &#x3D; read(sockfd, line, MAXLINE)) &lt; 0    &#x2F;&#x2F;读</p>
<p>​                ev.data.ptr &#x3D; md;     &#x2F;&#x2F;md为自定义类型，添加数据</p>
<p>​                ev.events&#x3D;EPOLLOUT|EPOLLET;</p>
<p>​                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);&#x2F;&#x2F;修改标识符，等待下一个循环时发送数据，异步处理的精髓</p>
<p>​            }</p>
<p>​            else if(events[i].events&amp;EPOLLOUT) &#x2F;&#x2F;有数据待发送，写socket</p>
<p>​            {</p>
<p>​                struct myepoll_data* md &#x3D; (myepoll_data*)events[i].data.ptr;    &#x2F;&#x2F;取数据</p>
<p>​                sockfd &#x3D; md-&gt;fd;</p>
<p>​                send( sockfd, md-&gt;ptr, strlen((char*)md-&gt;ptr), 0 );        &#x2F;&#x2F;发送数据</p>
<p>​                ev.data.fd&#x3D;sockfd;</p>
<p>​                ev.events&#x3D;EPOLLIN|EPOLLET;</p>
<p>​                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); &#x2F;&#x2F;修改标识符，等待下一个循环时接收数据</p>
<p>​            }</p>
<p>​            Else</p>
<p>​            {</p>
<p>​                &#x2F;&#x2F;其他的处理</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<h3 id="6-1-5-struct-stat结构体"><a href="#6-1-5-struct-stat结构体" class="headerlink" title="6.1.5 struct stat结构体"></a>6.1.5 struct stat结构体</h3><p>可以得到文件属性</p>
<p>如：0&#x3D;&#x3D;stat(pFileName,&amp;sFileStat)可以用来判断文件是否存在</p>
<p>头文件：&lt;sys&#x2F;stat.h&gt;</p>
<h2 id="6-2-Linux时间编程"><a href="#6-2-Linux时间编程" class="headerlink" title="6.2 Linux时间编程"></a>6.2 <a href="">Linux时间编程</a></h2><p>UTC   Coordinated Universal  Time   世界标准时间</p>
<p>GMT  Greenwich  Mean  Time   格林威治标准时间	</p>
<p>Calendar  Time  日历时间，“从一个标准时间点到此时经过的秒数”</p>
<h3 id="6-2-1-返回时间函数time"><a href="#6-2-1-返回时间函数time" class="headerlink" title="6.2.1 返回时间函数time"></a>6.2.1 返回时间函数time</h3><p>#include &lt;time.h&gt;</p>
<p>time_t time(time_t *tloc)</p>
<p>功能：获取日历时间，即从1970年1月1日0点到现在所经历的秒数。</p>
<p>&#x2F;* typedeflong time_t *&#x2F;</p>
<p>time();这个函数其实保存的是一个历史时间，所以需要用NULL把这个历史时间清空一下，time()就会自动保存当前时间了。你可以简单的理解为NULL就是给time()初始化。</p>
<p>例：time1.c （演示）</p>
<p>#include&lt;time.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(void){</p>
<p>struct tm *local;</p>
<p>time_t t;</p>
<p>t&#x3D;time(NULL);</p>
<p>local&#x3D;localtime(&amp;t);</p>
<p>printf(“Local hour is: %d\n”,local-&gt;tm_hour);</p>
<p>local&#x3D;gmtime(&amp;t);</p>
<p>printf(“UTChour is: %d\n”,local-&gt;tm_hour); return 0;</p>
<p>}</p>
<h3 id="6-2-2-当前时间函数gmtime"><a href="#6-2-2-当前时间函数gmtime" class="headerlink" title="6.2.2 当前时间函数gmtime"></a>6.2.2 当前时间函数gmtime</h3><p>struct tm *gmtime(const time_t *timep)</p>
<p>功能：将日历时间转化为格林威治标准时间（英国零时区时间），并保存至TM结构。</p>
<h3 id="6-2-3-本地时间函数localtime"><a href="#6-2-3-本地时间函数localtime" class="headerlink" title="6.2.3 本地时间函数localtime"></a>6.2.3 本地时间函数localtime</h3><p>struct tm *localtime(const time_t *timep)</p>
<p>功能：将日历时间转化为本地时间，并保存至TM结构。#include &lt;stdio.h&gt;</p>
<p><em>#include &lt;time.h&gt;</em>**</p>
<p><em>main(){</em>**</p>
<ul>
<li><p>time_t t;***</p>
</li>
<li><p>struct tm *p;***</p>
</li>
<li><p>time(&amp;t);***</p>
</li>
<li><p>p&#x3D;localtime(&amp;t);***</p>
</li>
<li><p>printf(“Year  :%d\n”,1900+p-&gt;tm_year);***</p>
</li>
<li><p>printf(“Month :%d\n”,1+p-&gt;tm_mon);***</p>
</li>
<li><p>printf(“Day   :%d\n”,p-&gt;tm_mday);***</p>
</li>
<li><p>printf(“Hour  :%d\n”,p-&gt;tm_hour);***</p>
</li>
<li><p>printf(“Minute:%d\n”,p-&gt;tm_min);***</p>
</li>
<li><p>printf(“Second:%d\n”,p-&gt;tm_sec);***</p>
</li>
<li><p>printf(“Weekday:%d\n”,p-&gt;tm_wday);***</p>
</li>
<li><p>printf(“Days  :%d\n”,p-&gt;tm_yday);***</p>
</li>
<li><p>printf(“Isdst :%d\n”,p-&gt;tm_isdst);***</p>
</li>
<li><p>getch();***</p>
</li>
</ul>
<h3 id="6-2-4-localtime-r"><a href="#6-2-4-localtime-r" class="headerlink" title="6.2.4 localtime_r"></a>6.2.4 localtime_r</h3><h3 id="6-2-5-字符串格式时间函数ctime"><a href="#6-2-5-字符串格式时间函数ctime" class="headerlink" title="6.2.5 字符串格式时间函数ctime"></a>6.2.5 字符串格式时间函数ctime</h3><p>char *ctime(time_t *timep);</p>
<p>将一个时间返回成一个可以识别的字符串格式，这里返回的时间已经转换成本地时间。#include &lt;stdio.h&gt;</p>
<p><em>#include &lt;time.h&gt;</em>**</p>
<p><em>#include &lt;stdlib.h&gt;</em>**</p>
<p><em>int main()</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>time_t *p;***</p>
</li>
<li><p>char s[30];***</p>
</li>
<li><p>time(p);***</p>
</li>
<li><p>strcpy(s,ctime(p)) ;***</p>
</li>
<li><p>printf(“%s\n”,s);***</p>
</li>
<li><p>getch();***</p>
</li>
</ul>
<p><em>}</em>**</p>
<h3 id="6-2-6-字符串格式时间函数asctime"><a href="#6-2-6-字符串格式时间函数asctime" class="headerlink" title="6.2.6 字符串格式时间函数asctime"></a>6.2.6 字符串格式时间函数asctime</h3><p>char *asctime(const struct tm *tm)</p>
<p>功能：将tm格式的时间转化为字符串，如：Sat Jul 30 08:43:03 2005</p>
<p>char *ctime(const time_t *timep)</p>
<p>功能：将日历时间转化为本地时间的字符串形式。</p>
<p>例：time2.c(演示) </p>
<p>#include &lt;time.h&gt;</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>int main(void)</em>**</p>
<p><em>{</em>**</p>
<p><em>struct tm *ptr;</em>**</p>
<p><em>time_tlt;</em>**</p>
<p><em>lt&#x3D;time(NULL);</em>**</p>
<p><em>ptr&#x3D;gmtime(&lt;);</em>**</p>
<p><em>printf(asctime(ptr));</em>**</p>
<p><em>printf(ctime(&lt;));</em>**</p>
<p><em>return 0;</em>**</p>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;time.h&gt;</em>**</p>
<p><em>#include &lt;stdlib.h&gt;</em>**</p>
<p><em>int main()</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>time_t *p;***</p>
</li>
<li><p>char s[30];***</p>
</li>
<li><p>struct gm *q;***</p>
</li>
<li><p>time(p);***</p>
</li>
<li><p>q&#x3D;gmtime(p);***</p>
</li>
<li><p>strcpy(s,asctime(q)) ;***</p>
</li>
<li><p>printf(“%s\n”,s);***</p>
</li>
</ul>
<p><em>}</em>**</p>
<h3 id="6-2-7-将时间转换成秒数函数mktime"><a href="#6-2-7-将时间转换成秒数函数mktime" class="headerlink" title="6.2.7 将时间转换成秒数函数mktime"></a>6.2.7 将时间转换成秒数函数mktime</h3><p>time_t  mktime(tm *timeptr);</p>
<p>将一个tm结构类型的时间转换成秒数时间，与gmtime的作用相反。</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;stdlib.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;time.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>#include &lt;time.h&gt;</em>**</p>
<p><em>main()</em>**</p>
<p>*{ ***</p>
<ul>
<li><p>time_t t;***</p>
</li>
<li><p>struct tm *p;***</p>
</li>
<li><p>char s[30];***</p>
</li>
<li><p>time(&amp;t);***</p>
</li>
<li><p>strcpy(s,ctime(&amp;t));***</p>
</li>
<li><p>printf(“%s\n”,s);***</p>
</li>
<li><p>p&#x3D;gmtime(&amp;t);***</p>
</li>
<li><p>t&#x3D;mktime(p);***</p>
</li>
<li><p>time(&amp;t);***</p>
</li>
<li><p>strcpy(s,ctime(&amp;t));***</p>
</li>
<li><p>printf(“%s\n”,s);***</p>
</li>
</ul>
<p><em>}</em>**</p>
<hr>
<p><em>Wed Dec 26 08:41:07 2007</em>**</p>
<p><em>Wed Dec 26 08:41:07 2007</em>**</p>
<h3 id="6-2-8-取得当前的时间函数gettimeofday"><a href="#6-2-8-取得当前的时间函数gettimeofday" class="headerlink" title="6.2.8 取得当前的时间函数gettimeofday"></a>6.2.8 取得当前的时间函数gettimeofday</h3><p>前面所提到的时间函数只能把时间精确到秒，而此函数可以精确到微秒。</p>
<p>int gettimeofday(struct timeval <em>tv,struct  timezone</em>tz)</p>
<p>功能：获取从今日凌晨到现在的时间差，常用于计算事件耗时。</p>
<p><em>struct timeval {</em>**</p>
<p><em>int tv_sec;&#x2F;&#x2F;秒数</em>**</p>
<p><em>int tv_usec; &#x2F;&#x2F;微妙数</em>**</p>
<p><em>};</em>**</p>
<p><em>timeval为时间</em>**</p>
<p><em>timezone为时区</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>#include&lt;stdio.h&gt;</em>**</p>
<p><em>#include&lt;sys&#x2F;time.h&gt;</em>**</p>
<p>*int main(){ ***</p>
<p><em>struct timeval tv;</em>**</p>
<p><em>gettimeofday(&amp;tv,NULL);</em>**</p>
<p><em>printf(“%d,%d\n”,tv.tv_sec,tv.tv_usec);</em>**</p>
<p><em>return 0;</em>**</p>
<p><em>}</em>**</p>
<h3 id="6-2-9-设置当前时间函数settimeofday"><a href="#6-2-9-设置当前时间函数settimeofday" class="headerlink" title="6.2.9 设置当前时间函数settimeofday"></a>6.2.9 设置当前时间函数settimeofday</h3><p>设置当前的系统时间。</p>
<p>int settimeofday(struct timeval *tv,struct  timezone *tz);</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;time.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>#include &lt;time.h&gt;</em>**</p>
<p><em>main()</em>**</p>
<p><em>{  struct timeval tv;</em>**</p>
<ul>
<li><p>struct timezone tz;***</p>
</li>
<li><p>gettimeofday (&amp;tv , &amp;tz);***</p>
</li>
<li><p>printf(“tv_sec        : %d\n”, tv.tv_sec);***</p>
</li>
<li><p>printf(“tv_usec       : %d\n”,tv.tv_usec);***</p>
</li>
<li><p>printf(“tz_minuteswest: %d\n”, tz.tz_minuteswest);***</p>
</li>
<li><p>printf(“tz_dsttime    : %d\n”,tz.tz_dsttime);***</p>
</li>
<li><p>tv.tv_sec&#x3D;tv.tv_sec- 4000;***</p>
</li>
<li><p>settimeofday (&amp;tv , &amp;tz); ***</p>
</li>
</ul>
<p>*} ***</p>
<h3 id="6-2-10-tm结构"><a href="#6-2-10-tm结构" class="headerlink" title="6.2.10 tm结构"></a>6.2.10 tm结构</h3><p>struct tm{</p>
<p>int tm_sec;  &#x2F;&#x2F;秒值</p>
<p>int tm_min; &#x2F;&#x2F;分钟值</p>
<p>int tm_hour; &#x2F;&#x2F;小时值</p>
<p>int tm_mday; &#x2F;&#x2F;本月第几日</p>
<p>int tm_mon; &#x2F;&#x2F;本年第几月</p>
<p>int tm_year; &#x2F;&#x2F;tm_year + 1900 &#x3D; 哪一年</p>
<p>int tm_wday; &#x2F;&#x2F;本周第几日</p>
<p>int tm_yday; &#x2F;&#x2F;本年第几日</p>
<p>int tm_isdst; &#x2F;&#x2F;日光节约时间</p>
<p>};</p>
<h3 id="6-2-11-时间显示"><a href="#6-2-11-时间显示" class="headerlink" title="6.2.11 时间显示"></a>6.2.11 时间显示</h3><h3 id="6-2-12-获取时间"><a href="#6-2-12-获取时间" class="headerlink" title="6.2.12 获取时间"></a>6.2.12 获取时间</h3><h3 id="6-2-13-计算程序执行耗时"><a href="#6-2-13-计算程序执行耗时" class="headerlink" title="6.2.13 计算程序执行耗时"></a>6.2.13 计算程序执行耗时</h3><p>*#include &lt;sys&#x2F;time.h&gt; ***</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p>*#include &lt;stdlib.h&gt; ***</p>
<p><em>#include &lt;math.h&gt;</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>&#x2F;* 算法分析 <em>&#x2F;</em></em>*</p>
<p>*void function() ***</p>
<p>*{ ***</p>
<ul>
<li><p>   **unsigned int i,j; ***</p>
</li>
<li><p>   **double y; ***</p>
</li>
<li><p>   **for(i&#x3D;0;i&lt;1000;i++) ***</p>
</li>
<li><p>   **	**for(j&#x3D;0;j&lt;1000;j++) ***</p>
</li>
<li><p>   **	**	**y++; ***</p>
</li>
</ul>
<p>*} ***</p>
<p>*main() ***</p>
<p>*{ ***</p>
<ul>
<li><p>   **struct timeval tpstart,tpend; ***</p>
</li>
<li><p>   **float timeuse; ***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>   <strong>gettimeofday(&amp;tpstart,NULL); &#x2F;&#x2F; 开始时间</strong>*</p>
</li>
<li><p>   **function(); ***</p>
</li>
<li><p>   <strong>gettimeofday(&amp;tpend,NULL);   &#x2F;&#x2F; 结束时间</strong>*</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>   <strong>&#x2F;* 计算执行时间 <em>&#x2F;</em></strong></p>
</li>
<li><p>   **timeuse&#x3D;1000000*(tpend.tv_sec-tpstart.tv_sec)+ ***</p>
</li>
<li><p>   **	**tpend.tv_usec-tpstart.tv_usec; ***</p>
</li>
<li><p>   **timeuse&#x2F;&#x3D;1000000; ***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>   **printf(“Used Time:%f\n”,timeuse); ***</p>
</li>
<li><p>   **exit(0); ***</p>
</li>
</ul>
<p><em>}</em>**</p>
<h3 id="6-2-14-延时执行"><a href="#6-2-14-延时执行" class="headerlink" title="6.2.14 延时执行"></a>6.2.14 延时执行</h3><p>unsigned int sleep(unsignedint seconds)</p>
<p>功能：使程序睡眠seconds秒。</p>
<p>void usleep(unsignedlong usec)</p>
<p>功能：使程序睡眠usec微秒。</p>
<h3 id="6-2-15-获取本地时间，以字符串显示"><a href="#6-2-15-获取本地时间，以字符串显示" class="headerlink" title="6.2.15 获取本地时间，以字符串显示"></a>6.2.15 获取本地时间，以字符串显示</h3><h4 id="6-2-15-1-第一种方法"><a href="#6-2-15-1-第一种方法" class="headerlink" title="6.2.15.1 第一种方法"></a>6.2.15.1 第一种方法</h4><p><em>#include&lt;time.h&gt;</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>int main(void)</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>   <strong>struct tm *local;</strong>*</p>
</li>
<li><p>   <strong>char *asctime1,<em>ctime1;</em></strong></p>
</li>
<li><p>   <strong>time_t t;</strong>*</p>
</li>
<li><p>   <strong>t&#x3D;time(NULL);</strong>	***</p>
</li>
<li><p>   <strong>local&#x3D;localtime(&amp;t);</strong>*</p>
</li>
<li><p>   <strong>asctime1&#x3D;asctime(local);</strong>*</p>
</li>
<li><p>   <strong>printf(asctime1);</strong>*</p>
</li>
<li><p>   <strong>printf(“\n\n”);</strong>*</p>
</li>
</ul>
<hr>
<ul>
<li><p>   <strong>printf(asctime(local));</strong>*</p>
</li>
<li><p>   <strong>ctime1&#x3D;ctime(&amp;t);</strong>*</p>
</li>
<li><p>   <strong>printf(ctime1);</strong>*</p>
</li>
<li><p>   <strong>printf(“\n\n”);</strong>*</p>
</li>
<li><p>   <strong>return 0;</strong>*</p>
</li>
</ul>
<p><em>}</em>**</p>
<h4 id="6-2-15-2-第二种方法"><a href="#6-2-15-2-第二种方法" class="headerlink" title="6.2.15.2 第二种方法"></a>6.2.15.2 第二种方法</h4><p>strftime</p>
<p>strftime() 函数根据区域设置格式化本地时间&#x2F;日期，函数的功能将时间格式化，或者说格式化一个时间字符串。</p>
<p><em>#include<iostream></em>**</p>
<p>*#include &lt;time.h&gt; ***</p>
<p><em>using namespace std;</em>**</p>
<p><em>int main()</em>**</p>
<p><em>{</em>**</p>
<p>*time_t t &#x3D; time(0); ***</p>
<p><em>char tmp[64];</em>**</p>
<p>*strftime( tmp, sizeof(tmp), “%Y-%m-%d %X”,localtime(&amp;t) );  ***</p>
<p>*puts( tmp ); ***</p>
<p><em>system(“pause”);</em>**</p>
<p><em>return 0;</em>**</p>
<p><em>}</em>**</p>
<p><em>程序运行结果：</em><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps65.jpg" alt="img">**</p>
<h3 id="6-2-16-设置系统时间"><a href="#6-2-16-设置系统时间" class="headerlink" title="6.2.16 设置系统时间"></a>6.2.16 <a href="">设置系统时间</a></h3><p><em>#include &lt;sys&#x2F;time.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;time.h&gt;</em>**</p>
<p><em>#include <string></em>**</p>
<p><em>using namespace std;</em>**</p>
<p>*int main(void)  ***</p>
<p>*{  ***</p>
<ul>
<li><p>string temp&#x3D; “2014-03-18 22:30:00”;***</p>
</li>
<li><p>   **struct tm time_tm;  ***</p>
</li>
<li><p>struct timeval time_tv;  ***</p>
</li>
<li><p>time_t timep;  ***</p>
</li>
<li><p>int ret &#x3D; 0;   ***</p>
</li>
<li><p>sscanf(temp.c_str(),”%d-%d-%d %d:%d:%d”, &amp;time_tm.tm_year, &amp;time_tm.tm_mon, &amp;time_tm.tm_mday, &amp;time_tm.tm_hour, &amp;time_tm.tm_min, &amp;time_tm.tm_sec);  ***</p>
</li>
<li><p>time_tm.tm_year -&#x3D; 1900;  ***</p>
</li>
<li><p>time_tm.tm_mon -&#x3D; 1;  ***</p>
</li>
<li><p>time_tm.tm_wday &#x3D; 0;  ***</p>
</li>
<li><p>time_tm.tm_yday &#x3D; 0;  ***</p>
</li>
<li><p>time_tm.tm_isdst &#x3D; 0;    ***</p>
</li>
<li><p>timep &#x3D; mktime(&amp;time_tm);  ***</p>
</li>
<li><p>time_tv.tv_sec &#x3D; timep;  ***</p>
</li>
<li><p>time_tv.tv_usec &#x3D; 0;    ***</p>
</li>
<li><p>ret &#x3D; settimeofday(&amp;time_tv, NULL);  ***</p>
</li>
<li><p>if(ret !&#x3D; 0)  ***</p>
</li>
<li><p>{  ***</p>
</li>
<li><pre><code>   fprintf(stderr, &quot;settimeofday failed\n&quot;);  ***
</code></pre>
</li>
<li><pre><code>   return -1;  ***
</code></pre>
</li>
<li><p>}  ***</p>
</li>
<li><p>return 0;  ***</p>
</li>
</ul>
<p>*}  ***</p>
<h2 id="6-3-目录与文件"><a href="#6-3-目录与文件" class="headerlink" title="6.3 目录与文件"></a>6.3 <a href="">目录与文件</a></h2><h3 id="6-3-1-错误处理"><a href="#6-3-1-错误处理" class="headerlink" title="6.3.1 错误处理"></a>6.3.1 错误处理</h3><p>将错误号转换成字符串，显示错误信息：strerror（）；它是一个指针</p>
<h3 id="6-3-2-创建与删除目录"><a href="#6-3-2-创建与删除目录" class="headerlink" title="6.3.2 创建与删除目录"></a>6.3.2 创建与删除目录</h3><h4 id="6-3-2-1-创建目录函数mkdir"><a href="#6-3-2-1-创建目录函数mkdir" class="headerlink" title="6.3.2.1 创建目录函数mkdir()"></a>6.3.2.1 创建目录函数mkdir()</h4><p><em>#include&lt;sys&#x2F;types.h&gt;</em>**</p>
<p><em>#include&lt;sys&#x2F;stat.h&gt;</em>**</p>
<p>int  mkdir(char *pathname,mode_t  mode);</p>
<p>pathname是一个字符型指针，表示需要创建的目录路径</p>
<p>mode表示权限的八进制数字。</p>
<p>错误信息：</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;types.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;stat.h&gt; **	**	**	**	**	**	<em><em>&#x2F;*包含头文件。</em>&#x2F;</em></em>*</p>
<p><em>#include &lt;errno.h&gt;</em>*	**	**	**	**	**	**	<em><em>&#x2F;*包含头文件处理程序的错误。</em>&#x2F;</em>**</p>
<p><em>main()</em>**</p>
<p>*{ ***</p>
<ul>
<li><p>extern int errno;**	**	**	**	**	**	<em><em>&#x2F;*设置一个错误。</em>&#x2F;</em>**</p>
</li>
<li><p>char *path&#x3D;”&#x2F;root&#x2F;tmp11”;**	**	<em><em>&#x2F;*定义一个字符串表示需要创建的目录。</em>&#x2F;</em>**</p>
</li>
</ul>
<hr>
<ul>
<li><p>if(mkdir(path,0766)&#x3D;&#x3D;0)**	**	**	<em><em>&#x2F;*创建一个目录。</em>&#x2F;</em>**</p>
</li>
<li><p>**	**	**	<strong>&#x2F;*需要注意这里的权限设置参数，第一个0表示这里的是</strong>*</p>
</li>
</ul>
<p><em>八进制数，766的含义如本章第一节所述。*&#x2F;</em>**</p>
<ul>
<li><pre><code>/\*如果目录创建成功，则会返回0，返回值与0进行比较。*/***
</code></pre>
</li>
<li><p>{***</p>
</li>
<li><p>**	**  printf(“created the directory %s.\n”,path);**	**	<em><em>&#x2F;*输出目录创建成功。</em>&#x2F;</em>**</p>
</li>
<li><p>}***</p>
</li>
<li><p>else**	**	**	**	**	**	**	**	**	**	<em><em>&#x2F;*如果不成功则输出提示信息。</em>&#x2F;</em>**</p>
</li>
<li><p>{***</p>
</li>
<li><p>**	**  printf(“cant’t creat the directory %s.\n”,path);**	<em><em>&#x2F;*输出信息。</em>&#x2F;</em>**</p>
</li>
<li><p>**	**  printf(“errno：%d\n”,errno);**	**	**	<em><em>&#x2F;*输出错误号。</em>&#x2F;</em>**</p>
</li>
<li><p>**	**  printf(“ERR  ：%s\n”,strerror(errno));&#x2F;*输出错误信息。*&#x2F;***</p>
</li>
<li><p>}***</p>
</li>
</ul>
<p><em>}</em>**</p>
<h4 id="6-3-2-2-删除目录"><a href="#6-3-2-2-删除目录" class="headerlink" title="6.3.2.2 删除目录"></a>6.3.2.2 删除目录</h4><p><em>int  rmdir（char* pathname）；</em>**</p>
<p><em>在c++中应该添加另外两个头文件</em>**</p>
<p><strong>#include</strong> &lt;unistd.h&gt;&#x2F;&#x2F;rmdir</p>
<p><strong>#include</strong>* <strong>&lt;string.h&gt;</strong>&#x2F;&#x2F;<strong>strerror</strong>*</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;types.h&gt;</em>**</p>
<p>*#include &lt;sys&#x2F;stat.h&gt; ***</p>
<p><em>#include &lt;errno.h&gt;</em>*	**	**	**	**	**	**	**	<em><em>&#x2F;*包含头文件。</em>&#x2F;</em>**</p>
<p><em>main()</em>**</p>
<p>*{ ***</p>
<ul>
<li><p>extern int errno;**	**	**	**	**	**	**	<em><em>&#x2F;*设置错误编号。</em>&#x2F;</em>**</p>
</li>
<li><p>char *path&#x3D;”&#x2F;root&#x2F;tmp11”;**	**	**	**	**	<em><em>&#x2F;*设置需要删除的目录。</em>&#x2F;</em>**</p>
</li>
</ul>
<hr>
<ul>
<li><p>if(rmdir(path)&#x3D;&#x3D;0)**	**	**	**	**	**	**	<em><em>&#x2F;*删除文件，返回值与0比较。</em>&#x2F;</em>**</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code> printf(&quot;deleted the directory %s.\n&quot;,path);**	**	**/\*显示删除成功。*/***
</code></pre>
</li>
<li><p>}***</p>
</li>
<li><p>else**	**	**	**	**	**	**	**	**	**	**	<em><em>&#x2F;*如果删除不成功。</em>&#x2F;</em>**</p>
</li>
<li><p>{ ***</p>
</li>
<li><pre><code>printf(&quot;cant&#39;t delete the directory %s.\n&quot;,path);**	**/\*显示删除错误。*/***
</code></pre>
</li>
<li><pre><code>printf(&quot;errno：%d\n&quot;,errno);**	**	**	**	**/\*显示错误号。*/***
</code></pre>
</li>
<li><pre><code>printf(&quot;ERR  ：%s\n&quot;,strerror(errno));**	**	**/\*显示错误信息。*/***
</code></pre>
</li>
<li><p>}***</p>
</li>
</ul>
<p><em>}</em>**</p>
<h3 id="6-3-3-创建文件"><a href="#6-3-3-创建文件" class="headerlink" title="6.3.3 创建文件"></a>6.3.3 创建文件</h3><p>int  creat(char *pathname,mode_t  mode);</p>
<p>pathname 需要创建的文件名或目录名</p>
<p>mode文件权限</p>
<p><strong>#include</strong> &lt;stdio.h&gt;</p>
<p><strong>#include</strong> &lt;sys&#x2F;types.h&gt;</p>
<p><strong>#include</strong> &lt;sys&#x2F;stat.h&gt;</p>
<p><strong>#include</strong> &lt;fcntl.h&gt;</p>
<p><strong>#include</strong> &lt;errno.h&gt;							&#x2F;<em>包含头文件。</em>&#x2F;</p>
<p><strong>#include</strong> &lt;unistd.h&gt;&#x2F;&#x2F;rmdir</p>
<p><strong>#include</strong> &lt;string.h&gt;&#x2F;&#x2F;strerror</p>
<p><strong>int</strong> <strong>main</strong> ()</p>
<p>{ </p>
<p>   <strong>extern</strong> <strong>int</strong> errno;						&#x2F;<em>定义错误号。</em>&#x2F;</p>
<p>   <strong>const</strong> <strong>char</strong> *path&#x3D;”.&#x2F;tmp.txt”;</p>
<p>   <strong>if</strong>(<strong>creat</strong>(path,0766)&#x3D;&#x3D;-1)					&#x2F;<em>用creat函数创建一个文件。</em>&#x2F;</p>
<p>   {</p>
<p>​     <strong>printf</strong>(“cant’t create the file %s.\n”,path);		&#x2F;<em>不能创建文件。</em>&#x2F;</p>
<p>​     <strong>printf</strong>(“errno：%d\n”,errno);			&#x2F;<em>显示错误号。</em>&#x2F;</p>
<p>​     <strong>printf</strong>(“ERR  ：%s\n”,<strong>strerror</strong>(errno));	&#x2F;<em>显示错误信息。</em>&#x2F;</p>
<p>   }</p>
<p>   <strong>else</strong>										&#x2F;<em>另一种情况。</em>&#x2F;</p>
<p>   { </p>
<p>​      <strong>printf</strong>(“created file %s.\n”,path);	&#x2F;<em>显示创建成功。</em>&#x2F;</p>
<p>   }</p>
<p>   <strong>return</strong> 0 ;</p>
<p>} </p>
<h3 id="6-3-4-删除文件"><a href="#6-3-4-删除文件" class="headerlink" title="6.3.4 删除文件"></a>6.3.4 删除文件</h3><p>int  remove(char *pathname);</p>
<p><strong>#include</strong> &lt;stdio.h&gt;</p>
<p><strong>#include</strong> &lt;sys&#x2F;types.h&gt;</p>
<p><strong>#include</strong> &lt;sys&#x2F;stat.h&gt;</p>
<p><strong>#include</strong> &lt;fcntl.h&gt;</p>
<p><strong>#include</strong> &lt;errno.h&gt;							&#x2F;<em>包含头文件。</em>&#x2F;</p>
<p><strong>#include</strong> &lt;unistd.h&gt;&#x2F;&#x2F;rmdir</p>
<p><strong>#include</strong> &lt;string.h&gt;&#x2F;&#x2F;strerror</p>
<p><strong>int</strong> <strong>main</strong>()</p>
<p>{ </p>
<p>   <strong>extern</strong> <strong>int</strong> errno;						&#x2F;<em>定义一个错误号。</em>&#x2F;</p>
<p>   <strong>const</strong> <strong>char</strong> *path&#x3D;”.&#x2F;tmp.txt”;		&#x2F;<em>定义要删除的文件名。</em>&#x2F;</p>
<p>   <strong>if</strong>(<strong>remove</strong>(path)&#x3D;&#x3D;0)						&#x2F;<em>删除文件。</em>&#x2F;</p>
<p>   {</p>
<p>​      <strong>printf</strong>(“Deleted file %s.\n”,path);	&#x2F;<em>显示删除成功。</em>&#x2F;</p>
<p>   }</p>
<p>   <strong>else</strong>										&#x2F;<em>另一种情况。</em>&#x2F;</p>
<p>   {</p>
<p>​      <strong>printf</strong>(“cant’t delete the file %s.\n”,path);&#x2F;<em>显示删除失败。</em>&#x2F;</p>
<p>​      <strong>printf</strong>(“errno：%d\n”,errno);			&#x2F;<em>显示错误号。</em>&#x2F;</p>
<p>​      <strong>printf</strong>(“ERR  ：%s\n”,<strong>strerror</strong>(errno));	&#x2F;<em>显示错误信息。</em>&#x2F;</p>
<p>   }</p>
<p>   <strong>return</strong> 0;</p>
<p>} </p>
<h3 id="6-3-5-建立临时文件函数mkstemp"><a href="#6-3-5-建立临时文件函数mkstemp" class="headerlink" title="6.3.5 建立临时文件函数mkstemp()"></a>6.3.5 建立临时文件函数mkstemp()</h3><p>int  mkstemp(char  *template);</p>
<p>参数template表示需要建立临时文件的文件名字符串。文件名字符串中最后6个字符必须是XXXXXX。mkstemp()函数会以可读写模式和0600权限来打开该文件，如果文件不存在，则会建立这个文件，返回值是打开文件的编号；如果文件建立不成功，则返回-1。</p>
<p>另外参数template字符串必须声明为数组。char  template[]&#x3D;”template-XXXXXX”;</p>
<p> 不能使用char *template &#x3D;”template-XXXXXX”;</p>
<h3 id="6-3-6-文件打开关闭见前面"><a href="#6-3-6-文件打开关闭见前面" class="headerlink" title="6.3.6 文件打开关闭见前面"></a>6.3.6 文件打开关闭见前面</h3><h2 id="6-4-串口通信"><a href="#6-4-串口通信" class="headerlink" title="6.4 串口通信"></a>6.4 <a href="">串口通信</a></h2><p>数据通信方式：串行通信、并行通信</p>
<p>串行通信：利用一条传输线将数据以比特位为单位顺序传送。</p>
<p>并行通信：利用多条数据传输线将一个字数据的各比特位同时传送。</p>
<h3 id="6-4-1-虚拟机虚拟串口设置"><a href="#6-4-1-虚拟机虚拟串口设置" class="headerlink" title="6.4.1 虚拟机虚拟串口设置"></a>6.4.1 虚拟机虚拟串口设置</h3><p>① 在关机情况下，设置</p>
<h3 id="6-4-2-串口设置"><a href="#6-4-2-串口设置" class="headerlink" title="6.4.2 串口设置"></a>6.4.2 串口设置</h3><p>options.c_cc[VTIME] &#x3D; 10; &#x2F;&#x2F;单位百毫秒</p>
<p>options.c_cc[VMIN] &#x3D; 4;</p>
<p>&#x2F;<em>设置等待时间和最小接收字符</em>&#x2F;</p>
<p>​	new_cfg.c_cc[VTIME]  &#x3D; 50;</p>
<p>​	new_cfg.c_cc[VMIN] &#x3D; 0;</p>
<h2 id="6-5-Linux进程控制程序设计"><a href="#6-5-Linux进程控制程序设计" class="headerlink" title="6.5 Linux进程控制程序设计"></a>6.5 <a href="">Linux进程控制程序设计</a></h2><p>进程分为运行态、就绪态、等待态。</p>
<p>进程号：Process 	Identity		Number			PID</p>
<p>​	父进程号：Parent 	Process		Idenity	Number		PPID	</p>
<h3 id="6-5-1-系统调用函数列表"><a href="#6-5-1-系统调用函数列表" class="headerlink" title="6.5.1 系统调用函数列表"></a>6.5.1 系统调用函数列表</h3><p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps66.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps67.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps68.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps69.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps70.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps71.png" alt="img"> </p>
<h3 id="6-5-2-基本概念"><a href="#6-5-2-基本概念" class="headerlink" title="6.5.2 基本概念"></a>6.5.2 基本概念</h3><h4 id="6-5-2-1-进程"><a href="#6-5-2-1-进程" class="headerlink" title="6.5.2.1 进程"></a>6.5.2.1 进程</h4><p>进程是一个具有一定独立功能的程序的一次运行活动。</p>
<h4 id="6-5-2-2-临界资源"><a href="#6-5-2-2-临界资源" class="headerlink" title="6.5.2.2 临界资源"></a>6.5.2.2 临界资源</h4><p>操作系统中将一次只允许一个程序访问的资源称为临界资源。</p>
<h4 id="6-5-2-3-临界区"><a href="#6-5-2-3-临界区" class="headerlink" title="6.5.2.3 临界区"></a>6.5.2.3 临界区</h4><p>进程中访问临界资源的那段程序代码称为临界区。为实现对临界资源的互斥访问，应保证诸程互斥地入各自的临界区。</p>
<h4 id="6-5-2-4-进程同步"><a href="#6-5-2-4-进程同步" class="headerlink" title="6.5.2.4 进程同步"></a>6.5.2.4 进程同步</h4><p>一组并发进程按一定的顺序执行的过程称为进程间的同步。具有同步关系的一组并发进程称为合作进程，合作进程间互相发送的信号称为消息或事件。</p>
<h4 id="6-5-2-5-死锁"><a href="#6-5-2-5-死锁" class="headerlink" title="6.5.2.5 死锁"></a>6.5.2.5 死锁</h4><p>多个进程因竞争资源而形成一种僵局，若无外力作用，这些进程都将永远不能再向前推进。</p>
<h3 id="6-5-3-进程调度"><a href="#6-5-3-进程调度" class="headerlink" title="6.5.3 进程调度"></a>6.5.3 进程调度</h3><p>按一定算法，从一组待运行的进程中选出一个来占有CPU运行。</p>
<h4 id="6-5-3-1-调度方式："><a href="#6-5-3-1-调度方式：" class="headerlink" title="6.5.3.1 调度方式："></a>6.5.3.1 调度方式：</h4><p>• 抢占式</p>
<p>• 非抢占式</p>
<h4 id="6-5-3-2-调度算法"><a href="#6-5-3-2-调度算法" class="headerlink" title="6.5.3.2 调度算法"></a>6.5.3.2 调度算法</h4><p>l 先来先服务调度算法</p>
<p>l 短进程优先调度算法</p>
<p>l 高优先级优先调度算法</p>
<p>l 时间片轮转法</p>
<h3 id="6-5-4-获取ID"><a href="#6-5-4-获取ID" class="headerlink" title="6.5.4 获取ID"></a>6.5.4 获取ID</h3><p>头文件：</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>获取本进程ID</p>
<p>vpid_t getpid(void) </p>
<p>获取父程ID</p>
<p>vpid_t getppid(void)</p>
<p>例：getpid.c(演示)</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>#include &lt;stdlib.h&gt;</em>**</p>
<p><em>int main(void)</em>**</p>
<p><em>{</em>**</p>
<p><em>printf( “PID &#x3D; %d\n”, getpid() );</em>**</p>
<p><em>printf( “PPID &#x3D; %d\n”, getppid() );</em>**</p>
<p><em>return 0;</em>**</p>
<p><em>}</em>**</p>
<h3 id="6-5-5-进程创建-fork"><a href="#6-5-5-进程创建-fork" class="headerlink" title="6.5.5 进程创建-fork"></a>6.5.5 进程创建-fork</h3><p>#include &lt;unistd.h&gt;</p>
<p>pid_t fork(void)</p>
<p>功能：创建子程</p>
<p>fork的奇妙之处在于它被调用一次，却返回两次，它可能有三种不同的返回值：</p>
<p>\1. 在父程中，fork返回新创建的子程的PID；</p>
<p>\2. 在子程中，fork返回0；</p>
<p>\3. 如果出现错误，fork返回一个负值</p>
<p><em>例：fork1.c（演示）</em>**</p>
<p><em>#include &lt;sys&#x2F;types.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>main()</em>**</p>
<p><em>{</em>**</p>
<p><em>pid_t pid;</em>**</p>
<p><em>&#x2F;*此时仅有一个进程</em>&#x2F;***</p>
<p><em>pid&#x3D;fork();</em>**</p>
<p><em>&#x2F;*此时已经有两个进程在同时运行</em>&#x2F;***</p>
<p><em>if(pid&lt;0)</em>**</p>
<p><em>printf(“errorin fork!”);</em>**</p>
<p><em>elseif(pid&#x3D;&#x3D;0)</em>**</p>
<p><em>printf(“I am the child process, IDis %d\n”,getpid());</em>**</p>
<p><em>else</em>**</p>
<p><em>printf(“I am the parent process,IDis  %d\n”,getpid());</em>**</p>
<p><em>}</em>**</p>
<p>在pid&#x3D;fork()之前，只有一个进程在执行，但在这条语句执行之后，就变成两个进程在执行了，这两个进程的共享代码段，将要执行的下一条语句都是if(pid&#x3D;&#x3D;0)。 两个程中，原来就存在的那个进程被称作“父程”，新出现的那个程被称作“子程”，父子进程的区别在于进程标识符（PID）不同。</p>
<h3 id="6-5-6-进程创建-vfork"><a href="#6-5-6-进程创建-vfork" class="headerlink" title="6.5.6 进程创建-vfork"></a>6.5.6 进程创建-vfork</h3><p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t vfork(void)     功能：创建子进程。</p>
<h3 id="6-5-7-fork-x2F-vfork区别："><a href="#6-5-7-fork-x2F-vfork区别：" class="headerlink" title="6.5.7 fork&#x2F; vfork区别："></a>6.5.7 fork&#x2F; vfork区别：</h3><p>\1.  fork:子程拷贝父进程的数据段</p>
<p>vfork:子程与父程共享数据段</p>
<p>\2.  fork:父、子进程的执行次序不确定</p>
<p>vfork:子程先运行，父程后运行</p>
<h3 id="6-5-8-exec函数族"><a href="#6-5-8-exec函数族" class="headerlink" title="6.5.8 exec函数族"></a>6.5.8 exec函数族</h3><p>exec用被执行的程序替换调用它的程序。</p>
<p>区别：</p>
<p>fork创建一个新的进程，产生一个新的PID。</p>
<p>exec启动一个新程序，替换原有的程，因此进程的PID不会改变。</p>
<p>#include&lt;unistd.h&gt;</p>
<p>int execl(constchar* path,const char * arg1,….)</p>
<p>参数：path：被执行程序名（含完整路径）。</p>
<p>arg1 – argn: 被执行程序所需的命令行参数，含程序名。以空指针（NULL）结束。</p>
<p>#include&lt;unistd.h&gt;</p>
<p>int execlp(const char * path,const char * arg1, …)</p>
<p>参数：</p>
<p>path：被执行程序名（不含路径，将从path环境变量中查找该程序）。</p>
<p>arg1 – argn: 被执行程序所需的命令行参数，含程序名。以空指针（NULL）结束。</p>
<p>#include&lt;unistd.h&gt;</p>
<p>int execv(const char * path, char* const argv[ ])</p>
<p>参数：</p>
<p>path：被执行程序名（含完整路径）。</p>
<p>argv[]: 被执行程序所需的命令行参数数组。</p>
<p>例：execv.c （演示）</p>
<p>#include &lt;unistd.h&gt;</p>
<p>main()</p>
<p>{char * argv[ ]&#x3D;{“ls”,”-al”,”&#x2F;etc&#x2F;passwd”,(char*)0};</p>
<p>execv(“&#x2F;bin&#x2F;ls”,argv);}</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>int system(constchar*string)</p>
<p>功能：调用fork产生子程，由子进程来调用&#x2F;bin&#x2F;sh -c string来执行参数string所代表的命令。</p>
<h3 id="6-5-9-进程等待"><a href="#6-5-9-进程等待" class="headerlink" title="6.5.9 进程等待"></a>6.5.9 进程等待</h3><p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p>pid_t wait (int *status)</p>
<p>功能：阻塞该进程，直到其某个子进程退出。</p>
<p>pid_t waitpid(pid_t pid,int *status,int options);</p>
<p>status: 子进程退出状态</p>
<p><em>例：wait.c(演示)</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;types.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;wait.h&gt;</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;stdlib.h&gt;</em>**</p>
<p><em>#include &lt;errno.h&gt;</em>**</p>
<p><em>#include &lt;math.h&gt;</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>int main(void)</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>   <strong>pid_t child;</strong>*</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>   <strong>&#x2F;* 创建子进程 <em>&#x2F;</em></strong></p>
</li>
<li><p>   <strong>if((child&#x3D;fork())&#x3D;&#x3D;-1)</strong>*</p>
</li>
<li><p>   <strong>{</strong>*</p>
</li>
<li><p>   **	<strong>printf(“Fork Error : %s\n”, strerror(errno));</strong>*</p>
</li>
<li><p>   **	<strong>exit(1);</strong>*</p>
</li>
<li><p>   <strong>}</strong>*</p>
</li>
<li><p>   **else ***</p>
</li>
<li><p>   **	<strong>if(child&#x3D;&#x3D;0) &#x2F;&#x2F; 子进程</strong>*</p>
</li>
<li><p>   **	<strong>{</strong>*</p>
</li>
<li><p>   **	**	<strong>printf(“the child process is run\n”);</strong>*</p>
</li>
<li><p>   **	**	<strong>sleep(1);  &#x2F;&#x2F;子进程睡眠一秒，但并没有去运行父进程</strong>*</p>
</li>
<li><p>   **	**	<strong>printf(“I am the child: %d\n”, getpid());</strong>*</p>
</li>
<li><p>   **	**	<strong>exit(0);</strong>*</p>
</li>
<li><p>   **	<strong>}</strong>*</p>
</li>
<li><p>   **	<strong>else        &#x2F;&#x2F;父进程</strong>*</p>
</li>
<li><p>   **	<strong>{</strong>*</p>
</li>
<li><p>   **	**	<strong>wait(NULL); &#x2F;&#x2F;等到子进程退出，父进程才会运行</strong>*</p>
</li>
<li><p>   **	**	<strong>printf(“the father process is run\n”);</strong>*</p>
</li>
<li><p>   **	**	<strong>printf(“I am the father:%d\n”,getpid());</strong>*</p>
</li>
<li><p>   **	**	<strong>return 0;</strong>*</p>
</li>
<li><p>   **	<strong>}</strong>*</p>
</li>
</ul>
<p><em>}</em>*	***</p>
<h3 id="6-5-10-进程终止"><a href="#6-5-10-进程终止" class="headerlink" title="6.5.10 进程终止"></a>6.5.10 进程终止</h3><p><strong>#include &lt;stdlib.h&gt;</strong>****</p>
<p><strong>void exit(int status);</strong>****</p>
<h3 id="6-5-11-守护进程"><a href="#6-5-11-守护进程" class="headerlink" title="6.5.11 守护进程"></a>6.5.11 守护进程</h3><h4 id="6-5-11-1-步骤"><a href="#6-5-11-1-步骤" class="headerlink" title="6.5.11.1 步骤"></a>6.5.11.1 步骤</h4><p>①创建子进程，父进程退出</p>
<p><em>pid&#x3D;fork();</em>**</p>
<p><em>if(pid&gt;0)</em>**</p>
<p><em>{</em>**</p>
<p><em>exit(0);&#x2F;&#x2F;父进程退出</em>**</p>
<p><em>}</em>**</p>
<p>②在子进程中创建新会话</p>
<ul>
<li><p>   <strong>#include&lt;sys&#x2F;types.h&gt;</strong>*</p>
</li>
<li><p>   <strong>#include&lt;unistd.h&gt;</strong>*</p>
</li>
<li><p>   <strong>pid_t setsid(void);</strong>*</p>
</li>
<li><p>   <strong>成功返回进程组id</strong>*</p>
</li>
</ul>
<p><em>失败返回-1；</em>**</p>
<p>③改变当前目录为根目录</p>
<p>④重设文件权限掩码</p>
<p>⑤关闭文件描述符</p>
<h4 id="6-5-11-2-实例"><a href="#6-5-11-2-实例" class="headerlink" title="6.5.11.2 实例"></a>6.5.11.2 实例</h4><h4 id="6-5-11-3-守护进程的出错处理"><a href="#6-5-11-3-守护进程的出错处理" class="headerlink" title="6.5.11.3 守护进程的出错处理"></a>6.5.11.3 守护进程的出错处理</h4><h2 id="6-6-Linux进程间通信程序设计"><a href="#6-6-Linux进程间通信程序设计" class="headerlink" title="6.6 Linux进程间通信程序设计"></a>6.6 <a href="">L</a>inux进程间通信程序设计</h2><h3 id="6-6-1-为什么进程间需要通信？"><a href="#6-6-1-为什么进程间需要通信？" class="headerlink" title="6.6.1 为什么进程间需要通信？"></a>6.6.1 为什么进程间需要通信？</h3><p>1、数据传输</p>
<p>一个进程需要将它的数据发送给另一个进程。</p>
<p>2、资源共享</p>
<p>多个进程之间共享同样的资源。</p>
<p>3、通知事件</p>
<p>一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件。</p>
<p>4、进程控制</p>
<p>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。</p>
<p>POSIX(Portable Operating System Interface)表示可移植操作系统接口。电气和电子工程师协会（Institute of Electrical and Electronics Engineers，IEEE）最初开发 POSIX 准，是为了提高 UNIX 环境下应用程序的可移植性。</p>
<h3 id="6-6-2-Linux使用的进程间通信方式包括："><a href="#6-6-2-Linux使用的进程间通信方式包括：" class="headerlink" title="6.6.2 Linux使用的进程间通信方式包括："></a>6.6.2 Linux使用的进程间通信方式包括：</h3><p>1、管道（pipe）和有名管道（FIFO）</p>
<p>2、信号（signal）</p>
<p>3、消息队列</p>
<p>4、共享内存</p>
<p>5、信号量</p>
<p>6、套接字（socket）</p>
<h3 id="6-6-3-管道通信"><a href="#6-6-3-管道通信" class="headerlink" title="6.6.3 管道通信"></a>6.6.3 管道通信</h3><p>什么是管道？</p>
<p>管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起。一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出数据。</p>
<p>数据被一个进程读出后，将被从管道中删除，其它读进程将不能再读到这些数据。管道提供了简单的流控制机制，进程试图读空管道时，进程将阻塞。同样，管道已经满时，进程再试图向管道写入数据，进程将阻塞。</p>
<h4 id="6-6-3-1-管道创建"><a href="#6-6-3-1-管道创建" class="headerlink" title="6.6.3.1 管道创建"></a>6.6.3.1 管道创建</h4><p>管道包括无名管道和有名管道两种，前者用于父进程和子进程间的通信，后者可用于运行于同一系统中的任意两个进程间的通信。</p>
<p>无名管道由pipe（）函数创建：</p>
<p>int pipe(int filedis[2])；</p>
<p>当一个管道建立时，它会创建两个文件描述符：filedis[0] 用于读管道， filedis[1] 用于写管道。</p>
<h4 id="6-6-3-2-管道关闭"><a href="#6-6-3-2-管道关闭" class="headerlink" title="6.6.3.2 管道关闭"></a>6.6.3.2 管道关闭</h4><p>关闭管道只需将这两个文件描述符关闭即可，可以使用普通的close函数逐个关闭。</p>
<p><em>例</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>#include &lt;errno.h&gt;</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;stdlib.h&gt;</em>**</p>
<p><em>int main()</em>**</p>
<p><em>{</em>**</p>
<p><em>int pipe_fd[2];</em>**</p>
<p><em>if(pipe(pipe_fd)&lt;0)</em>**</p>
<p><em>{</em>**</p>
<p><em>printf(“pipe create error\n”);</em>**</p>
<p><em>return -1;</em>**</p>
<p><em>}</em>**</p>
<p>*else ***</p>
<p><em>printf(“pipe create success\n”);</em>**</p>
<p><em>close(pipe_fd[0]);</em>**</p>
<p><em>close(pipe_fd[1]);</em>**</p>
<p><em>}</em>**</p>
<h4 id="6-6-3-3-管道读写"><a href="#6-6-3-3-管道读写" class="headerlink" title="6.6.3.3 管道读写"></a>6.6.3.3 管道读写</h4><p>管道用于不同进程间通信。通常先创建一个管道，再通过fork函数创建一个子进程，该子进程会继承父进程所创建的管道。</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps72.jpg" alt="img">* *</p>
<p>必须在系统调用fork()前调用pipe()，否则子进程将不会继承文件描述符。</p>
<p>例：管道读写pipe_rw.c</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;types.h&gt;</em>**</p>
<p><em>#include &lt;errno.h&gt;</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;string.h&gt;</em>**</p>
<p><em>#include &lt;stdlib.h&gt;</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>int main()</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>   <strong>int pipe_fd[2];</strong>*</p>
</li>
<li><p>   <strong>pid_t pid;</strong>*</p>
</li>
<li><p>   <strong>char buf_r[100];</strong>*</p>
</li>
<li><p>   <strong>char* p_wbuf;</strong>*</p>
</li>
<li><p>   <strong>int r_num;</strong>*</p>
</li>
</ul>
<hr>
<ul>
<li>   <strong>memset(buf_r,0,sizeof(buf_r));</strong>*</li>
</ul>
<hr>
<ul>
<li><p>   <em><em>&#x2F;*创建管道</em>&#x2F;</em>**</p>
</li>
<li><p>   <strong>if(pipe(pipe_fd)&lt;0)</strong>*</p>
</li>
<li><p>   <strong>{</strong>*</p>
</li>
<li><p>   **	<strong>printf(“pipe create error\n”);</strong>*</p>
</li>
<li><p>   **	<strong>return -1;</strong>*</p>
</li>
<li><p>   <strong>}</strong>*</p>
</li>
</ul>
<hr>
<ul>
<li><p>   <em><em>&#x2F;*创建子进程</em>&#x2F;</em>**</p>
</li>
<li><p>   <strong>if((pid&#x3D;fork())&#x3D;&#x3D;0)  &#x2F;&#x2F;子进程执行序列</strong>*</p>
</li>
<li><p>   <strong>{</strong>*</p>
</li>
<li><p>   **	<strong>printf(“\n”);</strong>*</p>
</li>
<li><p>   **	<strong>close(pipe_fd[1]);&#x2F;&#x2F;子进程先关闭了管道的写端</strong>*</p>
</li>
<li><p>   **	<em><em>sleep(2); &#x2F;*让父进程先运行，这样父进程先写子进程才有内容读</em>&#x2F;</em>**</p>
</li>
<li><p>   **	<strong>if((r_num&#x3D;read(pipe_fd[0],buf_r,100))&gt;0)</strong>*</p>
</li>
<li><p>   **	<strong>{</strong>*</p>
</li>
<li><p>   **	**	<strong>printf(“%d numbers read from the pipe is %s\n”,r_num,buf_r);</strong>*</p>
</li>
<li><p>   **	<strong>}</strong>	***</p>
</li>
<li><p>   **	<strong>close(pipe_fd[0]);</strong>*</p>
</li>
<li><p>   **	<strong>exit(0);</strong>*</p>
</li>
<li><p>**	<strong>}</strong>*</p>
</li>
<li><p>   <strong>else if(pid&gt;0) &#x2F;&#x2F;父进程执行序列</strong>*</p>
</li>
<li><p>   <strong>{</strong>*</p>
</li>
<li><p>   **	<strong>close(pipe_fd[0]); &#x2F;&#x2F;父进程先关闭了管道的读端</strong>*</p>
</li>
<li><p>   **	<strong>if(write(pipe_fd[1],”Hello”,5)!&#x3D;-1)</strong>*</p>
</li>
<li><p>   **	**	<strong>printf(“parent write1 Hello!\n”);</strong>*</p>
</li>
<li><p>   **	<strong>if(write(pipe_fd[1],” Pipe”,5)!&#x3D;-1)</strong>*</p>
</li>
<li><p>   **	**	<strong>printf(“parent write2 Pipe!\n”);</strong>*</p>
</li>
<li><p>   **	<strong>close(pipe_fd[1]);</strong>*</p>
</li>
<li><p>   **	<em><em>waitpid(pid,NULL,0); &#x2F;*等待子进程结束</em>&#x2F;</em>**</p>
</li>
<li><p>   **	<strong>exit(0);</strong>*</p>
</li>
<li><p>   <strong>}</strong>*</p>
</li>
<li><p>   <strong>return 0;</strong>*</p>
</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="6-6-4-命名管道（FIFO）"><a href="#6-6-4-命名管道（FIFO）" class="headerlink" title="6.6.4 命名管道（FIFO）"></a>6.6.4 命名管道（FIFO）</h3><p>命名管道和无名管道基本相同，但也有不同点：无名管道只能由父子进程使用；但是通过命名管道，不相关的进程也能交换数据。</p>
<h4 id="6-6-4-1-创建"><a href="#6-6-4-1-创建" class="headerlink" title="6.6.4.1 创建"></a>6.6.4.1 创建</h4><p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>int mkfifo(const char * pathname, mode_t mode)</p>
<p>pathname：FIFO文件名</p>
<p>mode：属性（见文件操作章节）</p>
<p>一旦创建了一个FIFO，就可用open打开它，一般的文件访问函数（close、read、write等）都可用于FIFO。</p>
<h4 id="6-6-4-2-操作"><a href="#6-6-4-2-操作" class="headerlink" title="6.6.4.2 操作"></a>6.6.4.2 操作</h4><p>当打开FIFO时，非阻塞标志（O_NONBLOCK）将对以后的读写产生如下影响：</p>
<p>1、没有使用O_NONBLOCK：访问要求无法满足时进程将阻塞。如试图读取空的FIFO，将导致进程阻塞。</p>
<p>2、使用O_NONBLOCK：访问要求无法满足时不阻塞，立刻出错返回，errno是ENXIO。</p>
<p>例：fifo_write.c</p>
<h3 id="6-6-5-信号通信"><a href="#6-6-5-信号通信" class="headerlink" title="6.6.5 信号通信"></a>6.6.5 信号通信</h3><p>信号(signal)机制是Unix系统中最为古老的进程间通信机制，很多条件可以产生一个信号：</p>
<p>1、当用户按某些按键时，产生信号。</p>
<p>2、硬件异常产生信号：除数为0、无效的存储访问等等。这些情况通常由硬件检测到，将其通知内核，然后内核产生适当的信号通知进程，例如，内核对正访问一个无效存储区的进程产生一个SIGSEGV信号。</p>
<p>3、进程用kill函数将信号发送给另一个进程。</p>
<p>4、用户可用kill命令将信号发送给其他进程。</p>
<p>下面是几种常见的信号：</p>
<p>§ SIGHUP：从终端上发出的结束信号</p>
<p>§ SIGINT：来自键盘的中断信（Ctrl-C）</p>
<p>§ SIGKILL：该信号结束接收信号的进程</p>
<p>§ SIGTERM：kill 命令发出的信号</p>
<p>§ SIGCHLD：标识子进程停止或结束的信号</p>
<p>§ SIGSTOP：来自键盘（Ctrl-Z）或调试程序的停止执行信号</p>
<h4 id="6-6-5-1-信号处理"><a href="#6-6-5-1-信号处理" class="headerlink" title="6.6.5.1 信号处理"></a>6.6.5.1 信号处理</h4><p>1、忽略此信号</p>
<p>大多数信号都按照这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL和SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供了一种终止或停止进程的方法。</p>
<p>2、执行用户希望的动作</p>
<p>通知内核在某种信发生时，调用一个用户函数。在用户函数中，执行用户希望的处理。</p>
<p>3、执行系统默认动作</p>
<p>对大多数信号的系统默认动作是终止该进程。</p>
<h4 id="6-6-5-2-信号发送"><a href="#6-6-5-2-信号发送" class="headerlink" title="6.6.5.2 信号发送"></a>6.6.5.2 信号发送</h4><p>发送信号的主要函数有 kill和raise。</p>
<p>区别：Kill既可以向自身发送信号，也可以向其他进程发送信号。与kill函数不同的是，raise函数是向进程自身发送信号。</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>int kill(pid_t pid, int signo)</p>
<p>int raise(int signo)</p>
<p>kill的pid参数有四种不同的情况：</p>
<p>1、pid&gt;0 </p>
<p>将信号发送给进程ID为pid的进程。</p>
<p>2、pid &#x3D;&#x3D;0</p>
<p>将信号发送给同组的进程。</p>
<p>3、pid &lt; 0 </p>
<p>将信号发送给其进程组ID等于pid绝对值的进程。</p>
<p>4、pid &#x3D;&#x3D;－1 </p>
<p>将信号发送给所有进程。</p>
<h4 id="6-6-5-3-Alarm"><a href="#6-6-5-3-Alarm" class="headerlink" title="6.6.5.3 Alarm"></a>6.6.5.3 Alarm</h4><p>使用alarm函数可以设置一个时间值(闹钟时间)，当所设置的时间到了时，产生SIGALRM信号。如果不捕捉此信号，则默认动作是终止该进程。</p>
<p>#include &lt;unistd.h&gt;</p>
<p>unsignedint alarm(unsignedint seconds)</p>
<p>Seconds：经过了指定的seconds秒后会产生信号SIGALRM。</p>
<p>每个进程只能有一个闹钟时间。如果在调用alarm时，以前已为该进程设置过闹钟时间，而且它还没有超时，以前登记的闹钟时间则被新值代换。</p>
<p>如果有以前登记的尚未超过的闹钟时间，而这次seconds值是0，则表示取消以前的闹钟。</p>
<h4 id="6-6-5-4-pause"><a href="#6-6-5-4-pause" class="headerlink" title="6.6.5.4 pause"></a>6.6.5.4 pause</h4><p>pause函数使调用进程挂起直至捕捉到一个信号。</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int pause(void)</p>
<p>只有执行了一个信号处理函数后，挂起才结束。</p>
<h4 id="6-6-5-5-信号的处理"><a href="#6-6-5-5-信号的处理" class="headerlink" title="6.6.5.5 信号的处理"></a>6.6.5.5 信号的处理</h4><p>当系统捕捉到某个信时，可以忽略该信号或是使用指定的处理函数来处理该信号，或者使用系统默认的方式。</p>
<p>信号处理的主要方法有两种，一种是使用简单的signal函数，另一种是使用信号集函数组。</p>
<h5 id="6-6-5-5-1-signal"><a href="#6-6-5-5-1-signal" class="headerlink" title="6.6.5.5.1 signal"></a>6.6.5.5.1 signal</h5><p>#include &lt;signal.h&gt;</p>
<p>void (*signal (int signo, void (*func)(int)))(int)</p>
<p>如何理解？</p>
<p>typedef void (*sighandler_t)(int)</p>
<p>sighandler_t signal(int signum, sighandler_thandler))</p>
<p>Func可能的值是：</p>
<p>1、SIG_IGN：忽略此信号</p>
<p>2、SIG_DFL: 按系统默认方式处理</p>
<p>3、信号处理函数名：使用该函数处理</p>
<p>mysignal.c</p>
<p><em>#include &lt;signal.h&gt;</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;stdlib.h&gt;</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>void my_func(int sign_no)</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>   <strong>if(sign_no&#x3D;&#x3D;SIGINT)</strong>*</p>
</li>
<li><p>   **	<strong>printf(“I have get SIGINT\n”);</strong>*</p>
</li>
<li><p>   <strong>else if(sign_no&#x3D;&#x3D;SIGQUIT)</strong>*</p>
</li>
<li><p>   **	<strong>printf(“I have get SIGQUIT\n”);</strong>*</p>
</li>
</ul>
<p><em>}</em>**</p>
<p><em>int main()</em>**</p>
<p><em>{</em>**</p>
<ul>
<li>   <strong>printf(“Waiting for signal SIGINT or SIGQUIT \n “);</strong>*</li>
</ul>
<hr>
<ul>
<li><p>   <em><em>&#x2F;*注册信号处理函数</em>&#x2F;</em>**</p>
</li>
<li><p>   <strong>signal(SIGINT, my_func);</strong>*</p>
</li>
<li><p>   <strong>signal(SIGQUIT, my_func);</strong>*</p>
</li>
</ul>
<hr>
<ul>
<li><p>   <strong>pause();</strong>*</p>
</li>
<li><p>   <strong>exit(0);</strong>*</p>
</li>
</ul>
<p><em>}</em>**</p>
<h3 id="6-6-6-共享内存"><a href="#6-6-6-共享内存" class="headerlink" title="6.6.6 共享内存"></a>6.6.6 共享内存</h3><p>共享内存实现分为两个步骤:</p>
<p>一、创建共享内存，使用shmget函数。</p>
<p>二、映射共享内存，将这段创建的共享内存映射到具体的进程空间去，使用shmat函数。</p>
<h4 id="6-6-6-1-创建"><a href="#6-6-6-1-创建" class="headerlink" title="6.6.6.1 创建"></a>6.6.6.1 创建</h4><p>int shmget ( key_t key, int size, int shmflg)</p>
<p>key标识共享内存的键值: 0&#x2F;IPC_PRIVATE。 当key的取值为IPC_PRIVATE，则函数shmget()将创建一块新的共享内存；如果key的取值为0，而参数shmflg中又设置IPC_PRIVATE这个标志，则同样会创建一块新的共享内存。</p>
<p>返回值：如果成功，返回共享内存标识符；如果失败，返回-1。</p>
<h4 id="6-6-6-2-映射"><a href="#6-6-6-2-映射" class="headerlink" title="6.6.6.2 映射"></a>6.6.6.2 映射</h4><p>int shmat (int shmid, char *shmaddr, int flag)</p>
<p>参数：</p>
<p>shmid：shmget函数返回的共享存储标识符</p>
<p>flag：决定以什么方式来确定映射的地址（通常为0）</p>
<p>返回值：如果成功，则返回共享内存映射到进程中的地址；如果失败，则返回-1。</p>
<p>当一个进程不再需要共享内存时，需要把它从进程地址空间中脱离。</p>
<p>intshmdt (char *shmaddr)</p>
<p>shmem.c</p>
<p><em>#include &lt;stdlib.h&gt;</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;string.h&gt;</em>**</p>
<p><em>#include &lt;errno.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;stat.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;types.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;ipc.h&gt;</em>**</p>
<p><em>#include &lt;sys&#x2F;shm.h&gt;</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>#define PERM S_IRUSR|S_IWUSR</em>**</p>
<p><em>&#x2F;* 共享内存 <em>&#x2F;</em></em>*</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p>*int main(int argc,char **argv) ***</p>
<p>*{ ***</p>
<ul>
<li><p>   **int shmid; ***</p>
</li>
<li><p>   **char *p_addr,*c_addr; ***</p>
</li>
</ul>
<hr>
<ul>
<li><p>   **if(argc!&#x3D;2) ***</p>
</li>
<li><p>   **{ ***</p>
</li>
<li><p>   **	**fprintf(stderr,”Usage:%s\n\a”,argv[0]); ***</p>
</li>
<li><p>   **	**exit(1); ***</p>
</li>
<li><p>   <strong>}</strong>*</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>   **&#x2F;* 创建共享内存 <em>&#x2F;</em>*	***</p>
</li>
<li><p>   **if((shmid&#x3D;shmget(IPC_PRIVATE,1024,PERM))&#x3D;&#x3D;-1) ***</p>
</li>
<li><p>   **{ ***</p>
</li>
<li><p>   **	**fprintf(stderr,”Create Share Memory Error:%s\n\a”,strerror(errno)); ***</p>
</li>
<li><p>   **	**exit(1); ***</p>
</li>
<li><p>   **} ***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>   <strong>&#x2F;* 创建子进程 <em>&#x2F;</em></strong></p>
</li>
<li><p>   <strong>if(fork()) &#x2F;&#x2F; 父进程写</strong>*</p>
</li>
<li><p>   **{ ***</p>
</li>
<li><p>   **	**p_addr&#x3D;shmat(shmid,0,0); ***</p>
</li>
<li><p>   **	**memset(p_addr,’\0’,1024); ***</p>
</li>
<li><p>   **	<strong>strncpy(p_addr,argv[1],1024);</strong>*</p>
</li>
<li><p>   **	<strong>wait(NULL); &#x2F;&#x2F; 释放资源,不关心终止状态</strong>*</p>
</li>
<li><p>   **	**exit(0); ***</p>
</li>
<li><p>   **} ***</p>
</li>
<li><p>   <strong>else       &#x2F;&#x2F; 子进程读</strong>*</p>
</li>
<li><p>   **{ ***</p>
</li>
<li><p>   **	<strong>sleep(1); &#x2F;&#x2F; 暂停1秒</strong>	**	***</p>
</li>
<li><p>   **	**c_addr&#x3D;shmat(shmid,0,0); ***</p>
</li>
<li><p>   **	**printf(“Client get %p\n”,c_addr); ***</p>
</li>
<li><p>   **	**exit(0); ***</p>
</li>
<li><p>   **} ***</p>
</li>
</ul>
<p><em>}</em>**</p>
<h3 id="6-6-7-消息队列"><a href="#6-6-7-消息队列" class="headerlink" title="6.6.7 消息队列"></a>6.6.7 消息队列</h3><p>unix早期通信机制之一的信号能够传送的信息量有限，管道则只能传送无格式的字节流，这无疑会给应用程序开发带来不便。消息队列（也叫做报文队列）则克服了这些缺点。</p>
<p>消息队列就是一个消息的链表。可以把消息看作一个记录，具有特定的格式。进程可以向中按照一定的规则添加新消息；另一些进程则可以从消息队列中读走消息。</p>
<p>目前主要有两种类型的消息队列：POSIX消息队列以及系统V消息队列，系统V消息队列目前被大量使用。</p>
<h4 id="6-6-7-1-键值"><a href="#6-6-7-1-键值" class="headerlink" title="6.6.7.1 键值"></a>6.6.7.1 键值</h4><p>消息队列的内核持续性要求每个消息队列都在系统范围内对应唯一的键值，所以，要获得一个消息队列的描述字，必须提供该消息队列的键值。</p>
<p>#include &lt;sys&#x2F;types.h&gt; </p>
<p>#include &lt;sys&#x2F;ipc.h&gt;</p>
<p>key_t ftok (char*pathname, char proj)</p>
<p>功能：返回文件名对应的键值。</p>
<p>pathname:文件名</p>
<p>proj:项目名（不为0即可）</p>
<h4 id="6-6-7-2-打开-x2F-创建"><a href="#6-6-7-2-打开-x2F-创建" class="headerlink" title="6.6.7.2 打开&#x2F;创建"></a>6.6.7.2 打开&#x2F;创建</h4><p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;ipc.h&gt; </p>
<p>#include &lt;sys&#x2F;msg.h&gt;</p>
<p>int msgget(key_tkey, int msgflg)</p>
<p>key：键值，由ftok获得。</p>
<p>msgflg：标志位。</p>
<p>返回值：与健值key相对应的消息队列描述字。</p>
<p>IPC_CREAT</p>
<p>创建新的消息队列</p>
<p>IPC_EXCL</p>
<p>与IPC_CREAT一同使用，表示如果要创建的消息队列已经存在，则返回错误。</p>
<p>IPC_NOWAIT</p>
<p>读写消息队列要求无法得到满足时，不阻塞。</p>
<p>在以下两种情况下，将创建一个新的消息队列：</p>
<p>如果没有与健值key相对应的消息队列，并且msgflg中包含了IPC_CREAT标志位。</p>
<p>key参数为IPC_PRIVATE。</p>
<h4 id="6-6-7-3-创建"><a href="#6-6-7-3-创建" class="headerlink" title="6.6.7.3 创建"></a>6.6.7.3 创建</h4><p><em>int open_queue(key_t keyval)</em>**</p>
<p><em>{</em>**</p>
<p><em>int</em>*  <strong>qid;</strong>*</p>
<p><em>if((qid&#x3D;msgget(keyval,IPC_CREAT))&#x3D;&#x3D;-1)</em>**</p>
<p><em>{</em>**</p>
<p><em>return(-1);</em>**</p>
<p><em>}</em>**</p>
<p><em>return(qid);</em>**</p>
<p><em>}</em>**</p>
<h4 id="6-6-7-4-发送消息"><a href="#6-6-7-4-发送消息" class="headerlink" title="6.6.7.4 发送消息"></a>6.6.7.4 发送消息</h4><p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;ipc.h&gt;</p>
<p>#include &lt;sys&#x2F;msg.h&gt; </p>
<p>int msgsnd(int msqid,struct msgbuf*msgp,int msgsz,int msgflg)</p>
<p>功能：向消息队列中发送一条消息。</p>
<p>msqid</p>
<p>已打开的消息队列id</p>
<p>msgp</p>
<p>存放消息的结构</p>
<p>msgsz</p>
<p>消息数据长度</p>
<p>msgflg</p>
<p>发送标志，有意义的msgflg标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待。</p>
<p>消息格式</p>
<p>struct msgbuf </p>
<p>{</p>
<p>long mtype; &#x2F;* 消息类型 &gt; 0*&#x2F;</p>
<p>char mtext[1];  &#x2F;* 消息数据的首地址 *&#x2F;</p>
<p>};</p>
<h4 id="6-6-7-5-接收消息"><a href="#6-6-7-5-接收消息" class="headerlink" title="6.6.7.5 接收消息"></a>6.6.7.5 接收消息</h4><p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;ipc.h&gt;</p>
<p>#include &lt;sys&#x2F;msg.h&gt; </p>
<p>int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long </p>
<p>msgtyp, int msgflg)</p>
<p>功能：从msqid代表的消息队列中读取一个msgtyp类型的消息，并把消息存储在msgp指向的msgbuf结构中。在成功地读取了一条消息以后，队列中的这条消息将被删除。</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;ipc.h&gt;</p>
<p>#include &lt;sys&#x2F;msg.h&gt; </p>
<p>int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long  msgtyp, int msgflg)</p>
<p>功能：从msqid代表的消息队列中读取一个msgtyp类型的消息，并把消息存储在msgp指向的msgbuf结构中。在成功地读取了一条消息以后，队列中的这条消息将被删除。</p>
<p>int read_message(int qid,long type,struct mymsgbuf*qbuf)</p>
<p>{</p>
<p>int result,length;</p>
<p>length&#x3D;sizeof(struct mymsgbuf)-sizeof(long);</p>
<p>if((result&#x3D;msgrcv(qid,qbuf,length,type,0))&#x3D;&#x3D;-1)</p>
<p>return(-1);</p>
<p>return(result);</p>
<p>}</p>
<h3 id="6-6-8-信号量"><a href="#6-6-8-信号量" class="headerlink" title="6.6.8 信号量"></a>6.6.8 信号量</h3><p>信号量(又名：信号灯)与其他进程 间通信方式不大相同，主要用途是保护临界资源。进程可以根据它判定是否能够访问某些共享资源。除了用于访问控制外，还可用于进程同步。</p>
<h4 id="6-6-8-1-分类"><a href="#6-6-8-1-分类" class="headerlink" title="6.6.8.1 分类"></a>6.6.8.1 分类</h4><p>二值信号灯：信号灯的值只能取0或1，类似于互斥锁。 但两者有不同：信号灯强调共享资源，只要共享资源可用，其他进程同样可以修改信号灯的值；互斥锁更强调进程，占用资源的进程使用完资源后，必须由进程本身来解锁。</p>
<p>计数信号灯：信号灯的值可以取任意非负值。</p>
<h4 id="6-6-8-2-创建-x2F-打开"><a href="#6-6-8-2-创建-x2F-打开" class="headerlink" title="6.6.8.2 创建&#x2F;打开"></a>6.6.8.2 创建&#x2F;打开</h4><p>#include &lt;sys&#x2F;types.h&gt; </p>
<p>#include &lt;sys&#x2F;ipc.h&gt; </p>
<p>#include &lt;sys&#x2F;sem.h&gt; </p>
<p>int semget(key_t key,int nsems,int semflg)</p>
<p>key：键值，由ftok获得</p>
<p>nsems：指定打开或者新创建的信号灯集中将包含信号灯的数目</p>
<p>semflg：标识，同消息队列</p>
<h4 id="6-6-8-3-操作"><a href="#6-6-8-3-操作" class="headerlink" title="6.6.8.3 操作"></a>6.6.8.3 操作</h4><p>int semop(int semid, struct sembuf *sops, unsigned nsops)</p>
<p>功能：对信号量进行控制。</p>
<p>semid：信号量集的ID</p>
<p>sops：是一个操作数组，表明要进行什么操作</p>
<p>nsops：sops所指向的数组的元素个数。</p>
<p>struct sembuf{ </p>
<p>unsigned short sem_num;&#x2F;* semaphore </p>
<p>indexin array  *&#x2F; </p>
<p>short sem_op;&#x2F;* semaphore operation *&#x2F;</p>
<p>short sem_flg;&#x2F;* operation flags *&#x2F; </p>
<p>};</p>
<p>sem_num：要操作的信号量在信号量集中的编号，第一个信号的编号是0。</p>
<p>sem_op：如果其值为正数，该值会加到现有的信号量值中，通常用于释放信号量；如果sem_op的值为负数，而其绝对值又大于信号的现值，操作将会阻塞，直到信号值大于或等于sem_op的绝对值，通常用于获取信号量；如果sem_op的值为0，则操作将暂时阻塞，直到信号的值变为0。</p>
<p>Sem_flg：信号操作标志，可能的选择有两种：</p>
<p>IPC_NOWAIT:对信号的操作不能满足时，semop()不会阻塞，并立即返回，同时设定错误信息。</p>
<p>IPC_UNDO:程序结束时(不论正常或不正常)释放信量，这样做的目的在于避免程序在异常情况下结束时未将锁定的资源解锁，造成该资源永远锁定。</p>
<h4 id="6-6-8-4-Linux-进程间通信-—-信号通信"><a href="#6-6-8-4-Linux-进程间通信-—-信号通信" class="headerlink" title="6.6.8.4 Linux 进程间通信 — 信号通信"></a>6.6.8.4 Linux 进程间通信 — 信号通信</h4><p>信号  ( signal ) 机制是 UNIX 系统中最为古老的进程间通信机制，很多条件可以产生一个信号.</p>
<p><strong>信号的产生：</strong>****</p>
<p>1，当用户<strong>按下某些按键</strong>时，产生信号.</p>
<p>2，<strong>硬件异常产生信号</strong>：除数为 0 ，无效的存储访问等等.这些情况通常由硬件检测到，将其通知内核，然后内核产生适当的信号通知进程，例如，内核对正访问一个无效存储区的进程产生一个 SIGSEGV 信号.</p>
<p>3，进程用 kill 函数 将信号发送给另一个进程.</p>
<p>4，用户可用 kill 命令将信号发送给<strong>其他进程</strong>.</p>
<p><strong>信号类型 - SIGHUP SIGINT  SIGKILL  SIGTERM  SIGCHLD  SIGSTOP：</strong>****</p>
<p>​          下面是几种常见的信号：</p>
<p>​          SIGHUP ：从终端上发出的<strong>结束信号</strong>.</p>
<p>​          SIGINT   ：来自键盘的中断信号 ( ctrl + c ) .</p>
<p>​          SIGKILL ：该信号结束接收信号的进程 .</p>
<p>​          SIGTERM：kill 命令发出 的信号.</p>
<p>​          SIGCHLD：标识子进程停止或结束的信号.</p>
<p>​          SIGSTOP：来自键盘 ( **ctrl + z **) 或调试程序的停止执行信号.</p>
<p>​          <img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps73.png" alt="img"></p>
<h5 id="6-6-8-4-1-信号处理："><a href="#6-6-8-4-1-信号处理：" class="headerlink" title="6.6.8.4.1 信号处理："></a>6.6.8.4.1 信号处理：</h5><p>当某信号出现时，将按照下列三种方式中的一种进行处理.</p>
<p><strong>1，忽略此信号：</strong>大多数信号都按照这种方式进行处理，但有两种信号却决不能被忽略.它们是：SIGKILL 和 SIGSTOP . 这两种信号不能被忽略的原因是：它们向超级用户提供了一种终止或停止进程的方法.****</p>
<p><strong>2，执行用户希望的动作：</strong>通知内核在某种信号发生时，调用一个用户函数，在用户函数中，执行用户希望的处理.</p>
<p><strong>3，执行系统默认动作：</strong>对大多数信号的系统默认动作是终止该进程. </p>
<p>当系统捕捉到某个信号时，可以忽略该信号或是使用指定的处理函数来处理该信号，或者使用系统默认的方式.</p>
<p>信号处理的主要方法有两种，<strong>一种是使用简单的 signal 函数，另一个是使用信号集函数</strong>. </p>
<h5 id="6-6-8-4-2-信号发送-kill-和-raise-："><a href="#6-6-8-4-2-信号发送-kill-和-raise-：" class="headerlink" title="6.6.8.4.2 信号发送  -  kill 和 raise ："></a>6.6.8.4.2 信号发送  -  kill 和 raise ：</h5><p>信号发送的主要函数有 kill 和 raise .</p>
<p>区别：kill 既可以向自身发送信号，也可以向其他进程发送信号，与 kill 函数不同的是，raise函数是向自身发送信号.</p>
<p>函数：</p>
<p>​                    #include &lt; sys&#x2F;types.h &gt;</p>
<p>​                    #include &lt; signal.h &gt;</p>
<p>**                    int kill ( pid_t  pai, int signo )**</p>
<p>**                   int  raise ( int  signo )**</p>
<p><strong>kill 的 pid 参数有四种不同情况：</strong>****</p>
<p>​          1， pid  &gt; 0</p>
<p>​                    将信号发送给进程 ID 为 pid 的进程.</p>
<p>​          2，pid &#x3D; 0</p>
<p>​                    将信号发送给同组的进程.</p>
<p>​          3，pid &lt; 0</p>
<p>​                    将信号发送给其进程组 ID 等于 pid 绝对值的进程.</p>
<p>​          4，pid &#x3D; -1</p>
<p>​                    将信号发送给所有进程.</p>
<h5 id="6-6-8-4-3-Alarm信号闹钟-unsigned-int-alarm："><a href="#6-6-8-4-3-Alarm信号闹钟-unsigned-int-alarm：" class="headerlink" title="6.6.8.4.3 Alarm信号闹钟  unsigned int alarm："></a>6.6.8.4.3 Alarm信号闹钟  unsigned int alarm：</h5><p>使用 alarm 函数可以设置一个时间值 ( 闹钟时间 )，当所设置的时间到了时，<strong>产生 SIGALRM 信号</strong>，如果不能扑捉此信号，则默认动作是终止该进程.</p>
<p>函数：** unsigned int alarm  ( unsigned int seconds )**</p>
<p>经过了指定的 seconds 秒后会产生信号 SIGALRM.</p>
<p>每个进程只能有一个闹钟时间，如果在调用 alarm 时，以前已为该进程设置过闹钟时间，而且它还没有超时，<strong>以前等级的闹钟</strong>时间则<strong>被新值替换</strong>.</p>
<p>如果有以前登记的尚未超时的闹钟时间，而这次 seconds 值是0 ，则表示<strong>取消以前的闹钟</strong>. </p>
<h5 id="6-6-8-4-4-pause函数"><a href="#6-6-8-4-4-pause函数" class="headerlink" title="6.6.8.4.4 pause函数"></a>6.6.8.4.4 pause函数</h5><p>int   pause ( void )：</p>
<p>​          pause 函数使调用<strong>进程挂起</strong>直至<strong>捕捉到一个信号</strong>.</p>
<p>​          函数：** int   pause ( void )**</p>
<p>​          只有执行了一个信号处理函数后，挂起才结束.</p>
<h5 id="6-6-8-4-5-signal-函数"><a href="#6-6-8-4-5-signal-函数" class="headerlink" title="6.6.8.4.5 signal 函数"></a>6.6.8.4.5 signal 函数</h5><p>** void ( *signal ( int signo  ,   void ( <em>func ) ( int ) ) ) ( int )：</em>*****</p>
<p>​          #include &lt; signal.h &gt; </p>
<p>​          void ( *signal ( int signo  ,   void ( *func ) ( int ) ) <strong>) ( int )</strong></p>
<p>​          如何理解：</p>
<p>​          typedef  void  ( *sighandler_t ) ( int )</p>
<p>​          sighandler_t  signal ( int  signum , sighandler_t  handler )</p>
<p>​          Func 可能的值是：</p>
<p>​          1，SIG_IGN  ：忽略此信号.</p>
<p>​          2，SIG_DFL ：按照系统默认方式处理.</p>
<p>​          3，信号处理函数名：使用该函数处理.</p>
<p>**实例 — 小测试： ******</p>
<ol>
<li><p>#include &lt;signal.h&gt;  </p>
</li>
<li><p>#include &lt;stdio.h&gt;  </p>
</li>
<li><p>#include &lt;stdlib.h&gt;  </p>
</li>
<li></li>
<li><p>void my_func(<strong>int</strong> sign_no)  </p>
</li>
<li><p>{  </p>
</li>
<li><pre><code>if(sign_no==SIGINT)  
</code></pre>
</li>
<li><pre><code>    printf(&quot;I have get SIGINT\n&quot;);  
</code></pre>
</li>
<li><pre><code>else if(sign_no==SIGQUIT)  
</code></pre>
</li>
<li><pre><code>    printf(&quot;I have get SIGQUIT\n&quot;);  
</code></pre>
</li>
<li><p>}  </p>
</li>
<li><p><strong>int</strong> main()  </p>
</li>
<li><p>{  </p>
</li>
<li><pre><code>printf(&quot;Waiting for signal SIGINT or SIGQUIT \n &quot;);  
</code></pre>
</li>
<li></li>
<li><pre><code>/*注册信号处理函数*/  
</code></pre>
</li>
<li><pre><code>signal(SIGINT, my_func);  
</code></pre>
</li>
<li><pre><code>signal(SIGQUIT, my_func);  
</code></pre>
</li>
<li></li>
<li><pre><code>pause();  
</code></pre>
</li>
<li><pre><code>exit(0);  
</code></pre>
</li>
<li><p>}</p>
</li>
</ol>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps74.png" alt="img"> </p>
<p>#include &lt;signal.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>void my_func(int sign_no)</p>
<p>{</p>
<p>​	if(sign_no&#x3D;&#x3D;SIGINT)</p>
<p>​		printf(“I have get SIGINT\n”);</p>
<p>​	else if(sign_no&#x3D;&#x3D;SIGQUIT)</p>
<p>​		printf(“I have get SIGQUIT\n”);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>​	printf(“Waiting for signal SIGINT or SIGQUIT \n “);</p>
<p>​	</p>
<p>​	&#x2F;<em>注册信号处理函数</em>&#x2F;</p>
<p>​	signal(SIGINT, my_func);</p>
<p>​	signal(SIGQUIT, my_func);</p>
<p>​	</p>
<p>​	pause();</p>
<p>​	exit(0);</p>
<p>}</p>
<p><a target="_blank" rel="noopener" href="http://lib.csdn.net/base/softwaretest"><strong>测试</strong></a><strong>方法：</strong>在终端下将该进程运行起来，然后 进程pause 了，我们再用 kill 给进程发送信号，</p>
<p>在另一终端下ps aux  可以找到运行进程的进程号.</p>
<p>然后<strong>kill  -s  SIGQUIT  +进程号</strong>  我们可以在前一个终端下看到 I have get SIGQUIT.</p>
<p>SIGUSR1 ：</p>
<p>kill  -usr1 PID .</p>
<p><strong>实例 — 按键驱动异步通知：</strong>****</p>
<p><strong>驱动异步通知应用程序.</strong></p>
<p><strong>1，应用程序 注册信号处理函数  signal ( SIGIO ,  my_signal_fun ) ：</strong>****</p>
<ol>
<li><p>#include &lt;sys&#x2F;types.h&gt;  </p>
</li>
<li><p>#include &lt;sys&#x2F;stat.h&gt;  </p>
</li>
<li><p>#include &lt;fcntl.h&gt;  </p>
</li>
<li><p>#include &lt;stdio.h&gt;  </p>
</li>
<li><p>#include &lt;poll.h&gt;  </p>
</li>
<li><p>#include &lt;signal.h&gt;  </p>
</li>
<li><p>#include &lt;sys&#x2F;types.h&gt;  </p>
</li>
<li><p>#include &lt;unistd.h&gt;  </p>
</li>
<li><p>#include &lt;fcntl.h&gt;  </p>
</li>
<li></li>
<li><p><strong>int</strong> fd;        &#x2F;&#x2F;全局变量；  </p>
</li>
<li></li>
<li><p>&#x2F;* </p>
</li>
<li></li>
<li><p>应用程序 不会主动 的去读键值； </p>
</li>
<li><p>my_signal_fun 什么时候被调用呢? </p>
</li>
<li></li>
<li><p>在驱动程序的中断处理函数 static irqreturn_t buttons_irq(int irq, void *dev_id) 中， </p>
</li>
<li><p>有信号发送函数 kill_fasync (&amp;button_async, SIGIO, POLL_IN) ； </p>
</li>
<li><p>当有按键按下时候，就会给应用程序发送一个信号; </p>
</li>
<li><p>这个信号就会触发 应用程序 调用信号处理函数 signal(SIGIO, my_signal_fun);  </p>
</li>
<li><p>信号处理函数指向了 void my_signal_fun(int signum) 函数； </p>
</li>
<li></li>
<li><p>*&#x2F;  </p>
</li>
<li></li>
<li><p>void my_signal_fun(<strong>int</strong> signum)  </p>
</li>
<li><p>{  </p>
</li>
<li><pre><code>unsigned **char** key_val;  
</code></pre>
</li>
<li><pre><code>read(fd, &amp;key_val, 1);    //读取键值；  
</code></pre>
</li>
<li><pre><code>printf(&quot;key_val: 0x%x\n&quot;, key_val);    
</code></pre>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)  </p>
</li>
<li><p>{  </p>
</li>
<li><pre><code>**int** Oflags;  
</code></pre>
</li>
<li></li>
<li><pre><code>signal(SIGIO, my_signal_fun);   /* 应用程序注册信号处理函数 */  
</code></pre>
</li>
<li><pre><code>                //  SIGIO 表示 Io 有数据可供读取；  
</code></pre>
</li>
<li></li>
<li><pre><code>fd = open(&quot;/dev/buttons&quot;, O_RDWR | O_NONBLOCK);  
</code></pre>
</li>
<li><pre><code>if (fd &lt; 0)  
</code></pre>
</li>
<li><pre><code>&#123;  
</code></pre>
</li>
<li><pre><code>    printf(&quot;can&#39;t open!\n&quot;);  
</code></pre>
</li>
<li><pre><code>    return -1;  
</code></pre>
</li>
<li><pre><code>&#125;  
</code></pre>
</li>
<li><pre><code>                /* 驱动程序发信号 */  
</code></pre>
</li>
<li><pre><code>fcntl(fd, F_SETOWN, getpid());   /* 信号发给谁，是通过这段程序告诉内核的 */  
</code></pre>
</li>
<li><pre><code>                /* getpid() 获取应用程序PID */  
</code></pre>
</li>
<li></li>
<li><pre><code>                /* 改变 Oflags 为异步通知 FASYNC*/  
</code></pre>
</li>
<li><pre><code>Oflags = fcntl(fd, F_GETFL);    //读取 Oflags；  
</code></pre>
</li>
<li><pre><code>                //改变 Oflags；  
</code></pre>
</li>
<li><pre><code>fcntl(fd, F_SETFL, Oflags | FASYNC);  //这样，驱动程序里面的 .fasync  =  sixth_drv_fasync, 函数指针就会被调用；  
</code></pre>
</li>
<li><pre><code>                     // 改变 FASYNC标志， 最终调用到驱动的 fasync -&gt; fasync_helper   
</code></pre>
</li>
<li><pre><code>                    //来初始化/或/释放 fasync_struct；  
</code></pre>
</li>
<li><pre><code>while (1)  
</code></pre>
</li>
<li><pre><code>&#123;  
</code></pre>
</li>
<li><pre><code>    sleep(1000);  
</code></pre>
</li>
<li><pre><code>&#125;  
</code></pre>
</li>
<li></li>
<li><pre><code>return 0;  
</code></pre>
</li>
<li><p>}</p>
</li>
</ol>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps75.png" alt="img"> </p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;poll.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>int fd;        &#x2F;&#x2F;全局变量；</p>
<p>&#x2F;*</p>
<p>应用程序 不会主动 的去读键值；</p>
<p>my_signal_fun 什么时候被调用呢?</p>
<p>在驱动程序的中断处理函数 static irqreturn_t buttons_irq(int irq, void *dev_id) 中，</p>
<p>有信号发送函数 kill_fasync (&amp;button_async, SIGIO, POLL_IN) ；</p>
<p>当有按键按下时候，就会给应用程序发送一个信号;</p>
<p>这个信号就会触发 应用程序 调用信号处理函数 signal(SIGIO, my_signal_fun); </p>
<p>信号处理函数指向了 void my_signal_fun(int signum) 函数；</p>
<p>*&#x2F;</p>
<p>void my_signal_fun(int signum)</p>
<p>{</p>
<p>​	unsigned char key_val;</p>
<p>​	read(fd, &amp;key_val, 1);    &#x2F;&#x2F;读取键值；</p>
<p>​	printf(“key_val: 0x%x\n”, key_val);  </p>
<p>}</p>
<p>int main(int argc, char **argv)</p>
<p>{</p>
<p>​	int Oflags;</p>
<p>​	signal(SIGIO, my_signal_fun);   &#x2F;* 应用程序注册信号处理函数 *&#x2F;</p>
<p>​					&#x2F;&#x2F;  SIGIO 表示 Io 有数据可供读取；</p>
<p>​	</p>
<p>​	fd &#x3D; open(“&#x2F;dev&#x2F;buttons”, O_RDWR | O_NONBLOCK);</p>
<p>​	if (fd &lt; 0)</p>
<p>​	{</p>
<p>​		printf(“can’t open!\n”);</p>
<p>​		return -1;</p>
<p>​	}</p>
<p>​					&#x2F;* 驱动程序发信号 *&#x2F;</p>
<p>​	fcntl(fd, F_SETOWN, getpid());   &#x2F;* 信号发给谁，是通过这段程序告诉内核的 *&#x2F;</p>
<p>​					&#x2F;* getpid() 获取应用程序PID *&#x2F;</p>
<p>​	</p>
<p>​					&#x2F;* 改变 Oflags 为异步通知 FASYNC*&#x2F;</p>
<p>​	Oflags &#x3D; fcntl(fd, F_GETFL);    &#x2F;&#x2F;读取 Oflags；</p>
<p>​					&#x2F;&#x2F;改变 Oflags；</p>
<p>​	fcntl(fd, F_SETFL, Oflags | FASYNC);  &#x2F;&#x2F;这样，驱动程序里面的 .fasync  &#x3D;  sixth_drv_fasync, 函数指针就会被调用；</p>
<p>​					     &#x2F;&#x2F; 改变 FASYNC标志， 最终调用到驱动的 fasync -&gt; fasync_helper </p>
<p>​					    &#x2F;&#x2F;来初始化&#x2F;或&#x2F;释放 fasync_struct；</p>
<p>​	while (1)</p>
<p>​	{</p>
<p>​		sleep(1000);</p>
<p>​	}</p>
<p>​	</p>
<p>​	return 0;</p>
<p>}</p>
<p>2，谁发信号：驱动程序：</p>
<p><strong>3，发给谁：应用程序  ；  应用程序要告诉驱动程序 其PID：</strong></p>
<p>4，驱动程序怎么发信号：调用函数：kill_fasync ：</p>
<p><strong>在驱动程序开头 定义结构 fasync_struct ：</strong>****</p>
<p>static struct fasync_struct *button_async;  </p>
<p>static struct fasync_struct *button_async;</p>
<p><strong>初始化 fasync_struct 结构体 使用 fasync_helper ：</strong>****</p>
<p>在应用程序调用 .fasync  &#x3D;  sixth_drv_fasync, 时候，调用 fasync_helper 函数 来初始化  struct fasync_struct *button_async  结构体；</p>
<p>struct fasync_struct *button_async  这个结构在 发信号的时候 kill_fasync (&amp;button_async, SIGIO, POLL_IN)  能用的到；</p>
<p><strong>[cpp]</strong> <a target="_blank" rel="noopener" href="http://blog.csdn.net/yikai2009/article/details/8643818">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/yikai2009/article/details/8643818">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/yikai2009/article/details/8643818">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/yikai2009/article/details/8643818">?</a></p>
<ol>
<li><p>static <strong>int</strong> sixth_drv_fasync (<strong>int</strong> fd, struct file *filp, <strong>int</strong> on)  </p>
</li>
<li><p>{  </p>
</li>
<li><pre><code>printk(&quot;driver: sixth_drv_fasync\n&quot;);  
</code></pre>
</li>
<li><pre><code>return fasync_helper (fd, filp, on, &amp;button_async);  /* 初始化结构体 */  
</code></pre>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>static struct file_operations sencod_drv_fops &#x3D; {  </p>
</li>
<li><pre><code>.owner   =  THIS_MODULE,    /* 这是一个宏，推向编译模块时自动创建的__this_module变量 */  
</code></pre>
</li>
<li><pre><code>.open    =  sixth_drv_open,       
</code></pre>
</li>
<li><pre><code>.read    =  sixth_drv_read,      
</code></pre>
</li>
<li><pre><code>.release =  sixth_drv_close,  
</code></pre>
</li>
<li><pre><code>.poll    =  sixth_drv_poll,  
</code></pre>
</li>
<li><pre><code>.fasync  =  sixth_drv_fasync,   /****************************  FASYNC  ********************************/  
</code></pre>
</li>
<li><p>};</p>
</li>
</ol>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps76.png" alt="img"> </p>
<p>static int sixth_drv_fasync (int fd, struct file *filp, int on)</p>
<p>{</p>
<p>​	printk(“driver: sixth_drv_fasync\n”);</p>
<p>​	return fasync_helper (fd, filp, on, &amp;button_async);  &#x2F;* 初始化结构体 *&#x2F;</p>
<p>}</p>
<p>static struct file_operations sencod_drv_fops &#x3D; {</p>
<p>​    .owner   &#x3D;  THIS_MODULE,    &#x2F;* 这是一个宏，推向编译模块时自动创建的__this_module变量 *&#x2F;</p>
<p>​    .open    &#x3D;  sixth_drv_open,     </p>
<p>​	.read	 &#x3D;	sixth_drv_read,	   </p>
<p>​	.release &#x3D;  sixth_drv_close,</p>
<p>​	.poll    &#x3D;  sixth_drv_poll,</p>
<p>​	.fasync	 &#x3D;  sixth_drv_fasync,   &#x2F;****************************  FASYNC  ********************************&#x2F;</p>
<p>};</p>
<p><strong>在按键驱动 服务程序 中发送信号 kill_fasync ：</strong>****</p>
<p>kill_fasync 需要三个参数：</p>
<p>第一个：&amp;button_async 包含进程 ID ， 也就是 发给谁，</p>
<p>第二个：  发什么，发  SIGIO 这个信号，SIGIO 表示 Io 有数据可供读取；</p>
<p>第三个：POLL_IN ， 原因， 表示有数据在等待读取；</p>
<ol>
<li><p>static irqreturn_t buttons_irq(<strong>int</strong> irq, void *dev_id)  </p>
</li>
<li><p>{  </p>
</li>
<li><pre><code>struct pin_desc * pindesc = (struct pin_desc *)dev_id;  
</code></pre>
</li>
<li><pre><code>unsigned **int** pinval;  
</code></pre>
</li>
<li></li>
<li><pre><code>pinval = s3c2410_gpio_getpin(pindesc-&gt;pin);  
</code></pre>
</li>
<li></li>
<li><pre><code>if (pinval)  
</code></pre>
</li>
<li><pre><code>&#123;  
</code></pre>
</li>
<li><pre><code>    /* 松开 */  
</code></pre>
</li>
<li><pre><code>    key_val = 0x80 | pindesc-&gt;key_val;  
</code></pre>
</li>
<li><pre><code>&#125;  
</code></pre>
</li>
<li><pre><code>else  
</code></pre>
</li>
<li><pre><code>&#123;  
</code></pre>
</li>
<li><pre><code>    /* 按下 */  
</code></pre>
</li>
<li><pre><code>    key_val = pindesc-&gt;key_val;  
</code></pre>
</li>
<li><pre><code>&#125;  
</code></pre>
</li>
<li></li>
<li><pre><code>    ev_press = 1;                  /* 表示中断发生了 */  
</code></pre>
</li>
<li><pre><code>    wake_up_interruptible(&amp;button_waitq);   /* 唤醒休眠的进程 */  
</code></pre>
</li>
<li></li>
<li><pre><code>kill_fasync (&amp;button_async, SIGIO, POLL_IN);                      /********  kill_fasync 发送信号  *********/  
</code></pre>
</li>
<li></li>
<li><pre><code>return IRQ_RETVAL(IRQ_HANDLED);  
</code></pre>
</li>
<li><p>}</p>
</li>
</ol>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps77.png" alt="img"> </p>
<p>static irqreturn_t buttons_irq(int irq, void *dev_id)</p>
<p>{</p>
<p>​	struct pin_desc * pindesc &#x3D; (struct pin_desc *)dev_id;</p>
<p>​	unsigned int pinval;</p>
<p>​	</p>
<p>​	pinval &#x3D; s3c2410_gpio_getpin(pindesc-&gt;pin);</p>
<p>​	if (pinval)</p>
<p>​	{</p>
<p>​		&#x2F;* 松开 *&#x2F;</p>
<p>​		key_val &#x3D; 0x80 | pindesc-&gt;key_val;</p>
<p>​	}</p>
<p>​	else</p>
<p>​	{</p>
<p>​		&#x2F;* 按下 *&#x2F;</p>
<p>​		key_val &#x3D; pindesc-&gt;key_val;</p>
<p>​	}</p>
<p>​        ev_press &#x3D; 1;                  &#x2F;* 表示中断发生了 *&#x2F;</p>
<p>​        wake_up_interruptible(&amp;button_waitq);   &#x2F;* 唤醒休眠的进程 *&#x2F;</p>
<p>​	</p>
<p>​	kill_fasync (&amp;button_async, SIGIO, POLL_IN);                      &#x2F;********  kill_fasync 发送信号  *********&#x2F;</p>
<p>​	</p>
<p>​	return IRQ_RETVAL(IRQ_HANDLED);</p>
<p>}</p>
<p><strong>总结：</strong>****</p>
<p>为了使得设备支持异步通知机制，驱动程序最终涉及以下 3 项工作：</p>
<p><strong>1，支持 F_SETOWN 命令 ：</strong>****</p>
<p>能在这个控制命令处理中设置 filp-&gt;f_owner 为对应进程 ID；</p>
<p>此项操作由内核完成，设备驱动无须处理；</p>
<p><strong>2，支持 F_SETFL 命令的处理：</strong>****</p>
<p>当 FASYNC 标志改变的时候，驱动操作中的 fasync () 函数将得以执行；</p>
<p>驱动程序实现 fasync ()  函数；</p>
<p><strong>3，调用 kill_fasync () 函数：</strong>****</p>
<p>在设备资源可获得时， 调用 kill_fasync () 函数激发相应的信号.</p>
<h3 id="6-6-9-多线程"><a href="#6-6-9-多线程" class="headerlink" title="6.6.9 多线程"></a>6.6.9 多线程</h3><h4 id="6-6-9-1-优点"><a href="#6-6-9-1-优点" class="headerlink" title="6.6.9.1 优点"></a>6.6.9.1 优点</h4><p>①线程适合多任务通信</p>
<p>同一进程中创建的多个线程功效相同的内存空间，不同的线程可以</p>
<p>②线程的创建和调度更高效</p>
<p>使用多线程的理由之一是：和进程相比，它是一种非常“节俭”的多任务操作方式。在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</p>
<p>运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。</p>
<p>使用多线程的理由之二是：线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。</p>
<p>除了以上所说的优点外，多线程程序作为一种多任务、并发的工作方式，有如下优点：</p>
<p>使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p>
<p>改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。</p>
<p>Linux系统下的多线程遵循POSIX线程接口，称为pthread。编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用库libpthread.a。</p>
<p>附件：<a href="file:///G:\学习笔记\笔记\附件\文档\linux多线程.docx">附件\文档\linux多线程.docx</a></p>
<h4 id="6-6-9-2-创建线程"><a href="#6-6-9-2-创建线程" class="headerlink" title="6.6.9.2 创建线程"></a>6.6.9.2 创建线程</h4><p>#include &lt;pthread.h&gt;</p>
<p>int pthread_create(pthread_t * tidp,const pthread_attr_t *attr, void *(*start_rtn)(void),void *arg)</p>
<p>tidp：线程id</p>
<p>attr：线程属性(通常为空)</p>
<p>start_rtn：线程要执行的函数</p>
<p>arg：start_rtn的参数</p>
<p>例  thread_create.c</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;pthread.h&gt;</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>void *myThread1(void)</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>int i;***</p>
</li>
<li><p>for (i&#x3D;0; i&lt;100; i++)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;This is the 1st pthread,created by zieckey.\n&quot;);***
</code></pre>
</li>
<li><pre><code>   sleep(1);//Let this thread to sleep 1 second,and then continue to run***
</code></pre>
</li>
<li><p>}***</p>
</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>void *myThread2(void)</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>int i;***</p>
</li>
<li><p>for (i&#x3D;0; i&lt;100; i++)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;This is the 2st pthread,created by zieckey.\n&quot;);***
</code></pre>
</li>
<li><pre><code>   sleep(1);***
</code></pre>
</li>
<li><p>}***</p>
</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>int main()</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>int i&#x3D;0, ret&#x3D;0;***</p>
</li>
<li><p>pthread_t id1,id2;***</p>
</li>
</ul>
<hr>
<ul>
<li><p>&#x2F;*创建线程1*&#x2F;***</p>
</li>
<li><p>ret &#x3D; pthread_create(&amp;id1, NULL, (void*)myThread1, NULL);***</p>
</li>
<li><p>if (ret)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;Create pthread error!\n&quot;);***
</code></pre>
</li>
<li><pre><code>   return 1;***
</code></pre>
</li>
<li><p>}***</p>
</li>
</ul>
<hr>
<ul>
<li><p>&#x2F;*创建线程2*&#x2F;***</p>
</li>
<li><p>ret &#x3D; pthread_create(&amp;id2, NULL, (void*)myThread2, NULL);***</p>
</li>
<li><p>if (ret)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;Create pthread error!\n&quot;);***
</code></pre>
</li>
<li><pre><code>   return 1;***
</code></pre>
</li>
<li><p>}***</p>
</li>
</ul>
<hr>
<ul>
<li><p>pthread_join(id1, NULL);***</p>
</li>
<li><p>pthread_join(id2, NULL);***</p>
</li>
</ul>
<hr>
<ul>
<li>return 0;***</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>thread_share.c</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;pthread.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>&#x2F;&#x2F;static int a&#x3D;4;</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>int a &#x3D; 1;<strong>&#x2F;&#x2F;数据段</strong></em></p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>void *create(void <em>arg)</em></em>*</p>
<p><em>{</em>**</p>
<ul>
<li><p>printf(“new pthread … \n”);***</p>
</li>
<li><p>printf(“a&#x3D;%d  \n”,a);***</p>
</li>
<li><p>return (void *)0;***</p>
</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>int main(int argc,char *argv[])</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>pthread_t tidp;***</p>
</li>
<li><p>int error;***</p>
</li>
</ul>
<hr>
<ul>
<li><p>int a&#x3D;5;<strong>&#x2F;&#x2F;栈      优先使用栈，后使用数据段。</strong>*</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>printf(“a &#x3D; %d\n”,a);***</p>
</li>
</ul>
<hr>
<ul>
<li><p>error&#x3D;pthread_create(&amp;tidp, NULL, create, NULL);***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>if(error!&#x3D;0)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;new thread is not create ... \n&quot;);***
</code></pre>
</li>
<li><pre><code>   return -1;***
</code></pre>
</li>
<li><p>}***</p>
</li>
</ul>
<hr>
<ul>
<li>sleep(1);***</li>
</ul>
<hr>
<ul>
<li><p>printf(“new thread is created … \n”);***</p>
</li>
<li><p>return 0;***</p>
</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<h4 id="6-6-9-3-编译"><a href="#6-6-9-3-编译" class="headerlink" title="6.6.9.3 编译"></a>6.6.9.3 编译</h4><p>因为pthread的库不是linux系统的库，所以在进行编译的时候要加上-lpthread</p>
<p># gcc filename -lpthread</p>
<h4 id="6-6-9-4-终止线程"><a href="#6-6-9-4-终止线程" class="headerlink" title="6.6.9.4 终止线程"></a>6.6.9.4 终止线程</h4><p>如果进程中任何一个线程中调用exit或_exit，那么整个进程都会终止。线程的正常退出方式有：</p>
<p>(1) 线程从启动例程中返回</p>
<p>(2) 线程可以被另一个进程终止</p>
<p>(3) 线程自己调用pthread_exit函数</p>
<h4 id="6-6-9-5-线程退出"><a href="#6-6-9-5-线程退出" class="headerlink" title="6.6.9.5 线程退出"></a>6.6.9.5 线程退出</h4><p>#include &lt;pthread.h&gt;</p>
<p>void pthread_exit(void* rval_ptr)</p>
<p>功能：终止调用线程</p>
<p>Rval_ptr:线程退出返回值的指针。</p>
<p>thread_exit.c</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;pthread.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>void *create(void <em>arg)</em></em>*</p>
<p><em>{</em>**</p>
<ul>
<li><p>printf(“new thread is created … \n”);***</p>
</li>
<li><p>return (void *)8;***</p>
</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>int main(int argc,char *argv[])</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>pthread_t tid;***</p>
</li>
<li><p>int error;***</p>
</li>
<li><p>void *temp;***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>error &#x3D; pthread_create(&amp;tid, NULL, create, NULL);***</p>
</li>
<li><p>printf(“main thread!\n”);***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>if( error )***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;thread is not created ... \n&quot;);***
</code></pre>
</li>
<li><pre><code>   return -1;***
</code></pre>
</li>
<li><p>}***</p>
</li>
<li><p>error &#x3D; pthread_join(tid, &amp;temp);***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>if( error )***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;thread is not exit ... \n&quot;);***
</code></pre>
</li>
<li><pre><code>   return -2;***
</code></pre>
</li>
<li><p>}***</p>
</li>
</ul>
<hr>
<ul>
<li><p>printf(“thread is exit code %d \n”, (int )temp);***</p>
</li>
<li><p>return 0;***</p>
</li>
</ul>
<p><em>}</em>**</p>
<h4 id="6-6-9-6-线程等待"><a href="#6-6-9-6-线程等待" class="headerlink" title="6.6.9.6 线程等待"></a>6.6.9.6 线程等待</h4><p>#include &lt;pthread.h&gt;</p>
<p>int pthread_join(pthread_t tid,void **rval_ptr)</p>
<p>功能：阻塞调用线程，直到指定的线程终止。</p>
<p>Tid:等待退出的线程id</p>
<p>Rval_ptr：线程退出的返回值的指针</p>
<p>thread_join.c</p>
<p><em>#include &lt;pthread.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>void *thread(void <em>str)</em></em>*</p>
<p><em>{</em>**</p>
<ul>
<li><p>int i;***</p>
</li>
<li><p>for (i &#x3D; 0; i &lt; 10; ++i)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   sleep(2);***
</code></pre>
</li>
<li><pre><code>   printf( &quot;This in the thread : %d\n&quot; , i );***
</code></pre>
</li>
<li><p>}***</p>
</li>
<li><p>return NULL;***</p>
</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>int main()</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>pthread_t pth;***</p>
</li>
<li><p>int i;***</p>
</li>
<li><p>int ret &#x3D; pthread_create(&amp;pth, NULL, thread, (void *)(i));***</p>
</li>
</ul>
<hr>
<ul>
<li><p>pthread_join(pth, NULL);***</p>
</li>
<li><p>printf(“123\n”);***</p>
</li>
<li><p>for (i &#x3D; 0; i &lt; 10; ++i)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   //sleep(1);***
</code></pre>
</li>
<li><pre><code>   printf( &quot;This in the main : %d\n&quot; , i );***
</code></pre>
</li>
<li><p>}***</p>
</li>
</ul>
<hr>
<ul>
<li>return 0;***</li>
</ul>
<p><em>}</em>**</p>
<h4 id="6-6-9-7-线程标识"><a href="#6-6-9-7-线程标识" class="headerlink" title="6.6.9.7 线程标识"></a>6.6.9.7 线程标识</h4><p>#include &lt;pthread.h&gt;</p>
<p>pthread_t pthread_self(void)</p>
<p>功能：获取调用线程的 threadidentifier</p>
<p>thread_id.c</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;pthread.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt; &#x2F;*getpid()</em>&#x2F;***</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>void *create(void <em>arg)</em></em>*</p>
<p><em>{</em>**</p>
<ul>
<li><p>printf(“New thread …. \n”);***</p>
</li>
<li><p>printf(“This thread’s id is %u  \n”, (unsigned int)pthread_self());***</p>
</li>
<li><p>printf(“The process pid is %d  \n”,getpid());***</p>
</li>
<li><p>return (void *)0;***</p>
</li>
</ul>
<p>*} ***</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>int main(int argc,char *argv[])</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>pthread_t tid;***</p>
</li>
<li><p>int error;***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>printf(“Main thread is starting … \n”);***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>error &#x3D; pthread_create(&amp;tid, NULL, create, NULL);***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>if(error)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;thread is not created ... \n&quot;);***
</code></pre>
</li>
<li><pre><code>   return -1;***
</code></pre>
</li>
<li><p>}***</p>
</li>
<li><p>printf(“The main process’s pid is %d  \n”,getpid());***</p>
</li>
<li><p>sleep(1);***</p>
</li>
<li><p>return 0;***</p>
</li>
</ul>
<p><em>}</em>**</p>
<h4 id="6-6-9-8-清除"><a href="#6-6-9-8-清除" class="headerlink" title="6.6.9.8 清除"></a>6.6.9.8 清除</h4><p>线程终止有两种情况：正常终止和非正常终止。线程主动调用pthread_exit或者从线程函数中return都将使线程正常退出，这是可预见的退出方式；非正常终止是线程在其他线程的干预下，或者由于自身运行出错（比如访问非法地址）而退出，这种退出方式是不可预见的。</p>
<p>从pthread_cleanup_push的调用点到pthread_cleanup_pop之间的程序段中的终止动作（包括调用pthread_exit()和异常终止，不包括return）都将执行pthread_cleanup_push()所指定的清理函数。</p>
<p>#include &lt;pthread.h&gt;</p>
<p>void pthread_cleanup_push(void (*rtn)(void *),void *arg)</p>
<p>功能：将清除函数压入清除栈</p>
<p>Rtn:清除函数</p>
<p>Arg:清除函数的参数</p>
<p>#include &lt;pthread.h&gt;</p>
<p>void pthread_cleanup_pop(int execute)</p>
<p>功能：将清除函数弹出清除栈</p>
<p>参数：Execute执行到pthread_cleanup_pop()时是否在弹出清理函数的同时执行该函数，非0:执行; 0:不执行</p>
<p>thread_clean.c</p>
<p><em>#include &lt;stdio.h&gt;</em>**</p>
<p><em>#include &lt;pthread.h&gt;</em>**</p>
<p><em>#include &lt;unistd.h&gt;</em>**</p>
<p><em>void *clean(void <em>arg)</em></em>*</p>
<p><em>{</em>**</p>
<ul>
<li><p>printf(“cleanup :%s  \n”,(char *)arg);***</p>
</li>
<li><p>return (void *)0;***</p>
</li>
</ul>
<p><em>}</em>**</p>
<p><em>void *thr_fn1(void <em>arg)</em></em>*</p>
<p><em>{</em>**</p>
<ul>
<li><p>printf(“thread 1 start  \n”);***</p>
</li>
<li><p>pthread_cleanup_push( (void*)clean,”thread 1 first handler”);***</p>
</li>
<li><p>pthread_cleanup_push( (void*)clean,”thread 1 second hadler”);***</p>
</li>
<li><p>printf(“thread 1 push complete  \n”);***</p>
</li>
<li><p>if(arg)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   return((void \*)1);***
</code></pre>
</li>
<li><p>}***</p>
</li>
<li><p>pthread_cleanup_pop(0);***</p>
</li>
<li><p>pthread_cleanup_pop(0);***</p>
</li>
<li><p>return (void *)1;***</p>
</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>void *thr_fn2(void <em>arg)</em></em>*</p>
<p><em>{</em>**</p>
<ul>
<li><p>printf(“thread 2 start  \n”);***</p>
</li>
<li><p>pthread_cleanup_push( (void*)clean,”thread 2 first handler”);***</p>
</li>
<li><p>pthread_cleanup_push( (void*)clean,”thread 2 second handler”);***</p>
</li>
<li><p>printf(“thread 2 push complete  \n”);***</p>
</li>
<li><p>if(arg)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   pthread_exit((void \*)2);***
</code></pre>
</li>
<li><p>}***</p>
</li>
<li><p>pthread_cleanup_pop(0);***</p>
</li>
<li><p>pthread_cleanup_pop(0);***</p>
</li>
<li><p>pthread_exit((void *)2);***</p>
</li>
</ul>
<p><em>}</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>thread 2 start</em>**</p>
<p><em>clean up: thread 2 first handler</em>**</p>
<p><em>clean up: thread 2 second handler</em>**</p>
<p><em>thread 2 push complete</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>thread 2 start</em>**</p>
<p><em>thread 2 push complete</em>**</p>
<p><em>clean up: thread 2 first handler</em>**</p>
<p><em>clean up: thread 2 second handler</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p><em>int main(void)</em>**</p>
<p><em>{</em>**</p>
<ul>
<li><p>int err;***</p>
</li>
<li><p>pthread_t tid1,tid2;***</p>
</li>
<li><p>void *tret;***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>err&#x3D;pthread_create(&amp;tid1,NULL,thr_fn1,(void *)1);***</p>
</li>
<li><p>if(err!&#x3D;0)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;error .... \n&quot;);***
</code></pre>
</li>
<li><pre><code>   return -1;***
</code></pre>
</li>
<li><p>}***</p>
</li>
<li><p>err&#x3D;pthread_create(&amp;tid2,NULL,thr_fn2,(void *)1);***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>if(err!&#x3D;0)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;error .... \n&quot;);***
</code></pre>
</li>
<li><pre><code>   return -1;***
</code></pre>
</li>
<li><p>}***</p>
</li>
<li><p>err&#x3D;pthread_join(tid1,&amp;tret);***</p>
</li>
<li><p>if(err!&#x3D;0)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;error .... \n&quot;);***
</code></pre>
</li>
<li><pre><code>   return -1;***
</code></pre>
</li>
<li><p>}***</p>
</li>
<li><p>printf(“thread 1 exit code %d  \n”,(int)tret);***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>err&#x3D;pthread_join(tid2,&amp;tret);***</p>
</li>
<li><p>if(err!&#x3D;0)***</p>
</li>
<li><p>{***</p>
</li>
<li><pre><code>   printf(&quot;error .... &quot;);***
</code></pre>
</li>
<li><pre><code>   return -1;***
</code></pre>
</li>
<li><p>}***</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>printf(“thread 2 exit code %d  \n”,(int)tret);***</p>
</li>
</ul>
<hr>
<ul>
<li>return 1;***</li>
</ul>
<p><em>}</em>**</p>
<h4 id="6-6-9-9-线程同步"><a href="#6-6-9-9-线程同步" class="headerlink" title="6.6.9.9 线程同步"></a>6.6.9.9 线程同步</h4><p>进行多线程编程，因为无法知道哪个线程会在哪个时候对共享资源进行操作，因此让如何保护共享资源变得复杂，通过下面这些技术的使用，可以解决线程之间对资源的竞争：</p>
<p>1 互斥量Mutex</p>
<p>2 信号灯Semaphore</p>
<p>3 条件变量Conditions</p>
<h3 id="6-6-10-互斥量"><a href="#6-6-10-互斥量" class="headerlink" title="6.6.10 互斥量"></a>6.6.10 互斥量</h3><p>为什么需要互斥量：</p>
<p>Item *p &#x3D;queue_list;</p>
<p>Queue_list&#x3D;queue_list-&gt;next;</p>
<p>process_job(p);</p>
<p>free(p);</p>
<p>当线程1处理完Item *p&#x3D;queue_list后，系统停止线程1的运行，改而运行线程2。线程2照样取出头节点，然后进行处理，最后释放了该节点。过了段时间，线程1重新得到运行。而这个时候，p所指向的节点已经被线程2释放掉，而线程1对此毫无知晓。他会接着运行process_job(p)。而这将导致无法预料的后果！</p>
<h4 id="6-6-10-1-创建"><a href="#6-6-10-1-创建" class="headerlink" title="6.6.10.1 创建"></a>6.6.10.1 创建</h4><p>在Linux中, 互斥量使用类型pthread_mutex_t表示。在使用前, 要对它进行初始化: </p>
<p>对于静态分配的互斥量, 可以把它设置为默认的mutex对象PTHREAD_MUTEX_INITIALIZER</p>
<p>对于动态分配的互斥量, 在申请内存(malloc)之后, 通过pthread_mutex_init进行初始化, 并且在释放内存(free)前需要调用pthread_mutex_destroy。</p>
<p>#include &lt;pthread.h&gt; </p>
<p>int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)</p>
<p>int pthread_mutex_destroy(pthread_mutex_t *mutex)</p>
<h4 id="6-6-10-2-加锁"><a href="#6-6-10-2-加锁" class="headerlink" title="6.6.10.2 加锁"></a>6.6.10.2 加锁</h4><p>对共享资源的访问, 要使用互斥量进行加锁, 如果互斥量已经上了锁, 调用线程会阻塞, 直到互斥量被解锁。</p>
<p>int pthread_mutex_lock(pthread_mutex_t *mutex)</p>
<p>int pthread_mutex_trylock(pthread_mutex_t *mutex)</p>
<p>返回值: 成功则返回0, 出错则返回错误编号。</p>
<p>trylock是非阻塞调用模式, 如果互斥量没被锁住, trylock函数将对互斥量加锁, 并获得对共享资源的访问权限; 如果互斥量被锁住了, trylock函数将不会阻塞等待而直接返回EBUSY, 表示共享资源处于忙状态。</p>
<h4 id="6-6-10-3-解锁"><a href="#6-6-10-3-解锁" class="headerlink" title="6.6.10.3 解锁"></a>6.6.10.3 解锁</h4><p>在操作完成后，必须给互斥量解锁，也就是前面所说的释放。这样其他等待该锁的线程才有机会获得该锁，否则其他线程将会永远阻塞。</p>
<p>int pthread_mutex_unlock(pthread_mutex_t *mutex)</p>
<p><a target="_blank" rel="noopener" href="http://www.enjoylinux.cn/">www.enjoylinux.cn</a></p>
<h4 id="6-6-10-4-互斥量PK信号量"><a href="#6-6-10-4-互斥量PK信号量" class="headerlink" title="6.6.10.4 互斥量PK信号量"></a>6.6.10.4 互斥量PK信号量</h4><p>Mutex是一把钥匙，一个人拿了就可进入一个房间，出来的时候把钥匙交给队列的第一个。</p>
<p>Semaphore是一件可以容纳N人的房间，如果人不满就可以进去，如果人满了，就要等待有人出来。对于N&#x3D;1的情况，称为binary semaphore。</p>
<p>Binary semaphore与Mutex的差异：</p>
<p>\1. mutex要由获得锁的线程来释放（谁获得，谁释放）。而semaphore可以由其它线程释放</p>
<p>\2. 初始状态可能不一样：mutex的初始值是1,而semaphore的初始值可能是0（或者为1）。</p>
<h2 id="6-7-Linux网络应用程序设计"><a href="#6-7-Linux网络应用程序设计" class="headerlink" title="6.7 Linux网络应用程序设计"></a>6.7 <a href="">Linux网络应用程序设计</a></h2><h3 id="6-7-1-端口"><a href="#6-7-1-端口" class="headerlink" title="6.7.1 端口"></a>6.7.1 端口</h3><p>端口是指计算机为了标识在计算机中访问网络的不同程序而设置的编号。</p>
<h3 id="6-7-2-TCP-x2F-IP"><a href="#6-7-2-TCP-x2F-IP" class="headerlink" title="6.7.2 TCP&#x2F;IP"></a>6.7.2 TCP&#x2F;IP</h3><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）即传输控制协议&#x2F;网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。</p>
<p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP&#x2F;IP协议族中的一种。</p>
<h4 id="6-7-2-1-网络模型"><a href="#6-7-2-1-网络模型" class="headerlink" title="6.7.2.1 网络模型"></a>6.7.2.1 网络模型</h4><p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps78.jpg" alt="img"> </p>
<h4 id="6-7-2-2-TCP-x2F-IP4层模型"><a href="#6-7-2-2-TCP-x2F-IP4层模型" class="headerlink" title="6.7.2.2 TCP&#x2F;IP4层模型"></a>6.7.2.2 TCP&#x2F;IP4层模型</h4><p>网络接口层：负责将二进制流转换为数据帧，并进行数据帧的发送和接收。数据帧是独立的网络信息传输单元。</p>
<p>网络层：负责将数据帧封装成IP数据包，并运行必要的路由算法。</p>
<p>传输层：负责端对端之间的通信会话连接与建立。</p>
<p>应用层：负责应用程序的网络访问，通过端口号来识别不同的进程。</p>
<h4 id="6-7-2-3-TCP-x2F-IP协议族"><a href="#6-7-2-3-TCP-x2F-IP协议族" class="headerlink" title="6.7.2.3 TCP&#x2F;IP协议族"></a>6.7.2.3 TCP&#x2F;IP协议族</h4><p>TCP&#x2F;IP 实际上一个协同工作的通信家族，为网络数据通信提供通路。为讨论方便可TCP&#x2F;IP 协议组大体上分为三部分：</p>
<p>• Internet 协议（IP）</p>
<p>• 传输控制协议（TCP）和用户数据报协议（UDP）</p>
<p>• 处于 TCP 和 UDP 之上的一组应用协议。它们包括：TELNET，文件传送协议（FTP），域名服务（DNS）和简单的邮件传送程序（SMTP）等。</p>
<p>TCP对话三次握手协议。</p>
<h4 id="6-7-2-4-网络层"><a href="#6-7-2-4-网络层" class="headerlink" title="6.7.2.4 网络层"></a>6.7.2.4 网络层</h4><p>第一部分称为网络层。主要包括Internet 协议（IP）、网际控制报文协议（ICMP）和地址解析协议（ARP）：</p>
<p>• Internet 协议（IP）该协议被设计成互联分组交换通信网，以形成一个网际通信环境。它负责在源主机和目的地主机之间传输来自其较高层软件的称为数据报文的数据块，它在源和目的地之间提供非连接型传递服务。</p>
<p>网际控制报文协议（ICMP）</p>
<p>它实际上不是IP层部分，但直接同IP层一起工作，报告网络上的某些出错情况。允许网际路由器传输差错信息或测试报文。</p>
<p>地址解析协议（ARP）</p>
<p>ARP 实际上不是网络层部分，它处于IP和数据链路层之间，它是在32位IP地址和48位物理地址之间执行翻译的协议。</p>
<h4 id="6-7-2-5-传输层协议"><a href="#6-7-2-5-传输层协议" class="headerlink" title="6.7.2.5 传输层协议"></a>6.7.2.5 传输层协议</h4><p>第二部分是传输层协议，包括传输控制协议和用户数据报文协议。</p>
<p>• 传输控制协议（TCP）：</p>
<p>该协议对建立网络上用户进程之间的对话负责，它确保进程之间的可靠通信，所提供的功能如下：</p>
<p>\1. 监听输入对话建立请求</p>
<p>\2. 请求另一网络站点对话</p>
<p>\3. 可靠的发送和接收数据</p>
<p>\4. 适度的关闭对话</p>
<p>• 用户数据报文协议（UDP）：</p>
<p>UDP 提供不可靠的非连接型传输层服务，它允许在源和目的地之间传送数据，而不必在传送数据之前建立对话。它主要用于那些非连接型的应用程序，如：视频点播。</p>
<h4 id="6-7-2-6-应用协议"><a href="#6-7-2-6-应用协议" class="headerlink" title="6.7.2.6 应用协议"></a>6.7.2.6 应用协议</h4><p>这部分主要包括Telnet，文件传送协议（FTP 和TFTP），简单文件传送协议（SMTP）和域名服务（DNS）等协议。</p>
<h4 id="6-7-2-7-IP协议"><a href="#6-7-2-7-IP协议" class="headerlink" title="6.7.2.7 IP协议"></a>6.7.2.7 IP协议</h4><p>IP主要有以下四个主要功能：</p>
<p>• 数据传送</p>
<p>• 寻址</p>
<p>• 路由选择</p>
<p>• 数据报文的分段</p>
<p>IP的主要目的是为数据输入&#x2F;输出网络提供基本算法，为高层协议提供无连接的传送服务。这意味着在IP将数据递交给接收站点以前不在传输站点和接收站点之间建立对话。它只是封装和传递数据，但不向发送者或接收者报告包的状态，不处理所遇到的故障。</p>
<p>IP包由IP协议头与协议数据两部分构成。</p>
<h4 id="6-7-2-8-TCP协议"><a href="#6-7-2-8-TCP协议" class="headerlink" title="6.7.2.8 TCP协议"></a>6.7.2.8 TCP协议</h4><p>TCP是重要的传输层协议，目的是允许数据同网络上的其他节点进行可靠的交换。它能提供端口编号的译码，以识别主机的应用程序，而且完成数据的可靠传输。</p>
<p>• TCP 协议具有严格的内装差错检验算法确保数据的完性。</p>
<p>• TCP 是面向字节的顺序协议，这意味着包内的每个字节被分配一个顺序编号，并分配给每包一个顺序编号。</p>
<h4 id="6-7-2-9-UDP协议"><a href="#6-7-2-9-UDP协议" class="headerlink" title="6.7.2.9 UDP协议"></a>6.7.2.9 UDP协议</h4><p>UDP也是传输层协议，它是无连接的，不可靠的传输服务。当接收数据时它不向发送方提供确认信息，它不提供输入包的顺序，如果出现丢失包或重份包的情况，也不会向发送方发出差错报文。由于它执行功能时具有较低的开销，因而执行速度比TCP快。</p>
<h3 id="6-7-3-linux网络编程"><a href="#6-7-3-linux网络编程" class="headerlink" title="6.7.3 linux网络编程"></a>6.7.3 linux网络编程</h3><p>socket，一种特殊的I&#x2F;O接口，Linux中的网络编程通过Socket(套接字)接口实现，Socket是一种文件描述符。</p>
<h4 id="6-7-3-1-套接字socket有三种类型："><a href="#6-7-3-1-套接字socket有三种类型：" class="headerlink" title="6.7.3.1 套接字socket有三种类型："></a>6.7.3.1 套接字socket有三种类型：</h4><p>l 流式套接字（SOCK_STREAM）</p>
<p>流式的套接字可以提供可靠的、面向连接的通讯流。它使用了TCP协议。TCP 保证了数据传输的正确性和顺序性。</p>
<p>l 数据报套接字（SOCK_DGRAM）</p>
<p>数据报套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证可靠，无差错,它使用数据报协议UDP。</p>
<p>l 原始套接字</p>
<p>原始套接字允许对低层协议如IP或ICMP直接访问，主要用于新的网络协议的测试等。</p>
<h4 id="6-7-3-2-地址结构"><a href="#6-7-3-2-地址结构" class="headerlink" title="6.7.3.2 地址结构"></a>6.7.3.2 地址结构</h4><p>*struct sockaddr ***</p>
<p>*{ ***</p>
<p>*u_short sa_family; ***</p>
<p>*char sa_data[14]; ***</p>
<p>*} ***</p>
<p><em>Sa_family:<strong>地址族，采用“AF_xxx”的形式，</strong></em></p>
<p><em>AF_INET：IPV4协议</em>**</p>
<ul>
<li><p>   <strong>AF_INET6：IPV6协议</strong>*</p>
</li>
<li><p>   <strong>AF_LOCAL：unix域协议</strong>*</p>
</li>
<li><p>   <strong>AF_LINK：链路地址协议</strong>*</p>
</li>
<li><p>   <strong>AF_KEY:密钥套接字</strong>*</p>
</li>
</ul>
<hr>
<p><em>Sa_data：14字节的特定协议地址。</em>**</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p>*struct sockaddr_in ***</p>
<p><em>{</em>**</p>
<p><em>shortint sin_family; &#x2F;* Internet地址族 <em>&#x2F;</em></em>*</p>
<p><em>unsigned short int sin_port;  &#x2F;* 端口号 <em>&#x2F;</em></em>*</p>
<p><em>struct in_addr sin_addr;   &#x2F;*IP地址 <em>&#x2F;</em></em>*</p>
<p><em>unsigned char sin_zero[8]; &#x2F;* 填0 <em>&#x2F;</em></em>*</p>
<p><em>}</em>**</p>
<p><em>编程中一般并不直接针对sockaddr数据结构操作，而是使用与sockaddr等价的sockaddr_in数据结构</em>**</p>
<p><em>sin_family:</em>**</p>
<p><em>AF_INET：IPV4协议</em>**</p>
<ul>
<li><p>   <strong>AF_INET6：IPV6协议</strong>*</p>
</li>
<li><p>   <strong>AF_LOCAL：unix域协议</strong>*</p>
</li>
<li><p>   <strong>AF_LINK：链路地址协议</strong>*</p>
</li>
<li><p>   <strong>AF_KEY:密钥套接字</strong>*</p>
</li>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p>**struct in_addr ******</p>
<p><strong>{</strong>****</p>
<p><strong>unsigned long s_addr;</strong>****</p>
<p><strong>}</strong>****</p>
<p><strong>S_addr:32位的地址。</strong>****</p>
<p>IP地址通常由数字加点(192.168.0.1)的形式表示，而在struct in_addr中使用的是IP地址是由32位的整数表示的，为了转换我们可以使用下面两个函数：</p>
<p>int inet_aton(const char *cp,struct in_addr *inp)</p>
<p>char *inet_ntoa(struct in_addr in) </p>
<p>函数里面 a 代表 asciin 代表network.第一个函数表示将a.b.c.d形式的IP转换为32位的IP,存储在 inp指针里面。第二个是将32位IP转换为a.b.c.d的格式。</p>
<h4 id="6-7-3-3-字节序转换"><a href="#6-7-3-3-字节序转换" class="headerlink" title="6.7.3.3 字节序转换"></a>6.7.3.3 字节序转换</h4><p>不同类型的 CPU 对变量的字节存储顺序可能不同：有的系统是高位在前，低位在后，而有的系统是低位在前，高位在后，而网络传输的数据顺序是一定要统一的。所以当内部字节存储顺序和网络字节顺序不同时，就一定要进行转换。</p>
<p>32bit的整数(0x01234567)从地址0x100开始：</p>
<p>小端字节序：</p>
<p>大端字节序：</p>
<p>网络字节顺序是TCP&#x2F;IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用bigendian排序方式。</p>
<p>为什么要进行字节序转换？</p>
<p>例：INTEL的CPU使用的小端字节序MOTOROLA 68k系列CPU使用的是大端字节序MOTOROLA发一个16位数据0X1234给INTEL, 传到INTEL时 ,就被INTEL解释为0X3412 。</p>
<p>l htons   把unsigned short类型从主机序转换到网络序</p>
<p>l htonl   把unsignedlong类型从主机序转换到网络序</p>
<p>l ntohs  把unsigned short类型从网络序转换到主机序</p>
<p>l ntohl  把unsignedlong类型从网络序转换到主机序</p>
<h4 id="6-7-3-4-如何判断大小端格式"><a href="#6-7-3-4-如何判断大小端格式" class="headerlink" title="6.7.3.4 如何判断大小端格式"></a>6.7.3.4 如何判断大小端格式</h4><p>int n&#x3D;1</p>
<p>if(<em>((char</em>)&amp;n)&#x3D;&#x3D;1)小端</p>
<h4 id="6-7-3-5-大小端概念"><a href="#6-7-3-5-大小端概念" class="headerlink" title="6.7.3.5 大小端概念"></a>6.7.3.5 大小端概念</h4><p>大小端(Big Endian vs Little Endian)</p>
<p>l    &lt;1&gt;大端方式(MSDN中说的网络序)：Motorola的PPC系列、IP协议中；(该方式和书写方式一致)</p>
<p>l    &lt;2&gt;小端方式(MSDN中说的主机序)：VAX计算机、Intel的x86系列；</p>
<p>字节内部的bit高低次序相同(左高右低)，而字节之间的高低次序相反。</p>
<p>在32位系统中我们分以下这些情况来一一说明：</p>
<h5 id="6-7-3-5-1-Byte类型-8bits"><a href="#6-7-3-5-1-Byte类型-8bits" class="headerlink" title="6.7.3.5.1 Byte类型(8bits)"></a>6.7.3.5.1 Byte类型(8bits)</h5><p>在只有一个Byte的情况下，大端方式和小端方式没有分别。如：0x34</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>bit7</strong></th>
<th><strong>bit6</strong></th>
<th><strong>bit5</strong></th>
<th><strong>bit4</strong></th>
<th><strong>bit3</strong></th>
<th><strong>bit2</strong></th>
<th><strong>bit1</strong></th>
<th><strong>bit0</strong></th>
<th>** **</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bi**<strong>g</strong></strong> Endian**</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0x34</td>
</tr>
<tr>
<td>** Little Endian**</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0x34</td>
</tr>
</tbody></table>
<h5 id="6-7-3-5-2-Short类型-16bits"><a href="#6-7-3-5-2-Short类型-16bits" class="headerlink" title="6.7.3.5.2 Short类型(16bits)"></a>6.7.3.5.2 Short类型(16bits)</h5><p>大小端方式之间有差别。如：0x1234</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>bit7</strong></th>
<th><strong>bit6</strong></th>
<th><strong>bit5</strong></th>
<th><strong>bit4</strong></th>
<th><strong>bit3</strong></th>
<th><strong>bit2</strong></th>
<th><strong>bit1</strong></th>
<th><strong>bit0</strong></th>
<th>** **</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bi**<strong>g</strong></strong> Endian (0)**</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0x12</td>
</tr>
<tr>
<td><strong>Bi**<strong>g</strong></strong> Endian (1)**</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0x34</td>
</tr>
<tr>
<td><strong>Little Endian (0)</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0x34</td>
</tr>
<tr>
<td><strong>Little Endian (1)</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0x12</td>
</tr>
</tbody></table>
<h5 id="6-7-3-5-3-Long类型-32bits"><a href="#6-7-3-5-3-Long类型-32bits" class="headerlink" title="6.7.3.5.3 Long类型(32bits)"></a>6.7.3.5.3 Long类型(32bits)</h5><p>大小端方式之间有差别。如：0x12345678</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>bit7</strong></th>
<th><strong>bit6</strong></th>
<th><strong>bit5</strong></th>
<th><strong>bit4</strong></th>
<th><strong>bit3</strong></th>
<th><strong>bit2</strong></th>
<th><strong>bit1</strong></th>
<th><strong>bit0</strong></th>
<th>** **</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bi**<strong>g</strong></strong> Endian (0)**</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0x12</td>
</tr>
<tr>
<td><strong>Bi**<strong>g</strong></strong> Endian (1)**</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0x34</td>
</tr>
<tr>
<td><strong>Bi**<strong>g</strong></strong> Endian (2)**</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0x56</td>
</tr>
<tr>
<td><strong>Bi**<strong>g</strong></strong> Endian (3)**</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0x78</td>
</tr>
<tr>
<td><strong>Little Endian (0)</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0x78</td>
</tr>
<tr>
<td><strong>Little Endian  (1)</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0x56</td>
</tr>
<tr>
<td><strong>Little Endian (2)</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0x34</td>
</tr>
<tr>
<td><strong>Little Endian  (3)</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0x12</td>
</tr>
</tbody></table>
<h5 id="6-7-3-5-4-位域的情况-边界对齐问题-大小端问题-："><a href="#6-7-3-5-4-位域的情况-边界对齐问题-大小端问题-：" class="headerlink" title="6.7.3.5.4 位域的情况(边界对齐问题+大小端问题)："></a>6.7.3.5.4 位域的情况(边界对齐问题+大小端问题)：</h5><p>大小端方式之间有明显的差别。</p>
<p>在一个字节内，如3-4-1结构下的{4, 15, 0}</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>bit7</strong></th>
<th><strong>bit6</strong></th>
<th><strong>bit5</strong></th>
<th><strong>bit4</strong></th>
<th><strong>bit3</strong></th>
<th><strong>bit2</strong></th>
<th><strong>bit1</strong></th>
<th><strong>bit0</strong></th>
<th>** **</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bi**<strong>g</strong></strong> Endian**</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0x9E</td>
</tr>
<tr>
<td><strong>Little Endian</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0x7C</td>
</tr>
</tbody></table>
<p>跨字节，边界不对齐，如5-4-7结构下的{2, 15, 0}</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>bit7</strong></th>
<th><strong>bit6</strong></th>
<th><strong>bit5</strong></th>
<th><strong>bit4</strong></th>
<th><strong>bit3</strong></th>
<th><strong>bit2</strong></th>
<th><strong>bit1</strong></th>
<th><strong>bit0</strong></th>
<th>** **</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bi**<strong>g</strong></strong> Endian (0)**</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0x17</td>
</tr>
<tr>
<td><strong>Bi**<strong>g</strong></strong> Endian (1)**</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0x80</td>
</tr>
<tr>
<td><strong>Little Endian (0)</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0x01</td>
</tr>
<tr>
<td><strong>Little Endian (1)</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0xE2</td>
</tr>
</tbody></table>
<h4 id="6-7-3-6-IP与主机名"><a href="#6-7-3-6-IP与主机名" class="headerlink" title="6.7.3.6 IP与主机名"></a>6.7.3.6 IP与主机名</h4><p>在网络上标识一台机器可以用IP，也可以使用主机名。</p>
<p>struct hostent *gethostbyname(const char *hostname) </p>
<p>struct hostent</p>
<p>{ </p>
<p>char <em>h_name; &#x2F;</em> 主机的正式名称 *&#x2F; </p>
<p>char <em>h_aliases; &#x2F;</em> 主机的别名 *&#x2F; </p>
<p>int h_addrtype; &#x2F;* 主机的地址类型 AF_INET*&#x2F; </p>
<p>int h_length; &#x2F;* 主机的地址长度 *&#x2F; </p>
<p>char *<em>h_addr_list; &#x2F;</em> 主机的IP地址列表 *&#x2F;</p>
<p>}</p>
<p>#define h_addr h_addr_list[0] &#x2F;* 主机的第一个IP地址*&#x2F; </p>
<h4 id="6-7-3-7-名字地址转换"><a href="#6-7-3-7-名字地址转换" class="headerlink" title="6.7.3.7 名字地址转换"></a>6.7.3.7 名字地址转换</h4><p>#include&lt;netdb.h&gt;</p>
<p>struct  hostent  *gethostbyname(const  char *hostname);</p>
<p>int  getaddrinfo(const  char *node,const  char *service,const struct addrinfo  *hints,struct  addrinfo  **result);</p>
<p>  node:网络地址或者网络主机名</p>
<p>​	service：服务名或十进制的端口号字符串</p>
<p>​	hints：服务线索</p>
<p>​	result：返回结果</p>
<h4 id="6-7-3-8-地址转换"><a href="#6-7-3-8-地址转换" class="headerlink" title="6.7.3.8 地址转换"></a>6.7.3.8 地址转换</h4><p>IP地址通常由数字加点(192.168.0.1)的形式表示，而在struct in_addr中使用的是IP地址是由32位的整数表示的，为了转换我们可以使用下面两个函数：</p>
<p> int inet_aton(const char *cp,struct in_addr *inp)</p>
<p>char *inet_ntoa(struct in_addr in) </p>
<p>函数里面 a 代表 asciin 代表network.第一个函数表示将a.b.c.d形式的IP转换为32位的IP,存储在 inp指针里面。第二个是将32位IP转换为a.b.c.d的格式。</p>
<h4 id="6-7-3-9-函数"><a href="#6-7-3-9-函数" class="headerlink" title="6.7.3.9 函数"></a>6.7.3.9 函数</h4><p>进行Socket编程的常用函数有：</p>
<p>• socket    创建一个socket。</p>
<p>• bind      用于绑定IP地址和端口号到socket。</p>
<p>• connect   该函数用于绑定之后的client端，与服务器建立连接。</p>
<p>listen    设置能处理的最大连接要求，Listen()并未开始接收连线，只是设置socket为listen模式。</p>
<p>accept   用来接受socket连接。</p>
<p>send    发送数据</p>
<h4 id="6-7-3-10-基于TCP-服务器"><a href="#6-7-3-10-基于TCP-服务器" class="headerlink" title="6.7.3.10 基于TCP-服务器"></a>6.7.3.10 <a href="">基于TCP-服务器</a></h4><p>\1. 创建一个socket，用函数socket()</p>
<p>\2. 绑定IP地址、端口等信息到socket上，用函数bind()</p>
<p>\3. 设置允许的最大连接数，用函数listen()</p>
<p>\4. 接收客户端上来的连接，用函数accept()</p>
<p>\5. 收发数据，用函数send()和recv()，或者read()和write()</p>
<p>\6. 关闭网络连接</p>
<h4 id="6-7-3-11-基于TCP-客户端"><a href="#6-7-3-11-基于TCP-客户端" class="headerlink" title="6.7.3.11 基于TCP-客户端"></a>6.7.3.11 基于TCP-客户端</h4><p>\1. 创建一个socket，用函数socket()</p>
<p>\2. 设置要连接的对方的IP地址和端口等属性</p>
<p>\3. 连接服务器，用函数connect()</p>
<p>\4. 收发数据，用函数send()和recv()，或者read()和write()</p>
<p>\5. 关闭网络连接</p>
<h4 id="6-7-3-12-网络地址转换"><a href="#6-7-3-12-网络地址转换" class="headerlink" title="6.7.3.12 网络地址转换"></a>6.7.3.12 网络地址转换</h4><h5 id="6-7-3-12-1-网络字节顺序"><a href="#6-7-3-12-1-网络字节顺序" class="headerlink" title="6.7.3.12.1 网络字节顺序"></a>6.7.3.12.1 网络字节顺序</h5><p>每一台机器内部对变量的字节存储顺序不同，而网络传输的数据是一定要统一顺序的。所以对内部字节表示顺序与网络字节顺序不同的机器，一定要对数据进行转换，从程序的可移植性要求来讲，就算本机的内部字节表示顺序与网络字节顺序相同也应该在传输数据以前先调用数据转换函数，以便程序移植到其它机器上后能正确执行。真正转换还是不转换是由系统函数自己来决定的。</p>
<h5 id="6-7-3-12-2-有关的转换函数"><a href="#6-7-3-12-2-有关的转换函数" class="headerlink" title="6.7.3.12.2 有关的转换函数"></a>6.7.3.12.2 有关的转换函数</h5><p>* unsigned short int htons（unsigned short int hostshort）：</p>
<p>主机字节顺序转换成网络字节顺序，对无符号短型进行操作4bytes</p>
<p>* unsigned long int htonl（unsigned long int hostlong）：</p>
<p>主机字节顺序转换成网络字节顺序，对无符号长型进行操作8bytes</p>
<p>* unsigned short int ntohs（unsigned short int netshort）：</p>
<p>网络字节顺序转换成主机字节顺序，对无符号短型进行操作4bytes</p>
<p>* unsigned long int ntohl（unsigned long int netlong）：</p>
<p>网络字节顺序转换成主机字节顺序，对无符号长型进行操作8bytes</p>
<p>注：以上函数原型定义在netinet&#x2F;in.h里</p>
<h5 id="6-7-3-12-3-inet-ntoa"><a href="#6-7-3-12-3-inet-ntoa" class="headerlink" title="6.7.3.12.3 inet_ntoa()"></a>6.7.3.12.3 inet_ntoa()</h5><p>　　简述： </p>
<p>　　将网络地址转换成“.”点隔的字符串格式。 </p>
<p>　　#include &lt;winsock.h&gt; </p>
<p>　　char FAR* PASCAL FAR inet_ntoa( struct in_addr in); </p>
<p>　　in：一个表示Internet主机地址的结构。 </p>
<p>　　注释： </p>
<p>　　本函数将一个用in参数所表示的Internet地址结构转换成以“.” 间隔的诸如“a.b.c.d”的字符串形式。请注意inet_ntoa()返回的字符串存放在WINDOWS套接口实现所分配的内存中。应用程序不应假设该内存是如何分配的。在同一个线程的下一个WINDOWS套接口调用前，数据将保证是有效。 </p>
<p>　　返回值： </p>
<p>　　若无错误发生，inet_ntoa()返回一个字符指针。否则的话，返回NULL。其中的数据应在下一个WINDOWS套接口调用前复制出来。 </p>
<p>　　测试代码如下 </p>
<p>　　include &lt;stdio.h&gt; </p>
<p>　　#include &lt;sys&#x2F;socket.h&gt; </p>
<p>　　#include &lt;netinet&#x2F;in.h&gt; </p>
<p>　　#include &lt;arpa&#x2F;inet.h&gt; </p>
<p>　　#include &lt;string.h&gt; </p>
<p>　　int main(int aargc, char* argv[]) </p>
<p>　　{ </p>
<p>　　struct in_addr addr1,addr2; </p>
<p>　　ulong l1,l2; </p>
<p>　　l1&#x3D; inet_addr(“192.168.0.74”); </p>
<p>　　l2 &#x3D; inet_addr(“211.100.21.179”); </p>
<p>　　memcpy(&amp;addr1, &amp;l1, 4); </p>
<p>　　memcpy(&amp;addr2, &amp;l2, 4); </p>
<p>　　printf(“%s : %sn”, inet_ntoa(addr1), inet_ntoa(addr2)); &#x2F;&#x2F;注意这一句的运行结果 </p>
<p>　　printf(“%sn”, inet_ntoa(addr1)); </p>
<p>　　printf(“%sn”, inet_ntoa(addr2)); </p>
<p>　　return 0; </p>
<p>　　} </p>
<p>　　实际运行结果如下： </p>
<p>　　192.168.0.74 : 192.168.0.74 &#x2F;&#x2F;从这里可以看出,printf里的inet_ntoa只运行了一次。 </p>
<p>　　192.168.0.74 </p>
<p>　　211.100.21.179 </p>
<p>inet_ntoa返回一个char *,而这个char *的空间是在inet_ntoa里面静态分配的，所以inet_ntoa后面的调用会覆盖上一次的调用。第一句printf的结果只能说明在printf里面的可变参数的求值是从右到左的，仅此而已。</p>
<h4 id="6-7-3-13-各函数语法"><a href="#6-7-3-13-各函数语法" class="headerlink" title="6.7.3.13 各函数语法"></a>6.7.3.13 各函数语法</h4><h5 id="6-7-3-13-1-socket"><a href="#6-7-3-13-1-socket" class="headerlink" title="6.7.3.13.1 socket"></a>6.7.3.13.1 socket</h5><p>int  socket(int  family,int  type,int  protocol);</p>
<p>inet_addr()的功能是将一个点分十进制的IP转换成一个长整数型数（u_long类型）</p>
<p>inet_addr(“127.0.0.1”)</p>
<h5 id="6-7-3-13-2-bind"><a href="#6-7-3-13-2-bind" class="headerlink" title="6.7.3.13.2 bind"></a>6.7.3.13.2 bind</h5><p>int bind(int sockfd, struct sockaddr * my_addr, int addrlen);</p>
<p>返回值：成功则返回0, 失败返回-1, 错误原因存于errno 中.</p>
<h5 id="6-7-3-13-3-listen"><a href="#6-7-3-13-3-listen" class="headerlink" title="6.7.3.13.3 listen"></a>6.7.3.13.3 listen</h5><p>#include&lt;sys&#x2F;socket.h&gt;</p>
<p>int listen(int sockfd, int backlog)</p>
<p>返回：0──成功， -1──失败</p>
<h5 id="6-7-3-13-4-accept"><a href="#6-7-3-13-4-accept" class="headerlink" title="6.7.3.13.4 accept"></a>6.7.3.13.4 accept</h5><p>#include&lt;sys&#x2F;socket.h&gt;</p>
<p>int accept(int sockfd, struct sockaddr* addr, socklen_t* len)</p>
<p>返回：非负描述字——成功， -1——失败</p>
<h5 id="6-7-3-13-5-inet-pton"><a href="#6-7-3-13-5-inet-pton" class="headerlink" title="6.7.3.13.5 inet_pton"></a>6.7.3.13.5 inet_pton</h5><p>类似inet_addr</p>
<p>linux下：</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include&lt;arpa&#x2F;inet.h&gt;</p>
<p>inet_pton函数原型：</p>
<p>inet_pton：将“点分十进制” －&gt; “二进制整数”</p>
<p>int inet_pton(int af, const char *src, void *dst);</p>
<p>这个函数转换字符串到网络地址，第一个参数af是地址簇，第二个参数<em>src是来源地址，第三个参数</em> dst接收转换后的数据。</p>
<p>inet_pton 是inet_addr的扩展，支持的多地址族有下列：</p>
<p>af &#x3D; <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/3634059.htm">AF_INET</a></p>
<p>src为指向字符型的地址，即ASCII的地址的首地址（ddd.ddd.ddd.ddd格式的），函数将该地址转换为<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2907631.htm">in_addr</a>的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/204974.htm">结构体</a>，并复制在*dst中。</p>
<p>af &#x3D; AF_INET6</p>
<p>src为指向IPV6的地址，函数将该地址转换为in6_addr的结构体，并复制在*dst中。</p>
<p>如果函数出错将返回一个负值，并将errno设置为EAFNOSUPPORT，如果参数af指定的地址族和src格式不对，函数将返回0。</p>
<p>inet_pton例程</p>
<p><a href="javascript:;">编辑</a></p>
<p>下面是例程：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1347718.htm">stdlib.h</a>&gt;</p>
<p>#include &lt;<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1728868.htm">string.h</a>&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>int main (void)</p>
<p>{</p>
<p>char IPdotdec[20]; &#x2F;&#x2F;存放<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/828066.htm">点分十进制</a>IP地址</p>
<p>struct <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2907631.htm">in_addr</a> s; &#x2F;&#x2F; IPv4地址<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/204974.htm">结构体</a></p>
<p>&#x2F;&#x2F; 输入IP地址</p>
<p>printf(“Please input IP address: “);</p>
<p>scanf(“%s”, IPdotdec);</p>
<p>&#x2F;&#x2F; 转换</p>
<p>inet_pton(AF_INET, IPdotdec, (void *)&amp;s);</p>
<p>printf(“inet_pton: 0x%x\n”, s.s_addr); &#x2F;&#x2F; 注意得到的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2194385.htm">字节序</a></p>
<p>&#x2F;&#x2F; 反转换</p>
<p><a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2553376.htm">inet_ntop</a>(AF_INET, (void *)&amp;s, IPdotdec, 16);</p>
<p>printf(“inet_ntop: %s\n”, IPdotdec);</p>
<p>}</p>
<h5 id="6-7-3-13-6-setsockopt"><a href="#6-7-3-13-6-setsockopt" class="headerlink" title="6.7.3.13.6 setsockopt"></a>6.7.3.13.6 <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/6110713.htm">setsockopt</a></h5><p>设置<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/567586.htm">套接口</a>的选项。</p>
<p>#include &lt;<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2956875.htm">sys&#x2F;types.h</a>&gt;</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>int <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/6110713.htm">setsockopt</a>(int sockfd, int level, int optname,const void *optval, socklen_t optlen);</p>
<p>sockfd：标识一个<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/567586.htm">套接口</a>的描述字。</p>
<p>level：选项定义的层次；支持SOL_SOCKET、IPPROTO_TCP、IPPROTO_IP和IPPROTO_IPV6。</p>
<p>optname：需设置的选项。</p>
<p>optval：<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/159417.htm">指针</a>，指向存放选项值的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/266782.htm">缓冲区</a>。</p>
<p>optlen：optval<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/266782.htm">缓冲区</a>长度。</p>
<h5 id="6-7-3-13-7-sockaddr-ll结构体"><a href="#6-7-3-13-7-sockaddr-ll结构体" class="headerlink" title="6.7.3.13.7 sockaddr_ll结构体"></a>6.7.3.13.7 <a href="">sockaddr_ll</a>结构体</h5><h5 id="6-7-3-13-8-Linux学习笔记之网络的send和recv函数"><a href="#6-7-3-13-8-Linux学习笔记之网络的send和recv函数" class="headerlink" title="6.7.3.13.8 Linux学习笔记之网络的send和recv函数"></a>6.7.3.13.8 Linux学习笔记之网络的send和recv函数</h5><p>1、  函数原型</p>
<p>Int send(int socket, const void * buff, int length, int flags)</p>
<p>Int recv(int socket, void *buff, int length, int flags)</p>
<p>2、  对于正常的tcp通信来说，参数flags应设置为0</p>
<p>3、  Send（）函数不会阻塞程序的执行（当套接字是阻塞的并且套接字的TCP发送缓冲区容不下应用程序缓冲区中的所有数据时，send()函数将会阻塞）。缓冲区的数据被发送到系统中的底层的TCP发送缓冲区，然后函数将返回。有可能在send()函数中定义的缓冲区中的数据不会全部被发送出去。Send()函数的返回值表示有多少个字节的数据已被发送到TCP发送缓冲区。确认这个返回值匹配缓冲区的大小以确保所有的数据都已被发送出去时非常重要的。</p>
<p>4、  Recv()函数是一个阻塞式函数。当文件描述符fd用fcntl()设置为非阻塞后，会理解返回-1，errno为resource temporarily unavailable ，或者可以用标志MSG_DONTWAIT来设置recv()当次读取数据为非阻塞，程序的执行将暂停直到函数从远程客户端接收到数据或者远程客户端明确的断开TCP会话。如果客户端断开TCP会话，recv()函数返回值为0。如果客户端发送数据包，recv()函数将接收到的数据放入定义的缓冲区并返回接收到的字节数。</p>
<p>Len &#x3D; recv(fd, buff, len, 0)</p>
<p>Buff[len] &#x3D; ‘\0’当接收到数据时，recv()函数返回的缓冲区长度被用于在缓冲区中放置一个NULL结束符。这确保了每个接收到的字符串都被正确的终止了。</p>
<p>while((n &#x3D; recv(connfd, buff, sizeof(buff), 0)) &gt; 0)   &#x2F;&#x2F;回发</p>
<p>{</p>
<p>   buff[n] &#x3D; ‘\0’;</p>
<p>printf(“recv : %s\n”,buff);</p>
<p>​                                   n &#x3D; send(connfd, buff, n, 0);</p>
<p>​                                   if(n &lt; 0)</p>
<p>​                                   {</p>
<p>​                                          perror(“write error\n”);</p>
<p>​                                          return -1;</p>
<p>​                                   }</p>
<p>​                                   buff[n] &#x3D; ‘\0’;</p>
<p>​                                   printf(“write : %s\n”,buff);</p>
<p>​                            }</p>
<p>当远程客户端关闭TCP会话连接时，recv()将返回0，用于退出while()循环。</p>
<p>5、  如果服务器和客户端同时等待在recv()函数调用上，它们将产生死锁，并且不会有通信发生。</p>
<p>6、  Send()函数发送的数据将被放入一个字节流中通过网络传递给接收主机，接收主机使用recv()函数读取字节流中的部分数据，但并没有办法控制读取字节流中哪一部分的数据，你不能保证通过一次recv()函数调用就可以读取由send()函数发送的所有数据。</p>
<p>7、  TCP中没有消息边界的概念。当消息使用send()函数并使用recv()函数接收时，它们不一定在发送和接收时使用相同的边界，因为TCP有处理数据的内部缓冲区。由于TCP数据包可能会发生重传，所以应用程序发送给套接字的数据会在LINUX系统内部缓存。</p>
<p>8、  由两次send()函数调用发送的数据可以被一次recv()函数调用接收。</p>
<p>9、  标记消息边界：i. 使用消息长度 ii. 使用消息结束标记。使用消息长度有两种方法：i. 每个消息的长度都相同 ii. 每个消息中都包含其长度的含义。结束标记是一个预先确定的字符或一组字符，它用于界定一个消息的结尾。当主机接收到每个数据包时，必须检查数据包中的每一个字节。如果它不是消息结束标记，就把它添加到临时缓冲区中，当发现消息结束标记时，临时缓冲区中的数据就被传输到永久缓冲区中以便使用，然后临时缓冲区被清空以用于重组下一个消息。</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps79.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps80.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps81.png" alt="img"> </p>
<h3 id="6-7-4-inet-pton"><a href="#6-7-4-inet-pton" class="headerlink" title="6.7.4 inet_pton"></a>6.7.4 <strong>inet_pton</strong></h3><p><strong>linux****下：</strong></p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>#include&lt;arpa&#x2F;inet.h&gt;</p>
<p>inet_pton函数原型：</p>
<p><strong>inet_pton</strong>：将“点分十进制” －&gt; “二进制整数”</p>
<p>int inet_pton(int af, const char *src, void *dst);</p>
<p>这个函数转换字符串到网络地址，第一个参数af是地址簇，第二个参数<em>src是来源地址，第三个参数</em> dst接收转换后的数据。</p>
<p>inet_pton 是inet_addr的扩展，支持的多地址族有下列：</p>
<p>af &#x3D; <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/3634059.htm">AF_INET</a></p>
<p>src为指向字符型的地址，即ASCII的地址的首地址（ddd.ddd.ddd.ddd格式的），函数将该地址转换为<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2907631.htm">in_addr</a>的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/204974.htm">结构体</a>，并复制在*dst中。</p>
<p>af &#x3D; AF_INET6</p>
<p>src为指向IPV6的地址，函数将该地址转换为in6_addr的结构体，并复制在*dst中。</p>
<p>如果函数出错将返回一个负值，并将errno设置为EAFNOSUPPORT，如果参数af指定的地址族和src格式不对，函数将返回0。</p>
<p>inet_pton例程</p>
<p>下面是例程：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1347718.htm">stdlib.h</a>&gt;</p>
<p>#include &lt;<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1728868.htm">string.h</a>&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>#include &lt;netinet&#x2F;in.h&gt;</p>
<p>int main (void)</p>
<p>{</p>
<p>char IPdotdec[20]; &#x2F;&#x2F;存放<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/828066.htm">点分十进制</a>IP地址</p>
<p>struct <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2907631.htm">in_addr</a> s; &#x2F;&#x2F; IPv4地址<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/204974.htm">结构体</a></p>
<p>&#x2F;&#x2F; 输入IP地址</p>
<p>printf(“Please input IP address: “);</p>
<p>scanf(“%s”, IPdotdec);</p>
<p>&#x2F;&#x2F; 转换</p>
<p>inet_pton(AF_INET, IPdotdec, (void *)&amp;s);</p>
<p>printf(“inet_pton: 0x%x\n”, s.s_addr); &#x2F;&#x2F; 注意得到的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2194385.htm">字节序</a></p>
<p>&#x2F;&#x2F; 反转换</p>
<p><a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2553376.htm">inet_ntop</a>(AF_INET, (void *)&amp;s, IPdotdec, 16);</p>
<p>printf(“inet_ntop: %s\n”, IPdotdec);</p>
<p>}</p>
<h2 id="6-8-其他系统函数"><a href="#6-8-其他系统函数" class="headerlink" title="6.8 其他系统函数"></a>6.8 其他系统函数</h2><h3 id="6-8-1-字符串处理"><a href="#6-8-1-字符串处理" class="headerlink" title="6.8.1 字符串处理"></a>6.8.1 字符串处理</h3><h4 id="6-8-1-1-char-strcasestr-const-char-haystack-const-char-needle"><a href="#6-8-1-1-char-strcasestr-const-char-haystack-const-char-needle" class="headerlink" title="6.8.1.1 char *strcasestr(const char *haystack,const char *needle)"></a>6.8.1.1 char *strcasestr(const char *haystack,const char *needle)</h4><p>在haystack中查找needle第一次出现的位置的char指针</p>
<h4 id="6-8-1-2-char-strtok-char-str-const-char-delimiters"><a href="#6-8-1-2-char-strtok-char-str-const-char-delimiters" class="headerlink" title="6.8.1.2 char *strtok(char *str,const char *delimiters)"></a>6.8.1.2 char *strtok(char *str,const char *delimiters)</h4><p>str:待分割字符串</p>
<p>delimiters：分割符</p>
<p>当strtok()在str中发现delimiters则将delimiters改为’\0’</p>
<p>注意：第一次调用strtok时必须给出str，第二次调用时将str设置成NULL，每次调用成功将会返回分割出片段的指针。</p>
<p>ptr &#x3D; strtok(str,’,’);</p>
<p>if(ptr!&#x3D;NULL)</p>
<p>{</p>
<p>​	ptr&#x3D;strtok(NULL,’,’);</p>
<p>}</p>
<p>strtok_s Windows下的分割字符串函数</p>
<p>char *strtok_s(char *str,const char *strDelimit, char **buf)</p>
<p>函数将剩下的存于buf中</p>
<p>strtok_r Linux下的分割字符串函数</p>
<p>char *strtok_r(char *str,const char *delimit, char **saveptr)</p>
<h3 id="6-8-2-getrlimit-与setrlimit-函数详解"><a href="#6-8-2-getrlimit-与setrlimit-函数详解" class="headerlink" title="6.8.2 getrlimit()与setrlimit()函数详解"></a>6.8.2 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/niocai/archive/2012/04/01/2428128.html">getrlimit()与setrlimit()函数详解</a></h3><p>功能描述：</p>
<p>获取或设定资源使用限制。每种资源都有相关的软硬限制，软限制是内核强加给相应资源的限制值，硬限制是软限制的最大值。非授权调用进程只可以将其软限制指定为0~硬限制范围中的某个值，同时能不可逆转地降低其硬限制。授权进程可以任意改变其软硬限制。RLIM_INFINITY的值表示不对资源限制。</p>
<p>用法：</p>
<p>#include &lt;sys&#x2F;resource.h&gt;<br>int getrlimit(int resource, struct rlimit *rlim);<br>int setrlimit(int resource, const struct rlimit *rlim);</p>
<p>参数：</p>
<p>resource：可能的选择有</p>
<p>RLIMIT_AS &#x2F;&#x2F;进程的最大虚内存空间，字节为单位。<br>RLIMIT_CORE &#x2F;&#x2F;内核转存文件的最大长度。<br>RLIMIT_CPU &#x2F;&#x2F;最大允许的CPU使用时间，秒为单位。当进程达到软限制，内核将给其发送SIGXCPU信号，这一信号的默认行为是终止进程的执行。然而，可以捕捉信号，处理句柄可将控制返回给主程序。如果进程继续耗费CPU时间，核心会以每秒一次的频率给其发送SIGXCPU信号，直到达到硬限制，那时将给进程发送 SIGKILL信号终止其执行。<br>RLIMIT_DATA &#x2F;&#x2F;进程数据段的最大值。<br>RLIMIT_FSIZE &#x2F;&#x2F;进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送SIGXFSZ信号，默认情况下将终止进程的执行。<br>RLIMIT_LOCKS &#x2F;&#x2F;进程可建立的锁和租赁的最大值。<br>RLIMIT_MEMLOCK &#x2F;&#x2F;进程可锁定在内存中的最大数据量，字节为单位。<br>RLIMIT_MSGQUEUE &#x2F;&#x2F;进程可为POSIX消息队列分配的最大字节数。<br>RLIMIT_NICE &#x2F;&#x2F;进程可通过setpriority() 或 nice()调用设置的最大完美值。<br>RLIMIT_NOFILE &#x2F;&#x2F;指定比进程可打开的最大文件描述词大一的值，超出此值，将会产生EMFILE错误。<br>RLIMIT_NPROC &#x2F;&#x2F;用户可拥有的最大进程数。<br>RLIMIT_RTPRIO &#x2F;&#x2F;进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。<br>RLIMIT_SIGPENDING &#x2F;&#x2F;用户可拥有的最大挂起信号数。<br>RLIMIT_STACK &#x2F;&#x2F;最大的进程堆栈，以字节为单位。</p>
<p>rlim：描述资源软硬限制的结构体，原型如下</p>
<p>struct rlimit {<br>　　rlim_t rlim_cur;<br>　　rlim_t rlim_max;<br>};</p>
<p>返回说明：</p>
<p>成功执行时，返回0。失败返回-1，errno被设为以下的某个值<br>EFAULT：rlim指针指向的空间不可访问<br>EINVAL：参数无效<br>EPERM：增加资源限制值时，权能不允许</p>
<p>延伸阅读：</p>
<p>ulimit和setrlimit轻松修改task进程资源上限值</p>
<p>在linux系统中，Resouce limit指在一个进程的执行过程中，它所能得到的资源的限制，比如进程的core file的最大值，虚拟内存的最大值等。</p>
<p>Resouce limit的大小可以直接影响进程的执行状况。其有两个最重要的概念：soft limit 和 hard limit。</p>
<p>struct rlimit {<br>　　rlim_t rlim_cur;　　&#x2F;&#x2F;soft limit<br>　　rlim_t rlim_max;　　&#x2F;&#x2F;hard limit<br>};</p>
<p>soft limit是指内核所能支持的资源上限。比如对于RLIMIT_NOFILE(一个进程能打开的最大文件数，内核默认是1024)，soft limit最大也只能达到1024。对于RLIMIT_CORE(core文件的大小，内核不做限制)，soft limit最大能是unlimited。<br>hard limit在资源中只是作为soft limit的上限。当你设置hard limit后，你以后设置的soft limit只能小于hard limit。要说明的是，hard limit只针对非特权进程，也就是进程的有效用户ID(effective user ID)不是0的进程。具有特权级别的进程(具有属性CAP_SYS_RESOURCE)，soft limit则只有内核上限。</p>
<p>我们可以来看一下下面两条命令的输出。</p>
<p>sishen@sishen:<del>$ ulimit -c -n -s<br>core file size (blocks, -c) 0<br>open files (-n) 1024<br>stack size (kbytes, -s) 8192<br>sishen@sishen:</del>$ ulimit -c -n -s -H<br>core file size (blocks, -c) unlimited<br>open files (-n) 1024<br>stack size (kbytes, -s) unlimited</p>
<p>-H表示显示的是hard limit。从结果上可以看出soft limit和hard limit的区别。unlimited表示no limit, 即内核的最大值。</p>
<p>对于resouce limit的读取修改，有两种方法。</p>
<p>* 使用shell内建命令ulimit<br>* 使用getrlimit和setrlimit API</p>
<p>ulimit是改变shell的resouce limit，并达到改变shell启动的进程的resouce limit效果(子进程继承)。</p>
<p>usage：ulimit [-SHacdefilmnpqrstuvx [limit]]</p>
<p>当不指定limit的时候，该命令显示当前值。这里要注意的是，当你要修改limit的时候，如果不指定-S或者-H，默认是同时设置soft limit和hard limit。也就是之后设置时只能减不能增。所以，建议使用ulimit设置limit参数是加上-S。</p>
<p>getrlimit和setrlimit的使用也很简单，manpage里有很清楚的描述。</p>
<p>int getrlimit(int resource, struct rlimit *rlim);<br>int setrlimit(int resource, const struct rlimit *rlim);</p>
<p>需要注意的是你在setrlimit，需要检查是否成功来判断新值有没有超过hard limit。如下例Linux系统中在应用程序运行过程中经常会遇到程序突然崩溃，提示：Segmentation fault，这是因为应用程序收到了SIGSEGV信号。这个信号提示当进程发生了无效的存储访问，当接收到这个信号时，缺省动作是：终止w&#x2F;core。终止w&#x2F;core的含义是：在进程当前目录生成core文件，并将进程的内存映象复制到core文件中，core文件的默认名称就是“core”（这是 Unix类系统的一个由来已久的功能）。<br>事实上，并不是只有SIGSEGV信号产生coredump，还有下面一些信号也产生coredump：SIGABRT（异常终止）、SIGBUS（硬件故障）、SIGEMT（硬件故障）、SIGFPE（算术异常）、SIGILL（非法硬件指令）、SIGIOT（硬件故障），SIGQUIT，SIGSYS（无效系统调用），SIGTRAP（硬件故障）等。Linux系统中在应用程序运行过程中经常会遇到程序突然崩溃，提示：Segmentation fault，这是因为应用程序收到了SIGSEGV信号。这个信号提示当进程发生了无效的存储访问，当接收到这个信号时，缺省动作是：终止w&#x2F;core。终止w&#x2F;core的含义是：在进程当前目录生成core文件，并将进程的内存映象复制到core文件中，core文件的默认名称就是“core”（这是 Unix类系统的一个由来已久的功能）。<br>事实上，并不是只有SIGSEGV信号产生coredump，还有下面一些信号也产生coredump：SIGABRT（异常终止）、SIGBUS（硬件故障）、SIGEMT（硬件故障）、SIGFPE（算术异常）、SIGILL（非法硬件指令）、SIGIOT（硬件故障），SIGQUIT，SIGSYS（无效系统调用），SIGTRAP（硬件故障）等。对于resouce limit的读取修改，有两种方法。</p>
<p>* 使用shell内建命令ulimit<br>* 使用getrlimit和setrlimit APIsetrlimit：</p>
<p>if (getrlimit(RLIMIT_CORE, &amp;rlim)&#x3D;&#x3D;0) {<br>　　rlim_new.rlim_cur &#x3D; rlim_new.rlim_max &#x3D; RLIM_INFINITY;<br>　　if (setrlimit(RLIMIT_CORE, &amp;rlim_new)!&#x3D;0) {<br>　　　　rlim_new.rlim_cur &#x3D; rlim_new.rlim_max &#x3D; rlim.rlim_max;<br>　　　　(void) setrlimit(RLIMIT_CORE, &amp;rlim_new);<br>　　}<br>}</p>
<h3 id="6-8-3-signal-函数"><a href="#6-8-3-signal-函数" class="headerlink" title="6.8.3 signal()函数"></a>6.8.3 signal()函数</h3><p>在&lt;signal.h&gt; 这个头文件中。</p>
<p>signal（参数1，参数2）；</p>
<p>参数1：我们要进行处理的信号。系统的信号我们可以再终端键入 kill -l查看(共64个)。其实这些信号时系统定义的宏。</p>
<p>参数2：我们处理的方式（是系统默认还是忽略还是捕获）。</p>
<p>一般有3中方式进行操作。</p>
<p>（1）eg: signal(SIGINT ,SIG_ING );</p>
<p>&#x2F;&#x2F;SIG_ING 代表忽略SIGINT信号，SIGINT信号代表由InterruptKey产生，通常是CTRL +C 或者是DELETE 。发送给所有ForeGround Group的进程。</p>
<p>下面我们写个死循环：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps82.png" alt="img"></p>
<p>这时我们保存执行。</p>
<p>按下CTRL _C程序没有反应。这就对了</p>
<p>如果我们想结束该程序可以按下CTRL +\来结束</p>
<p>其实当我们按下CTRL +\组合键时，是产生了SIGQUIT信号</p>
<p>（2）eg: signal(SIGINT ,SIG_DFL );</p>
<p>&#x2F;&#x2F;SIGINT信号代表由InterruptKey产生，通常是CTRL +C或者是DELETE。发送给所有ForeGroundGroup的进程。 SIG_DFL代表执行系统默认操作，其实对于大多数信号的系统默认动作时终止该进程。这与不写此处理函数是一样的。</p>
<p>我们将上面的程序改成</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps83.png" alt="img"></p>
<p>这时就可以按下CTRL +C 来终止该进程了。把signal(SIGINT,SIG_DFL);这句去掉，效果是一样的。</p>
<p>（3） void ( <em>signal( int sig, void (</em> handler)( int )))( int );<br>int (*p)();<br>这是一个函数指针, p所指向的函数是一个不带任何参数, 并且返回值为int的一个函数.<br>int (*fun())();<br>这个式子与上面式子的区别在于用fun()代替了p,而fun()是一个函数,所以说就可以看成是fun()这个函数执行之后,它的返回值是一个函数指针,这个函数指针(其实就是上面的p)所指向的函数是一个不带任何参数,并且返回值为int的一个函数.</p>
<p>void (*signal(int signo, void (*handler)(int)))(int);就可以看成是signal()函数(它自己是带两个参数,一个为整型,一个为函数指针的函数),而这个signal()函数的返回值也为一个函数指针,这个函数指针指向一个带一个整型参数,并且返回值为void的一个函数.</p>
<p>在写信号处理函数时对于信号处理的函数也是void sig_fun(int signo);这种类型,恰好与上面signal()函数所返回的函数指针所指向的函数是一样的.void ( *signal() )( int );</p>
<p>signal是一个函数, 它返回一个函数指针, 后者所指向的函数接受一个整型参数 且没有返回值, 仔细看, 是不是siganal( int signo, void (*handler)(int) )的第2个参数了,对了,其实他所返回的就是 signal的第2个信号处理函数,指向信号处理函数,就可以执行函数了( signal内部时, signal把信号做为参数传递给handler信号处理函数,接着 signal函数返回指针, 并且又指向信号处理函数, 就开始执行它)</p>
<p>那么，signal函数的参数又是如何呢？signal函数接受两个参数：一个整型的信号编号，以及一个指向用户定义的信号处理函数的指针。我们此前已经定义了指向用户定义的信号处理函数的指针sfp：</p>
<p>sfp 的类型可以通过将上面的声明中的sfp去掉而得到，即void (*)(int)。此外，signal函数的返回值是一个指向调用前的用户定义信号处理函数的指针，这个指针的类型与sfp指针类型一致。因此，我们可以如下声明signal函数：</p>
<p>同样地，使用typedef可以简化上面的函数声明：</p>
<p>Ok;看个例子：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps84.png" alt="img"> </p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps85.png" alt="img"></p>
<p>此程序是对当我们按下CTRL +C键时，会执行我们定义的信号处理函数。</p>
<p>每当我们按下CTRL +C键时会打印该信号的number.可以看出该信号的num为2</p>
<p>要想退出可以按下CTRL +\ 打印结果为最后一行。</p>
<p>一些常用的Signal 如下：</p>
<p>注：下面是从百度文库中找的(<em>^__^</em>) 嘻嘻……</p>
<table>
<thead>
<tr>
<th><strong>Signal</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SIGABRT</td>
<td>由调用abort函数产生，进程非正常退出</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>用alarm函数设置的timer超时或setitimer函数设置的interval timer超时</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>某种特定的硬件异常，通常由内存访问引起</td>
</tr>
<tr>
<td>SIGCANCEL</td>
<td>由Solaris Thread Library内部使用，通常不会使用</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>当被stop的进程恢复运行的时候，自动发送</td>
</tr>
<tr>
<td>SIGEMT</td>
<td>和实现相关的硬件异常</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>数学相关的异常，如被0除，浮点溢出，等等</td>
</tr>
<tr>
<td>SIGFREEZE</td>
<td>Solaris专用，Hiberate或者Suspended时候发送</td>
</tr>
<tr>
<td>SIGHUP</td>
<td>发送给具有Terminal的Controlling Process，当terminal被disconnect时候发送</td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法指令异常</td>
</tr>
<tr>
<td>SIGINFO</td>
<td>BSD signal。由Status Key产生，通常是CTRL+T。发送给所有Foreground Group的进程</td>
</tr>
<tr>
<td>SIGINT</td>
<td>由Interrupt Key产生，通常是CTRL+C或者DELETE。发送给所有ForeGround Group的进程</td>
</tr>
<tr>
<td>SIGIO</td>
<td>异步IO事件</td>
</tr>
<tr>
<td>SIGIOT</td>
<td>实现相关的硬件异常，一般对应SIGABRT</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>无法处理和忽略。中止某个进程</td>
</tr>
<tr>
<td>SIGLWP</td>
<td>由Solaris Thread Libray内部使用</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>在reader中止之后写Pipe的时候发送</td>
</tr>
<tr>
<td>SIGPOLL</td>
<td>当某个事件发送给Pollable Device的时候发送</td>
</tr>
<tr>
<td>SIGPROF</td>
<td>Setitimer指定的Profiling Interval Timer所产生</td>
</tr>
<tr>
<td>SIGPWR</td>
<td>和系统相关。和UPS相关。</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>输入Quit Key的时候（CTRL+\）发送给所有Foreground Group的进程</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>非法内存访问</td>
</tr>
<tr>
<td>SIGSTKFLT</td>
<td>Linux专用，数学协处理器的栈异常</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>中止进程。无法处理和忽略。</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>非法系统调用</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>请求中止进程，kill命令缺省发送</td>
</tr>
<tr>
<td>SIGTHAW</td>
<td>Solaris专用，从Suspend恢复时候发送</td>
</tr>
<tr>
<td>SIGTRAP</td>
<td>实现相关的硬件异常。一般是调试异常</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>Suspend Key，一般是Ctrl+Z。发送给所有Foreground Group的进程</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>当Background Group的进程尝试读取Terminal的时候发送</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>当Background Group的进程尝试写Terminal的时候发送</td>
</tr>
<tr>
<td>SIGURG</td>
<td>当out-of-band data接收的时候可能发送</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>用户自定义signal 1</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>用户自定义signal 2</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>setitimer函数设置的Virtual Interval Timer超时的时候</td>
</tr>
<tr>
<td>SIGWAITING</td>
<td>Solaris Thread Library内部实现专用</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>当Terminal的窗口大小改变的时候，发送给Foreground Group的所有进程</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>当CPU时间限制超时的时候</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>进程超过文件大小限制</td>
</tr>
<tr>
<td>SIGXRES</td>
<td>Solaris专用，进程超过资源限制的时候发送</td>
</tr>
</tbody></table>
<h3 id="6-8-4-WIFEXITED-x2F-WEXITSTATUS-x2F-WIFSIGNALED"><a href="#6-8-4-WIFEXITED-x2F-WEXITSTATUS-x2F-WIFSIGNALED" class="headerlink" title="6.8.4 WIFEXITED&#x2F;WEXITSTATUS&#x2F;WIFSIGNALED"></a>6.8.4 WIFEXITED&#x2F;WEXITSTATUS&#x2F;WIFSIGNALED</h3><p>If the exit status value (*note Program Termination::) of the child</p>
<p>process is zero, then the status value reported by <code>waitpid&#39; or </code>wait’</p>
<p>is also zero. You can test for other kinds of information encoded in</p>
<p>the returned status value using the following macros. These macros are</p>
<p>defined in the header file &#96;sys&#x2F;wait.h’.</p>
<p>– Macro: int WIFEXITED (int STATUS)</p>
<p>​     This macro returns a nonzero value if the child process terminated</p>
<p>​     normally with <code>exit&#39; or </code>_exit’.</p>
<p>– Macro: int WEXITSTATUS (int STATUS)</p>
<p>​     If &#96;WIFEXITED’ is true of STATUS, this macro returns the low-order</p>
<p>​     8 bits of the exit status value from the child process. *Note</p>
<p>​     Exit Status::.</p>
<p>– Macro: int WIFSIGNALED (int STATUS)</p>
<p>​     This macro returns a nonzero value if the child process terminated</p>
<p>​     because it received a signal that was not handled. *Note Signal</p>
<p>​     Handling::.</p>
<p>子进程的结束状态返回后存于status，底下有几个宏可判别结束情况</p>
<p>WIFEXITED(status)如果子进程正常结束则为非0值。</p>
<p>WEXITSTATUS(status)取得子进程exit()返回的结束代码，一般会先用WIFEXITED 来判断是否正常结束才能使用此宏。</p>
<p>WIFSIGNALED(status)如果子进程是因为信号而结束则此宏值为真</p>
<p>WTERMSIG(status)取得子进程因信号而中止的信号代码，一般会先用WIFSIGNALED 来判断后才使用此宏。</p>
<p>WIFSTOPPED(status)如果子进程处于暂停执行情况则此宏值为真。一般只有使用WUNTRACED 时才会有此情况。</p>
<p>WSTOPSIG(status)取得引发子进程暂停的信号代码</p>
<h3 id="6-8-5-Linux下send、sendto、sendmsg函数分析"><a href="#6-8-5-Linux下send、sendto、sendmsg函数分析" class="headerlink" title="6.8.5 Linux下send、sendto、sendmsg函数分析"></a>6.8.5 Linux下send、sendto、sendmsg函数分析</h3><p>从网上查到了一些关于这几个函数的使用及注意事项，现终结如下：<br>功能描述：<br>发送消息，send只可用于基于连接的套接字，send 和 write唯一的不同点是标志的存在，当标志为0时，send等同于write。sendto 和 sendmsg既可用于无连接的套接字，也可用于基于连接的套接字。除了套接字设置为非阻塞模式，调用将会阻塞直到数据被发送完。</p>
<p>参数：  </p>
<p>sock：索引将要从其发送数据的套接字。<br>buf：指向将要发送数据的缓冲区。<br>len：以上缓冲区的长度。<br>flags：是以下零个或者多个标志的组合体，可通过or操作连在一起</p>
<p>MSG_DONTROUTE：不要使用网关来发送封包，只发送到直接联网的主机。这个标志主要用于诊断或者路由程序。<br>MSG_DONTWAIT：操作不会被阻塞。<br>MSG_EOR：终止一个记录。<br>MSG_MORE：调用者有更多的数据需要发送。<br>MSG_NOSIGNAL：当另一端终止连接时，请求在基于流的错误套接字上不要发送SIGPIPE信号。<br>MSG_OOB：发送out-of-band数据(需要优先处理的数据)，同时现行协议必须支持此种操作。</p>
<p>to：指向存放接收端地址的区域，可以为NULL。<br>tolen：以上内存区的长度，可以为0。<br>msg：指向存放发送消息头的内存缓冲，结构形态如下</p>
<p>struct msghdr {<br>​    void         *msg_name;<br>​    socklen_t     msg_namelen;<br>​    struct iovec *msg_iov;<br>​    size_t        msg_iovlen;<br>​    void         *msg_control;<br>​    socklen_t     msg_controllen;<br>​    int           msg_flags;<br>}; </p>
<p>可能用到的数据结构有</p>
<p>struct cmsghdr {<br>​    socklen_t cmsg_len;<br>​    int       cmsg_level;<br>​    int       cmsg_type;<br>};<br>返回说明：<br>成功执行时，返回已发送的字节数。失败返回-1，errno被设为以下的某个值<br>EACCES：对于Unix域套接字，不允许对目标套接字文件进行写，或者路径前驱的一个目录节点不可搜索<br>EAGAIN，EWOULDBLOCK： 套接字已标记为非阻塞，而发送操作被阻塞<br>EBADF：sock不是有效的描述词<br>ECONNRESET：连接被用户重置<br>EDESTADDRREQ：套接字不处于连接模式，没有指定对端地址<br>EFAULT：内存空间访问出错<br>EINTR：操作被信号中断<br>EINVAL：参数无效<br>EISCONN：基于连接的套接字已被连接上，同时指定接收对象<br>EMSGSIZE：消息太大<br>ENOMEM：内存不足<br>ENOTCONN：套接字尚未连接，目标没有给出<br>ENOTSOCK：sock索引的不是套接字<br>EPIPE：本地连接已关闭</p>
<h3 id="6-8-6-Makecontext-x2F-getcontext-x2F-swapcontext实现用户线程"><a href="#6-8-6-Makecontext-x2F-getcontext-x2F-swapcontext实现用户线程" class="headerlink" title="6.8.6 Makecontext&#x2F;getcontext&#x2F;swapcontext实现用户线程"></a>6.8.6 <strong>Makecontext</strong><strong>&#x2F;getcontext&#x2F;swapcontext<strong><strong>实现用户线程</strong></strong></strong></h3><h4 id="6-8-6-1-ucontext-t"><a href="#6-8-6-1-ucontext-t" class="headerlink" title="6.8.6.1 ucontext_t"></a>6.8.6.1 ucontext_t</h4><p>typedef struct ucontext                 &#x2F;&#x2F;用户级线程上下文 </p>
<p>{ </p>
<p>unsigned long int uc_flags; </p>
<p>struct ucontext *uc_link;             &#x2F;&#x2F;保存线程退出时返回的上下文 </p>
<p>stack_t uc_stack;                   &#x2F;&#x2F;线程栈 </p>
<p>mcontext_t uc_mcontext; </p>
<p>__sigset_t uc_sigmask; </p>
<p>struct _libc_fpstate __fpregs_mem; </p>
<p>} ucontext_t; </p>
<p>typedef struct sigaltstack { </p>
<p>void *ss_sp;                             &#x2F;&#x2F;栈顶指针 </p>
<p>int ss_flags; </p>
<p>size_t ss_size;                            &#x2F;&#x2F;栈大小 </p>
<p>} stack_t;</p>
<h4 id="6-8-6-2-Ucontext-1"><a href="#6-8-6-2-Ucontext-1" class="headerlink" title="6.8.6.2 Ucontext 1"></a>6.8.6.2 Ucontext 1</h4><p>现代Unix系统都在ucontext.h中提供用于上下文切换的函数，这些函数有getcontext, setcontext，swapcontext 和makecontext。</p>
<p>getcontext用于保存当前上下文;</p>
<p>setcontext用于切换上下文;</p>
<p>swapcontext会保存当前上下文并切换到另一个上下文；</p>
<p>makecontext创建一个新的上下文。</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps86.jpg" alt="img"> </p>
<p><strong>用户级线程的抢占</strong></p>
<h4 id="6-8-6-3-ucontext机制2"><a href="#6-8-6-3-ucontext机制2" class="headerlink" title="6.8.6.3 ucontext机制2"></a>6.8.6.3 ucontext机制2</h4><p>所谓 “ucontext” 机制是 GNU C 库提供的一组用于创建、保存、切换用户态执行“上下文”（context）的API，可以看作是 “setjmp&#x2F;long_jmp” 的“升级版”，主要包括以下四个函数：</p>
<p>void makecontext(ucontext_t *ucp, void (*func)(), int argc, …);</p>
<p>int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</p>
<p>int getcontext(ucontext_t *ucp);</p>
<p>int setcontext(const ucontext_t *ucp);</p>
<p>结构体 ucontext_t 和上述4个函数声明一起定义在系统头文件&lt;ucontext.h&gt; 中，该类型的具体实现与体系结构相关，但规范要求其至少要包含以下字段：</p>
<p>typedef struct ucontext {</p>
<p>  struct ucontext *uc_link;</p>
<p>​    sigset_t       uc_sigmask;</p>
<p>​    stack_t         uc_stack;</p>
<p>​    mcontext_t uc_mcontext;</p>
<p>​    …</p>
<p>} ucontext_t;</p>
<p>其中 sigset_t 和 stack_t 定义在标准头文件 &lt;signal.h&gt; 中， uc_link 字段保存当前context结束后继续执行的context记录， uc_sigmask 记录该context运行阶段需要屏蔽的信号，uc_stack 是该context运行的栈信息， 最后一个字段uc_mcontext 则保存具体的程序执行上下文——如PC值、堆栈指针、寄存器值等信息——其实现方式依赖于底层运行的系统架构，是平台、硬件相关的。</p>
<p>下面具体来看每个函数的功能：</p>
<p>• int makecontext(ucontext_t *ucp, void (*func)(), int argc, …) 该函数用以初始化一个ucontext_t类型的结构，也就是我们所说的用户执行上下文。函数指针func指明了该context的入口函数，argc指明入口参数个数，该值是可变的，但每个参数类型都是int型，这些参数紧随argc传入。 另外，在调用makecontext之前，一般还需要显式的指明其初始栈信息（栈指针SP及栈大小）和运行时的信号屏蔽掩码（signal mask）。 同时也可以指定uc_link字段，这样在func函数返回后，就会切换到uc_link指向的context继续执行。</p>
<p>• int setcontext(const ucontext_t *ucp) 该函数用来将当前程序执行线索切换到参数ucp所指向的上下文状态，在执行正确的情况下，该函数直接切入到新的执行状态，不再会返回。比如我们用上面介绍的makecontext初始化了一个新的上下文，并将入口指向某函数entry()，那么setcontext成功后就会马上运行entry()函数。</p>
<p>• int getcontext(ucontext_t *ucp) 该函数用来将当前执行状态上下文保存到一个ucontext_t结构中，若后续调用setcontext或swapcontext恢复该状态，则程序会沿着getcontext调用点之后继续执行，看起来好像刚从getcontext函数返回一样。 这个操作的功能和setjmp所起的作用类似，都是保存执行状态以便后续恢复执行，但需要重点指出的是：getcontext函数的返回值仅能表示本次操作是否执行正确，而不能用来区分是直接从getcontext操作返回，还是由于setcontext&#x2F;swapcontex恢复状态导致的返回，这点与setjmp是不一样的。</p>
<p>• int swapcontext(ucontext_t *oucp, ucontext_t *ucp) 理论上，有了上面的3个函数，就可以满足需要了（后面讲的libgo就只用了这3个函数，而实际只需setcontext&#x2F;getcontext就足矣了），但由于getcontext不能区分返回状态，因此编写上下文切换的代码时就需要保存额外的信息来进行判断，显得比较麻烦。 为了简化切换操作的实现，ucontext 机制里提供了swapcontext这个函数，用来“原子”地完成旧状态的保存和切换到新状态的工作（当然，这并非真正的原子操作，在多线程情况下也会引入一些调度方面的问题，后面会详细介绍）。 为了进一步理解swapcontext这个函数的设计目的，可以尝试利用getcontext&#x2F;setcontext完成同样的功能，你需要怎样编写代码？ 同时，也不妨思考一下下面这段代码的执行结果（该例出自维基百科Setcontext 条目）：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;ucontext.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main(int argc, char *argv[]) {</p>
<p>  ucontext_t context;</p>
<p>  getcontext(&amp;context);</p>
<p>  puts(“Hello world”);</p>
<p>  sleep(1);</p>
<p>  setcontext(&amp;context);</p>
<p>  return 0;</p>
<p>}</p>
<p>可以看出，用ucontext机制实现一个“协程”系统并不困难。 实际上，每个运行上下文（ucontext_t）就直接对应于“协程”概念，对于协程的“创建”（Create）、“启动” （Spawn）、“挂起” （Suspend）、“切换” （Swap）等操作，很容易通过上面的4个API及其组合加以实现，需要的工作仅在于设计一组数据结构保存暂不运行的context结构，提供一些调度的策略即可。 这方面的开源实现有很多，其中最著名的就是Go的前身，libtask库。</p>
<p>对于将“协程”映射到多OS线程执行的情形，就要稍稍复杂一些，但主要的问题是集中在共享任务队列的实现、调度线程间的互斥等，至于“协程”的映射问题，与单线程情况没有太大的区别。 对于这方面的开源借鉴，当然首推Go的运行时 —— 但由于标准Go实现没有使用GNU C库，而是自行设计了包括C编译器在内的整套工具链，因而就没有直接采用ucontext机制（尽管其内部实现机制与ucontext原理类似）。</p>
<p>在下一篇中，会转而分析Go语言前端的运行时实现——libgo。libgo的调度器部分基本用C开发并由GCC编译，“goroutine”（Go语言中相对于“协程”的概念）也直接以“ucontext”机制实现，其代码对于分析C语言下“协程”系统实现方法而言，具有较高的参考价值。</p>
<h4 id="6-8-6-4-Ucontext协程理解3"><a href="#6-8-6-4-Ucontext协程理解3" class="headerlink" title="6.8.6.4 Ucontext协程理解3"></a>6.8.6.4 Ucontext协程理解3</h4><p>1.干货写在前面</p>
<p>协程是一种用户态的轻量级线程。本篇主要研究协程的C&#x2F;C++的实现。<br>首先我们可以看看有哪些语言已经具备协程语义：</p>
<p>比较重量级的有C#、erlang、golang*</p>
<p>轻量级有python、lua、javascript、ruby</p>
<p>还有函数式的scala、scheme等。</p>
<p>c&#x2F;c++不直接支持协程语义，但有不少开源的协程库，如：<br>Protothreads：<a target="_blank" rel="noopener" href="http://coolshell.cn/articles/10975.html">一个“蝇量级” C 语言协程库</a><br>libco:<a target="_blank" rel="noopener" href="http://www.cnblogs.com/bangerlee/p/4003160.html">来自腾讯的开源协程库libco介绍</a>，<a target="_blank" rel="noopener" href="http://code.tencent.com/libco.html">官网</a><br>coroutine:<a target="_blank" rel="noopener" href="https://github.com/cloudwu/coroutine/">云风的一个C语言同步协程库</a>,<a target="_blank" rel="noopener" href="http://blog.codingnow.com/2012/07/c_coroutine.html">详细信息</a></p>
<p>目前看到大概有四种实现协程的方式：</p>
<p>第一种：利用glibc 的 ucontext组件(云风的库)</p>
<p>第二种：使用汇编代码来切换上下文(<a target="_blank" rel="noopener" href="http://www.cnblogs.com/sniperHW/archive/2012/06/19/2554574.html">实现c协程</a>)</p>
<p>第三种：利用C语言语法switch-case的奇淫技巧来实现（Protothreads)</p>
<p>第四种：利用了 C 语言的 setjmp 和 longjmp（ <a target="_blank" rel="noopener" href="http://www.cnblogs.com/Pony279/p/3903048.html">一种协程的 C&#x2F;C++ 实现</a>,要求函数里面使用 static local 的变量来保存协程内部的数据）</p>
<p>本篇主要使用ucontext来实现简单的协程库。</p>
<p>2.ucontext初接触</p>
<p>利用ucontext提供的四个函数getcontext(),setcontext(),makecontext(),swapcontext()可以在一个进程中实现用户级的线程切换。</p>
<p>本节我们先来看ucontext实现的一个简单的例子：</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps87.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps88.png" alt="img"></p>
<p>#include &lt;stdio.h&gt;  </p>
<p>#include &lt;ucontext.h&gt;  </p>
<p>#include &lt;unistd.h&gt;  </p>
<p>int main(int argc, const char *argv[]){  </p>
<p>​    ucontext_t context;  </p>
<p>​    getcontext(&amp;context);  </p>
<p>​    puts(“Hello world”);  </p>
<p>​    sleep(1);  </p>
<p>​    setcontext(&amp;context);  </p>
<p>​    return 0;  </p>
<p>}  </p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;ucontext.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main(int argc, const char *argv[]){</p>
<p>​    ucontext_t context;</p>
<p>​    getcontext(&amp;context);</p>
<p>​    puts(“Hello world”);</p>
<p>​    sleep(1);</p>
<p>​    setcontext(&amp;context);</p>
<p>​    return 0;</p>
<p>}</p>
<p>注：示例代码来自<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Setcontext">维基百科</a>.</p>
<p>保存上述代码到example.c,执行编译命令：</p>
<p>gcc example.c -o example</p>
<p>想想程序运行的结果会是什么样？</p>
<p>[plain] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps89.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps90.png" alt="img"></p>
<p>cxy@ubuntu:~$ .&#x2F;example   </p>
<p>Hello world  </p>
<p>Hello world  </p>
<p>Hello world  </p>
<p>Hello world  </p>
<p>Hello world  </p>
<p>Hello world  </p>
<p>Hello world  </p>
<p>^C  </p>
<p>cxy@ubuntu:~$  </p>
<p>cxy@ubuntu:~$ .&#x2F;example </p>
<p>Hello world</p>
<p>Hello world</p>
<p>Hello world</p>
<p>Hello world</p>
<p>Hello world</p>
<p>Hello world</p>
<p>Hello world</p>
<p>^C</p>
<p>cxy@ubuntu:~$</p>
<p>上面是程序执行的部分输出，不知道是否和你想得一样呢？我们可以看到，程序在输出第一个“Hello world”后并没有退出程序，而是持续不断的输出”Hello world“。其实是程序通过getcontext先保存了一个上下文,然后输出”Hello world”,在通过setcontext恢复到getcontext的地方，重新执行代码，所以导致程序不断的输出”Hello world“，在我这个菜鸟的眼里，这简直就是一个神奇的跳转。 </p>
<p>那么问题来了，ucontext到底是什么？</p>
<p>3.ucontext组件到底是什么</p>
<p>在类System V环境中,在头文件&lt; ucontext.h &gt; 中定义了两个结构类型，mcontext_t和ucontext_t和四个函数getcontext(),setcontext(),makecontext(),swapcontext().利用它们可以在一个进程中实现用户级的线程切换。</p>
<p>mcontext_t类型与机器相关，并且不透明.ucontext_t结构体则至少拥有以下几个域:</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps91.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps92.png" alt="img"></p>
<p>typedef struct ucontext {  </p>
<p>​    struct ucontext *uc_link;  </p>
<p>​    sigset_t         uc_sigmask;  </p>
<p>​    stack_t          uc_stack;  </p>
<p>​    mcontext_t       uc_mcontext;  </p>
<p>​    …  </p>
<p>} ucontext_t;  </p>
<p>​           typedef struct ucontext {</p>
<p>​               struct ucontext *uc_link;</p>
<p>​               sigset_t         uc_sigmask;</p>
<p>​               stack_t          uc_stack;</p>
<p>​               mcontext_t       uc_mcontext;</p>
<p>​               …</p>
<p>​           } ucontext_t;</p>
<p>当当前上下文(如使用makecontext创建的上下文）运行终止时系统会恢复uc_link指向的上下文；uc_sigmask为该上下文中的阻塞信号集合；uc_stack为该上下文中使用的栈；uc_mcontext保存的上下文的特定机器表示，包括调用线程的特定寄存器等。</p>
<p>下面详细介绍四个函数：</p>
<p>int getcontext(ucontext_t *ucp);</p>
<p>初始化ucp结构体，将当前的上下文保存到ucp中</p>
<p>int setcontext(const ucontext_t *ucp);</p>
<p>设置当前的上下文为ucp，setcontext的上下文ucp应该通过getcontext或者makecontext取得，如果调用成功则不返回。如果上下文是通过调用getcontext()取得,程序会继续执行这个调用。如果上下文是通过调用makecontext取得,程序会调用makecontext函数的第二个参数指向的函数，如果func函数返回,则恢复makecontext第一个参数指向的上下文第一个参数指向的上下文context_t中指向的uc_link.如果uc_link为NULL,则线程退出。</p>
<p>void makecontext(ucontext_t *ucp, void (*func)(), int argc, …);</p>
<p>makecontext修改通过getcontext取得的上下文ucp(这意味着调用makecontext前必须先调用getcontext)。然后给该上下文指定一个栈空间ucp-&gt;stack，设置后继的上下文ucp-&gt;uc_link.</p>
<p>当上下文通过setcontext或者swapcontext激活后，执行func函数，argc为func的参数个数，后面是func的参数序列。当func执行返回后，继承的上下文被激活，如果继承上下文为NULL时，线程退出。</p>
<p>int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</p>
<p>保存当前上下文到oucp结构体中，然后激活upc上下文。 </p>
<p>如果执行成功，getcontext返回0，setcontext和swapcontext不返回；如果执行失败，getcontext,setcontext,swapcontext返回-1，并设置对于的errno.</p>
<p>简单说来， getcontext获取当前上下文，setcontext设置当前上下文，swapcontext切换上下文，makecontext创建一个新的上下文。</p>
<p>4.小试牛刀-使用ucontext组件实现线程切换</p>
<p>虽然我们称协程是一个用户态的轻量级线程，但实际上多个协程同属一个线程。任意一个时刻，同一个线程不可能同时运行两个协程。如果我们将协程的调度简化为：主函数调用协程1，运行协程1直到协程1返回主函数，主函数在调用协程2，运行协程2直到协程2返回主函数。示意步骤如下：</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps93.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps94.png" alt="img"></p>
<p>执行主函数  </p>
<p>切换：主函数 –&gt; 协程1  </p>
<p>执行协程1  </p>
<p>切换：协程1  –&gt; 主函数  </p>
<p>执行主函数  </p>
<p>切换：主函数 –&gt; 协程2  </p>
<p>执行协程2  </p>
<p>切换协程2  –&gt; 主函数  </p>
<p>执行主函数  </p>
<p>这种设计的关键在于实现主函数到一个协程的切换，然后从协程返回主函数。这样无论是一个协程还是多个协程都能够完成与主函数的切换，从而实现协程的调度。 </p>
<p>实现用户线程的过程是：</p>
<p>我们首先调用getcontext获得当前上下文</p>
<p>修改当前上下文ucontext_t来指定新的上下文，如指定栈空间极其大小，设置用户线程执行完后返回的后继上下文（即主函数的上下文）等</p>
<p>调用makecontext创建上下文，并指定用户线程中要执行的函数</p>
<p>切换到用户线程上下文去执行用户线程（如果设置的后继上下文为主函数，则用户线程执行完后会自动返回主函数）。</p>
<p>下面代码context_test函数完成了上面的要求。</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps95.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps96.png" alt="img"></p>
<p>#include &lt;ucontext.h&gt;  </p>
<p>#include &lt;stdio.h&gt;  </p>
<p>void func1(void * arg)  </p>
<p>{  </p>
<p>​    puts(“1”);  </p>
<p>​    puts(“11”);  </p>
<p>​    puts(“111”);  </p>
<p>​    puts(“1111”);  </p>
<p>}  </p>
<p>void context_test()  </p>
<p>{  </p>
<p>​    char stack[1024*128];  </p>
<p>​    ucontext_t child,main;  </p>
<p>​    getcontext(&amp;child); &#x2F;&#x2F;获取当前上下文  </p>
<p>​    child.uc_stack.ss_sp &#x3D; stack;&#x2F;&#x2F;指定栈空间  </p>
<p>​    child.uc_stack.ss_size &#x3D; sizeof(stack);&#x2F;&#x2F;指定栈空间大小  </p>
<p>​    child.uc_stack.ss_flags &#x3D; 0;  </p>
<p>​    child.uc_link &#x3D; &amp;main;&#x2F;&#x2F;设置后继上下文  </p>
<p>​    makecontext(&amp;child,(void (*)(void))func1,0);&#x2F;&#x2F;修改上下文指向func1函数  </p>
<p>​    swapcontext(&amp;main,&amp;child);&#x2F;&#x2F;切换到child上下文，保存当前上下文到main  </p>
<p>​    puts(“main”);&#x2F;&#x2F;如果设置了后继上下文，func1函数指向完后会返回此处  </p>
<p>}  </p>
<p>int main()  </p>
<p>{  </p>
<p>​    context_test();  </p>
<p>​    return 0;  </p>
<p>}  </p>
<p>在context_test中，创建了一个用户线程child,其运行的函数为func1.指定后继上下文为main<br>func1返回后激活后继上下文，继续执行主函数。</p>
<p>保存上面代码到example-switch.cpp.运行编译命令:</p>
<p>g++ example-switch.cpp -o example-switch</p>
<p>执行程序结果如下</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a></p>
<p>cxy@ubuntu:~$ .&#x2F;example-switch  </p>
<p>1  </p>
<p>11  </p>
<p>111  </p>
<p>1111  </p>
<p>main  </p>
<p>cxy@ubuntu:~$  </p>
<p>你也可以通过修改后继上下文的设置，来观察程序的行为。如修改代码 </p>
<p>child.uc_link &#x3D; &amp;main;为child.uc_link &#x3D; NULL;</p>
<p>再重新编译执行，其执行结果为：</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps97.png" alt="img"></p>
<p>cxy@ubuntu:~$ .&#x2F;example-switch  </p>
<p>1  </p>
<p>11  </p>
<p>111  </p>
<p>1111  </p>
<p>cxy@ubuntu:~$ </p>
<p>可以发现程序没有打印”main”，执行为func1后直接退出，而没有返回主函数。可见，如果要实现主函数到线程的切换并返回，指定后继上下文是非常重要的。 </p>
<p>5.使用ucontext实现自己的线程库</p>
<p>掌握了上一节从主函数到协程的切换的关键，我们就可以开始考虑实现自己的协程了。<br>定义一个协程的结构体如下：</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps98.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps99.png" alt="img"></p>
<p>typedef void (*Fun)(void *arg);  </p>
<p>typedef struct uthread_t  </p>
<p>{  </p>
<p>​    ucontext_t ctx;  </p>
<p>​    Fun func;  </p>
<p>​    void *arg;  </p>
<p>​    enum ThreadState state;  </p>
<p>​    char stack[DEFAULT_STACK_SZIE];  </p>
<p>}uthread_t;  </p>
<p>typedef void (*Fun)(void *arg);</p>
<p>typedef struct uthread_t</p>
<p>{</p>
<p>​    ucontext_t ctx;</p>
<p>​    Fun func;</p>
<p>​    void *arg;</p>
<p>​    enum ThreadState state;</p>
<p>​    char stack[DEFAULT_STACK_SZIE];</p>
<p>}uthread_t;</p>
<p>ctx保存协程的上下文，stack为协程的栈，栈大小默认为DEFAULT_STACK_SZIE&#x3D;128Kb.你可以根据自己的需求更改栈的大小。func为协程执行的用户函数，arg为func的参数，state表示协程的运行状态，包括FREE,RUNNABLE,RUNING,SUSPEND,分别表示空闲，就绪，正在执行和挂起四种状态。 </p>
<p>在定义一个调度器的结构体</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps100.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps101.png" alt="img"></p>
<p>typedef std::vector<uthread_t> Thread_vector;  </p>
<p>typedef struct schedule_t  </p>
<p>{  </p>
<p>​    ucontext_t main;  </p>
<p>​    int running_thread;  </p>
<p>​    Thread_vector threads;  </p>
<p>​    schedule_t():running_thread(-1){}  </p>
<p>}schedule_t;  </p>
<p>typedef std::vector<uthread_t> Thread_vector;</p>
<p>typedef struct schedule_t</p>
<p>{</p>
<p>​    ucontext_t main;</p>
<p>​    int running_thread;</p>
<p>​    Thread_vector threads;</p>
<p>​    schedule_t():running_thread(-1){}</p>
<p>}schedule_t;</p>
<p>调度器包括主函数的上下文main,包含当前调度器拥有的所有协程的vector类型的threads，以及指向当前正在执行的协程的编号running_thread.如果当前没有正在执行的协程时，running_thread&#x3D;-1. </p>
<p>接下来，在定义几个使用函数uthread_create,uthread_yield,uthread_resume函数已经辅助函数schedule_finished.就可以了。</p>
<p>int  uthread_create(schedule_t &amp;schedule,Fun func,void *arg);</p>
<p>创建一个协程，该协程的会加入到schedule的协程序列中，func为其执行的函数，arg为func的执行函数。返回创建的线程在schedule中的编号。</p>
<p>void uthread_yield(schedule_t &amp;schedule);</p>
<p>挂起调度器schedule中当前正在执行的协程，切换到主函数。</p>
<p>void uthread_resume(schedule_t &amp;schedule,int id);</p>
<p>恢复运行调度器schedule中编号为id的协程</p>
<p>int  schedule_finished(const schedule_t &amp;schedule);</p>
<p>判断schedule中所有的协程是否都执行完毕，是返回1，否则返回0.注意：如果有协程处于挂起状态时算作未全部执行完毕，返回0.</p>
<p>代码就不全贴出来了，我们来看看两个关键的函数的具体实现。首先是uthread_resume函数：</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps102.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps103.png" alt="img"></p>
<p>void uthread_resume(schedule_t &amp;schedule , int id)  </p>
<p>{  </p>
<p>​    if(id &lt; 0 || id &gt;&#x3D; schedule.threads.size()){  </p>
<p>​        return;  </p>
<p>​    }  </p>
<p>​    uthread_t *t &#x3D; &amp;(schedule.threads[id]);  </p>
<p>​    switch(t-&gt;state){  </p>
<p>​        case RUNNABLE:  </p>
<p>​            getcontext(&amp;(t-&gt;ctx));  </p>
<p>​            t-&gt;ctx.uc_stack.ss_sp &#x3D; t-&gt;stack;  </p>
<p>​            t-&gt;ctx.uc_stack.ss_size &#x3D; DEFAULT_STACK_SZIE;  </p>
<p>​            t-&gt;ctx.uc_stack.ss_flags &#x3D; 0;  </p>
<p>​            t-&gt;ctx.uc_link &#x3D; &amp;(schedule.main);  </p>
<p>​            t-&gt;state &#x3D; RUNNING;  </p>
<p>​            schedule.running_thread &#x3D; id;  </p>
<p>​            makecontext(&amp;(t-&gt;ctx),(void (*)(void))(uthread_body),1,&amp;schedule);  </p>
<p>​            &#x2F;* !! note : Here does not need to break *&#x2F;  </p>
<p>​        case SUSPEND:  </p>
<p>​            swapcontext(&amp;(schedule.main),&amp;(t-&gt;ctx));  </p>
<p>​            break;  </p>
<p>​        default: ;  </p>
<p>​    }  </p>
<p>}  </p>
<p>void uthread_resume(schedule_t &amp;schedule , int id)</p>
<p>{</p>
<p>​    if(id &lt; 0 || id &gt;&#x3D; schedule.threads.size()){</p>
<p>​        return;</p>
<p>​    }</p>
<p>​    uthread_t *t &#x3D; &amp;(schedule.threads[id]);</p>
<p>​    switch(t-&gt;state){</p>
<p>​        case RUNNABLE:</p>
<p>​            getcontext(&amp;(t-&gt;ctx));</p>
<p>​            t-&gt;ctx.uc_stack.ss_sp &#x3D; t-&gt;stack;</p>
<p>​            t-&gt;ctx.uc_stack.ss_size &#x3D; DEFAULT_STACK_SZIE;</p>
<p>​            t-&gt;ctx.uc_stack.ss_flags &#x3D; 0;</p>
<p>​            t-&gt;ctx.uc_link &#x3D; &amp;(schedule.main);</p>
<p>​            t-&gt;state &#x3D; RUNNING;</p>
<p>​            schedule.running_thread &#x3D; id;</p>
<p>​            makecontext(&amp;(t-&gt;ctx),(void (*)(void))(uthread_body),1,&amp;schedule);</p>
<p>​            &#x2F;* !! note : Here does not need to break *&#x2F;</p>
<p>​        case SUSPEND:</p>
<p>​            swapcontext(&amp;(schedule.main),&amp;(t-&gt;ctx));</p>
<p>​            break;</p>
<p>​        default: ;</p>
<p>​    }</p>
<p>}</p>
<p>如果指定的协程是首次运行，处于RUNNABLE状态，则创建一个上下文，然后切换到该上下文。如果指定的协程已经运行过，处于SUSPEND状态，则直接切换到该上下文即可。代码中需要注意RUNNBALE状态的地方不需要break. </p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps104.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps105.png" alt="img"></p>
<p>void uthread_yield(schedule_t &amp;schedule)  </p>
<p>{  </p>
<p>​    if(schedule.running_thread !&#x3D; -1 ){  </p>
<p>​        uthread_t *t &#x3D; &amp;(schedule.threads[schedule.running_thread]);  </p>
<p>​        t-&gt;state &#x3D; SUSPEND;  </p>
<p>​        schedule.running_thread &#x3D; -1;  </p>
<p>​        swapcontext(&amp;(t-&gt;ctx),&amp;(schedule.main));  </p>
<p>​    }  </p>
<p>}  </p>
<p>void uthread_yield(schedule_t &amp;schedule)</p>
<p>{</p>
<p>​    if(schedule.running_thread !&#x3D; -1 ){</p>
<p>​        uthread_t *t &#x3D; &amp;(schedule.threads[schedule.running_thread]);</p>
<p>​        t-&gt;state &#x3D; SUSPEND;</p>
<p>​        schedule.running_thread &#x3D; -1;</p>
<p>​        swapcontext(&amp;(t-&gt;ctx),&amp;(schedule.main));</p>
<p>​    }</p>
<p>}</p>
<p>uthread_yield挂起当前正在运行的协程。首先是将running_thread置为-1，将正在运行的协程的状态置为SUSPEND，最后切换到主函数上下文。 </p>
<p>更具体的代码我已经放到github上,<a target="_blank" rel="noopener" href="https://github.com/Winnerhust/uthread">点击这里</a>。</p>
<p>6.最后一步-使用我们自己的协程库</p>
<p>保存下面代码到example-uthread.cpp.</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps106.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps107.png" alt="img"></p>
<p>#include “uthread.h”  </p>
<p>#include &lt;stdio.h&gt;  </p>
<p>void func2(void * arg)  </p>
<p>{  </p>
<p>​    puts(“22”);  </p>
<p>​    puts(“22”);  </p>
<p>​    uthread_yield(*(schedule_t *)arg);  </p>
<p>​    puts(“22”);  </p>
<p>​    puts(“22”);  </p>
<p>}  </p>
<p>void func3(void *arg)  </p>
<p>{  </p>
<p>​    puts(“3333”);  </p>
<p>​    puts(“3333”);  </p>
<p>​    uthread_yield(*(schedule_t *)arg);  </p>
<p>​    puts(“3333”);  </p>
<p>​    puts(“3333”);  </p>
<p>}  </p>
<p>void schedule_test()  </p>
<p>{  </p>
<p>​    schedule_t s;  </p>
<p>​    int id1 &#x3D; uthread_create(s,func3,&amp;s);  </p>
<p>​    int id2 &#x3D; uthread_create(s,func2,&amp;s);  </p>
<p>​    while(!schedule_finished(s)){  </p>
<p>​        uthread_resume(s,id2);  </p>
<p>​        uthread_resume(s,id1);  </p>
<p>​    }  </p>
<p>​    puts(“main over”);  </p>
<p>}  </p>
<p>int main()  </p>
<p>{  </p>
<p>​    schedule_test();  </p>
<p>​    return 0;  </p>
<p>}  </p>
<p>#include “uthread.h”</p>
<p>#include &lt;stdio.h&gt;</p>
<p>void func2(void * arg)</p>
<p>{</p>
<p>​    puts(“22”);</p>
<p>​    puts(“22”);</p>
<p>​    uthread_yield(*(schedule_t *)arg);</p>
<p>​    puts(“22”);</p>
<p>​    puts(“22”);</p>
<p>}</p>
<p>void func3(void *arg)</p>
<p>{</p>
<p>​    puts(“3333”);</p>
<p>​    puts(“3333”);</p>
<p>​    uthread_yield(*(schedule_t *)arg);</p>
<p>​    puts(“3333”);</p>
<p>​    puts(“3333”);</p>
<p>}</p>
<p>void schedule_test()</p>
<p>{</p>
<p>​    schedule_t s;</p>
<p>​    int id1 &#x3D; uthread_create(s,func3,&amp;s);</p>
<p>​    int id2 &#x3D; uthread_create(s,func2,&amp;s);</p>
<p>​    while(!schedule_finished(s)){</p>
<p>​        uthread_resume(s,id2);</p>
<p>​        uthread_resume(s,id1);</p>
<p>​    }</p>
<p>​    puts(“main over”);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>​    schedule_test();</p>
<p>​    return 0;</p>
<p>}</p>
<p>执行编译命令并运行：</p>
<p>g++ example-uthread.cpp -o example-uthread</p>
<p>.&#x2F;example-uthread</p>
<p>运行结果如下：</p>
<p>[cpp] <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">view plain</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">copy</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">print</a><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq910894904/article/details/41911175">?</a><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps108.jpg" alt="img"><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps109.png" alt="img"></p>
<p>cxy@ubuntu:~&#x2F;mythread$.&#x2F;example-uthread  </p>
<p>22  </p>
<p>22  </p>
<p>3333  </p>
<p>3333  </p>
<p>22  </p>
<p>22  </p>
<p>3333  </p>
<p>3333  </p>
<p>main over  </p>
<p>cxy@ubuntu:~&#x2F;mythread$  </p>
<p>cxy@ubuntu:~&#x2F;mythread$.&#x2F;example-uthread</p>
<p>22</p>
<p>22</p>
<p>3333</p>
<p>3333</p>
<p>22</p>
<p>22</p>
<p>3333</p>
<p>3333</p>
<p>main over</p>
<p>cxy@ubuntu:~&#x2F;mythread$</p>
<p>可以看到，程序协程func2，然后切换到主函数,在执行协程func3，再切换到主函数，又切换到func2,在切换到主函数，再切换到func3,最后切换到主函数结束。 </p>
<p>总结一下，我们利用getcontext和makecontext创建上下文，设置后继的上下文到主函数，设置每个协程的栈空间。在利用swapcontext在主函数和协程之间进行切换。</p>
<p>到此，使用ucontext做一个自己的协程库就到此结束了。相信你也可以自己完成自己的协程库了。</p>
<p>最后，代码我已经放到github上,<a target="_blank" rel="noopener" href="https://github.com/Winnerhust/uthread">点击这里</a>。</p>
<h3 id="6-8-7-Linux下使用popen-执行shell命令"><a href="#6-8-7-Linux下使用popen-执行shell命令" class="headerlink" title="6.8.7 Linux下使用popen()执行shell命令"></a>6.8.7 Linux下使用popen()执行shell命令</h3><p>简单说一下popen()函数</p>
<p><strong>函数定义</strong>****</p>
<p>#include &lt;stdio.h&gt;</p>
<p>FILE * popen(const char *command , const char *type );</p>
<p>int pclose(FILE *stream);</p>
<p><strong>函数说明</strong>****</p>
<p>　　popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。这个管道必须由pclose()函数关闭，而不是fclose()函数。pclose()函数关闭标准I&#x2F;O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose()返回的终止状态与shell已执行exit一样。</p>
<p>　　type参数只能是读或者写中的一种，得到的返回值（标准I&#x2F;O流）也具有和type相应的只读或只写类型。如果type是”r”则文件指针连接到command的标准输出；如果type是”w”则文件指针连接到command的标准输入。</p>
<p>　　command参数是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin&#x2F;sh并使用-c标志，shell将执行这个命令。</p>
<p>　　popen()的返回值是个标准I&#x2F;O流，必须由pclose来终止。前面提到这个流是单向的（只能用于读或写）。向这个流写内容相当于写入该命令的标准输入，命令的标准输出和调用popen()的进程相同；与之相反的，从流中读数据相当于读取命令的标准输出，命令的标准输入和调用popen()的进程相同。</p>
<p><strong>返回值</strong>****</p>
<p>　　如果调用fork()或pipe()失败，或者不能分配内存将返回NULL，否则返回标准I&#x2F;O流。popen()没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回EINVAL。</p>
<p>附上一个例子：</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7452\wps110.png" alt="img"> </p>
<p>&#x2F;&#x2F;execute shell command<br>&#x2F;&#x2F;执行一个shell命令，输出结果逐行存储在resvec中，并返回行数</p>
<p>int32_t myexec(const char *cmd, vector<string> &amp;resvec) {</p>
<p>​    resvec.clear();</p>
<p>​    FILE *pp &#x3D; popen(cmd, “r”); &#x2F;&#x2F;建立管道</p>
<p>​    if (!pp) {</p>
<p>​        return -1;</p>
<p>​    }<br>​    char tmp[1024]; &#x2F;&#x2F;设置一个合适的长度，以存储每一行输出</p>
<p>​    while (fgets(tmp, sizeof(tmp), pp) !&#x3D; NULL) {</p>
<p>​        if (tmp[strlen(tmp) - 1] &#x3D;&#x3D; ‘\n’) {</p>
<p>​            tmp[strlen(tmp) - 1] &#x3D; ‘\0’; &#x2F;&#x2F;去除换行符</p>
<p>​        }</p>
<p>​        resvec.push_back(tmp);</p>
<p>​    }</p>
<p>​    pclose(pp); &#x2F;&#x2F;关闭管道</p>
<p>​    return resvec.size();</p>
<p>}</p>
<h1 id="第-7-章-new"><a href="#第-7-章-new" class="headerlink" title="第 7 章 new"></a>第 7 章 new</h1><h2 id="7-1-gcc选项-g与-rdynamic的异同"><a href="#7-1-gcc选项-g与-rdynamic的异同" class="headerlink" title="7.1 gcc选项-g与-rdynamic的异同"></a>7.1 gcc选项-g与-rdynamic的异同</h2><p>gcc 的 -g ，应该没有人不知道它是一个调试选项，因此在一般需要进行程序调试的场景下，我们都会加上该选项，并且根据调试工具的不同，还能直接选择更有针对性的说明，比如 -ggdb 。-g是一个编译选项，即在源代码编译的过程中起作用，让gcc把更多调试信息（也就包括符号信息）收集起来并将存放到最终的可执行文件内。 </p>
<p>相比-g选项， -rdynamic 却是一个 连接选项 ，它将指示连接器把所有符号（而不仅仅只是程序已使用到的外部符号）都添加到动态符号表（即.dynsym表）里，以便那些通过 dlopen() 或 backtrace() （这一系列函数使用.dynsym表内符号）这样的函数使用。</p>
<p>看示例：</p>
<p>[root@www c]<strong># cat t.c</strong></p>
<p><strong>#include &lt;stdio.h&gt;</strong></p>
<p><strong>void</strong> bar() {}</p>
<p><strong>void</strong> baz() {}</p>
<p><strong>void</strong> foo() {}</p>
<p><strong>int</strong> main() { foo(); printf(“test”); <strong>return</strong> 0; }</p>
<p>对于上面的示例代码，普通和加-g编译：</p>
<p>[root@www c]<em># uname -a</em></p>
<p>Linux <a target="_blank" rel="noopener" href="http://www.t1.com/">www.t1.com</a> 2.6.38.8 <em>#2 SMP Wed Nov 2 07:52:53 CST 2011 x86_64 x86_64 x86_64 GNU&#x2F;Linux</em></p>
<p>[root@www c]<em># gcc -O0 -o t t.c</em></p>
<p>[root@www c]<em># gcc -O0 -g -o t.g t.c</em></p>
<p>[root@www c]<em># readelf -a t &gt; t.elf</em></p>
<p>[root@www c]<em># readelf -a t.g &gt; t.g.elf</em></p>
<p>[root@www c]<em># ls -lh *.elf t t.g</em></p>
<p>-rwxr-xr-x. 1 root root 6.6K Jul 24 06:50 t</p>
<p>-rw-r–r–. 1 root root  15K Jul 24 06:51 t.elf</p>
<p>-rwxr-xr-x. 1 root root 7.9K Jul 24 06:50 t.g</p>
<p>-rw-r–r–. 1 root root  16K Jul 24 06:51 t.g.elf</p>
<p>加-g编译后，因为包含了debug信息，因此生成的可执行文件偏大（程序本身非常小，所以增加的调试信息不多）。<br>看-g编译的符号表： </p>
<p>[root@www c]<em># readelf -s t</em></p>
<p>Symbol table ‘.dynsym’ contains 4 entries:</p>
<p>   Num:    Value          Size Type    Bind   Vis      Ndx Name</p>
<p>​     0: 0000000000000000     0 NOTYPE  LOCAL  <strong>DEFAULT</strong>  UND</p>
<p>​     1: 0000000000000000     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>  UND <a href="mailto:&#112;&#114;&#105;&#x6e;&#116;&#x66;&#64;&#x47;&#76;&#73;&#66;&#67;&#x5f;&#50;&#x2e;&#50;&#x2e;&#x35;">&#112;&#114;&#105;&#x6e;&#116;&#x66;&#64;&#x47;&#76;&#73;&#66;&#67;&#x5f;&#50;&#x2e;&#50;&#x2e;&#x35;</a> (2)</p>
<p>​     2: 0000000000000000     0 NOTYPE  WEAK   <strong>DEFAULT</strong>  UND <strong>gmon_start</strong></p>
<p>​     3: 0000000000000000     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>  UND <a href="mailto:&#95;&#x5f;&#108;&#105;&#x62;&#x63;&#x5f;&#x73;&#116;&#97;&#x72;&#116;&#x5f;&#109;&#97;&#105;&#110;&#x40;&#71;&#76;&#73;&#x42;&#x43;&#95;&#50;&#46;&#x32;&#46;&#53;">&#95;&#x5f;&#108;&#105;&#x62;&#x63;&#x5f;&#x73;&#116;&#97;&#x72;&#116;&#x5f;&#109;&#97;&#105;&#110;&#x40;&#71;&#76;&#73;&#x42;&#x43;&#95;&#50;&#46;&#x32;&#46;&#53;</a> (2)</p>
<p>Symbol table ‘.symtab’ contains 67 entries:</p>
<p>   Num:    Value          Size Type    Bind   Vis      Ndx Name</p>
<p>…</p>
<p>​    48: 00000000004003e0     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 _start</p>
<p>​    49: 00000000004004c4     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 bar</p>
<p>…</p>
<p>​    53: 0000000000000000     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>  UND putchar@@GLIBC_2.2.5</p>
<p>​    54: 0000000000000000     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>  UND _<em>libc_start_main@@GLIBC</em></p>
<p>​    55: 00000000004005e8     4 OBJECT  <strong>GLOBAL</strong> <strong>DEFAULT</strong>   15 _IO_stdin_used</p>
<p>​    56: 00000000004004d0     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 foo</p>
<p>…</p>
<p>​    64: 00000000004004d6    31 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 main</p>
<p>​    65: 0000000000400390     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   11 _init</p>
<p>​    66: 00000000004004ca     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 baz</p>
<p>注意.dynsym表，只有该程序用到的几个外部动态符号存在。<br>加-rdynamic选项编译，readelf查看： </p>
<p>[root@www c]<em># gcc -O0 -rdynamic -o t.rd t.c</em></p>
<p>[root@www c]*# readelf -s t.rd *</p>
<p>Symbol table ‘.dynsym’ contains 20 entries:</p>
<p>   Num:    Value          Size Type    Bind   Vis      Ndx Name</p>
<p>​     0: 0000000000000000     0 NOTYPE  LOCAL  <strong>DEFAULT</strong>  UND</p>
<p>​     1: 0000000000000000     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>  UND <a href="mailto:&#112;&#114;&#x69;&#110;&#x74;&#102;&#64;&#x47;&#x4c;&#x49;&#66;&#x43;&#95;&#x32;&#46;&#x32;&#x2e;&#53;">&#112;&#114;&#x69;&#110;&#x74;&#102;&#64;&#x47;&#x4c;&#x49;&#66;&#x43;&#95;&#x32;&#46;&#x32;&#x2e;&#53;</a> (2)</p>
<p>​     2: 0000000000000000     0 NOTYPE  WEAK   <strong>DEFAULT</strong>  UND <strong>gmon_start</strong></p>
<p>​     3: 0000000000000000     0 NOTYPE  WEAK   <strong>DEFAULT</strong>  UND _Jv_RegisterClasses</p>
<p>​     4: 0000000000000000     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>  UND <a href="mailto:&#x5f;&#95;&#108;&#x69;&#98;&#99;&#x5f;&#115;&#116;&#x61;&#x72;&#x74;&#95;&#x6d;&#97;&#x69;&#x6e;&#x40;&#x47;&#x4c;&#73;&#66;&#67;&#x5f;&#50;&#46;&#50;&#x2e;&#x35;">&#x5f;&#95;&#108;&#x69;&#98;&#99;&#x5f;&#115;&#116;&#x61;&#x72;&#x74;&#95;&#x6d;&#97;&#x69;&#x6e;&#x40;&#x47;&#x4c;&#73;&#66;&#67;&#x5f;&#50;&#46;&#50;&#x2e;&#x35;</a> (2)</p>
<p>​     5: 0000000000400724     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 bar</p>
<p>​     6: 0000000000400730     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 foo</p>
<p>​     7: 0000000000600b68     0 NOTYPE  <strong>GLOBAL</strong> <strong>DEFAULT</strong>   24 __data_start</p>
<p>​     8: 0000000000600b80     0 NOTYPE  <strong>GLOBAL</strong> <strong>DEFAULT</strong>  ABS _end</p>
<p>​     9: 0000000000600b6c     0 NOTYPE  <strong>GLOBAL</strong> <strong>DEFAULT</strong>  ABS _edata</p>
<p>​    10: 0000000000600b68     0 NOTYPE  WEAK   <strong>DEFAULT</strong>   24 data_start</p>
<p>​    11: 0000000000400640     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 _start</p>
<p>​    12: 0000000000400848     4 OBJECT  <strong>GLOBAL</strong> <strong>DEFAULT</strong>   15 _IO_stdin_used</p>
<p>​    13: 0000000000400770   137 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 __libc_csu_init</p>
<p>​    14: 0000000000600b6c     0 NOTYPE  <strong>GLOBAL</strong> <strong>DEFAULT</strong>  ABS __bss_start</p>
<p>​    15: 0000000000400736    39 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 main</p>
<p>​    16: 00000000004005f0     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   11 _init</p>
<p>​    17: 0000000000400760     2 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 __libc_csu_fini</p>
<p>​    18: 0000000000400838     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   14 _fini</p>
<p>​    19: 000000000040072a     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 baz</p>
<p>Symbol table ‘.symtab’ contains 67 entries:</p>
<p>   Num:    Value          Size Type    Bind   Vis      Ndx Name</p>
<p>…</p>
<p>​    50: 0000000000400640     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 _start</p>
<p>​    51: 0000000000400724     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 bar</p>
<p>…</p>
<p>​    55: 0000000000000000     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>  UND putchar@@GLIBC_2.2.5</p>
<p>​    56: 0000000000000000     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>  UND _<em>libc_start_main@@GLIBC</em></p>
<p>​    57: 0000000000400848     4 OBJECT  <strong>GLOBAL</strong> <strong>DEFAULT</strong>   15 _IO_stdin_used</p>
<p>​    58: 0000000000400730     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 foo</p>
<p>…</p>
<p>​    64: 0000000000400736    31 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 main</p>
<p>​    65: 00000000004005f0     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   11 _init</p>
<p>​    66: 000000000040072a     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 baz</p>
<p>[root@www c]<em>#</em></p>
<p>可以看到添加-rdynamic选项后，.dynsym表就包含了所有的符号，不仅是已使用到的外部动态符号，还包括本程序内定义的符号，比如bar、foo、baz等。<br>.dynsym表里的数据并不能被strip掉： </p>
<p>[root@www c]<em># strip t.rd</em></p>
<p>[root@www c]<em># readelf -s t.rd</em></p>
<p>Symbol table ‘.dynsym’ contains 20 entries:</p>
<p>   Num:    Value          Size Type    Bind   Vis      Ndx Name</p>
<p>​     0: 0000000000000000     0 NOTYPE  LOCAL  <strong>DEFAULT</strong>  UND</p>
<p>​     1: 0000000000000000     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>  UND <a href="mailto:&#112;&#114;&#105;&#110;&#116;&#x66;&#x40;&#71;&#x4c;&#x49;&#x42;&#67;&#95;&#50;&#46;&#x32;&#46;&#53;">&#112;&#114;&#105;&#110;&#116;&#x66;&#x40;&#71;&#x4c;&#x49;&#x42;&#67;&#95;&#50;&#46;&#x32;&#46;&#53;</a> (2)</p>
<p>​     2: 0000000000000000     0 NOTYPE  WEAK   <strong>DEFAULT</strong>  UND <strong>gmon_start</strong></p>
<p>​     3: 0000000000000000     0 NOTYPE  WEAK   <strong>DEFAULT</strong>  UND _Jv_RegisterClasses</p>
<p>​     4: 0000000000000000     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>  UND <a href="mailto:&#x5f;&#95;&#x6c;&#105;&#x62;&#x63;&#x5f;&#x73;&#116;&#97;&#114;&#116;&#95;&#x6d;&#x61;&#x69;&#110;&#64;&#x47;&#76;&#73;&#x42;&#67;&#95;&#50;&#x2e;&#50;&#x2e;&#53;">&#x5f;&#95;&#x6c;&#105;&#x62;&#x63;&#x5f;&#x73;&#116;&#97;&#114;&#116;&#95;&#x6d;&#x61;&#x69;&#110;&#64;&#x47;&#76;&#73;&#x42;&#67;&#95;&#50;&#x2e;&#50;&#x2e;&#53;</a> (2)</p>
<p>​     5: 0000000000400724     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 bar</p>
<p>​     6: 0000000000400730     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 foo</p>
<p>​     7: 0000000000600b68     0 NOTYPE  <strong>GLOBAL</strong> <strong>DEFAULT</strong>   24 __data_start</p>
<p>​     8: 0000000000600b80     0 NOTYPE  <strong>GLOBAL</strong> <strong>DEFAULT</strong>  ABS _end</p>
<p>​     9: 0000000000600b6c     0 NOTYPE  <strong>GLOBAL</strong> <strong>DEFAULT</strong>  ABS _edata</p>
<p>​    10: 0000000000600b68     0 NOTYPE  WEAK   <strong>DEFAULT</strong>   24 data_start</p>
<p>​    11: 0000000000400640     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 _start</p>
<p>​    12: 0000000000400848     4 OBJECT  <strong>GLOBAL</strong> <strong>DEFAULT</strong>   15 _IO_stdin_used</p>
<p>​    13: 0000000000400770   137 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 __libc_csu_init</p>
<p>​    14: 0000000000600b6c     0 NOTYPE  <strong>GLOBAL</strong> <strong>DEFAULT</strong>  ABS __bss_start</p>
<p>​    15: 0000000000400736    39 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 main</p>
<p>​    16: 00000000004005f0     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   11 _init</p>
<p>​    17: 0000000000400760     2 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 __libc_csu_fini</p>
<p>​    18: 0000000000400838     0 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   14 _fini</p>
<p>​    19: 000000000040072a     6 FUNC    <strong>GLOBAL</strong> <strong>DEFAULT</strong>   13 baz</p>
<p>简单总结一下-g选项与-rdynamic选项的差别：<br>1，-g选项新添加的是调试信息（一系列.debug_xxx段），被相关调试工具，比如gdb使用，可以被strip掉。 </p>
<p>2，-rdynamic选项新添加的是动态连接符号信息，用于动态连接功能，比如dlopen()系列函数、backtrace()系列函数使用，不能被strip掉，即强制strip将导致程序无法执行：</p>
<p>[root@www c]<em># .&#x2F;t.rd</em></p>
<p>test[root@www c]<em># strip -R .dynsym t.rd</em></p>
<p>[root@www c]<em># .&#x2F;t.rd</em></p>
<p>.&#x2F;t.rd: relocation error: .&#x2F;t.rd: symbol , version GLIBC_2.2.5 <strong>not</strong> <strong>defined</strong> <strong>in</strong> file libc.so.6 with link time reference</p>
<p>[root@www c]<em>#</em></p>
<p>3，.symtab表在程序加载时会被加载器 <a target="_blank" rel="noopener" href="https://blogs.oracle.com/ali/entry/inside_elf_symbol_tables">丢弃</a> ，gdb等调试工具由于可以直接访问到磁盘上的二进制程序文件： </p>
<p>[root@www c]<em># gdb t.g -q</em></p>
<p>Reading symbols from &#x2F;home&#x2F;work&#x2F;dladdr&#x2F;c&#x2F;t.g…<strong>done</strong>.</p>
<p>(gdb)</p>
<p>因此可以使用所有的调试信息，这包括.symtab表；而backtrace()系列函数作为程序执行的逻辑功能，无法去读取磁盘上的二进制程序文件，因此只能使用.dynsym表。<br>其它几个工具可以动态指定查看，比如nm、objdump： </p>
<p>[root@www c]<em># nm t.rd</em></p>
<p>nm: t.rd: <strong>no</strong> symbols</p>
<p>[root@www c]<em># nm -D t.rd</em></p>
<p>0000000000400848 R _IO_stdin_used</p>
<p>​                 w _Jv_RegisterClasses</p>
<p>0000000000600b6c A __bss_start</p>
<p>0000000000600b68 D __data_start</p>
<p>​                 w <strong>gmon_start</strong></p>
<p>0000000000400760 T __libc_csu_fini</p>
<p>0000000000400770 T __libc_csu_init</p>
<p>​                 U __libc_start_main</p>
<p>0000000000600b6c A _edata</p>
<p>0000000000600b80 A _end</p>
<p>0000000000400838 T _fini</p>
<p>00000000004005f0 T _init</p>
<p>0000000000400640 T _start</p>
<p>0000000000400724 T bar</p>
<p>000000000040072a T baz</p>
<p>0000000000600b68 W data_start</p>
<p>0000000000400730 T foo</p>
<p>0000000000400736 T main</p>
<p>​                 U <strong>printf</strong></p>
<p>[root@www c]<em>#</em></p>
<p>[root@www c]<em># objdump -T t.rd</em></p>
<p>t.rd:     file <strong>format</strong> elf64-x86-64</p>
<p>DYNAMIC SYMBOL TABLE:</p>
<p>0000000000000000      DF <em>UND</em>	0000000000000000  GLIBC_2.2.5 <strong>printf</strong></p>
<p>0000000000000000  w   D  <em>UND</em>	0000000000000000              <strong>gmon_start</strong></p>
<p>0000000000000000  w   D  <em>UND</em>	0000000000000000              _Jv_RegisterClasses</p>
<p>0000000000000000      DF <em>UND</em>	0000000000000000  GLIBC_2.2.5 __libc_start_main</p>
<p>0000000000400724 g    DF .text	0000000000000006  Base        bar</p>
<p>0000000000400730 g    DF .text	0000000000000006  Base        foo</p>
<p>0000000000600b68 g    D  .data	0000000000000000  Base        __data_start</p>
<p>0000000000600b80 g    D  <em>ABS</em>	0000000000000000  Base        _end</p>
<p>0000000000600b6c g    D  <em>ABS</em>	0000000000000000  Base        _edata</p>
<p>0000000000600b68  w   D  .data	0000000000000000  Base        data_start</p>
<p>0000000000400640 g    DF .text	0000000000000000  Base        _start</p>
<p>0000000000400848 g    DO .rodata	0000000000000004  Base        _IO_stdin_used</p>
<p>0000000000400770 g    DF .text	0000000000000089  Base        __libc_csu_init</p>
<p>0000000000600b6c g    D  <em>ABS</em>	0000000000000000  Base        __bss_start</p>
<p>0000000000400736 g    DF .text	0000000000000027  Base        main</p>
<p>00000000004005f0 g    DF .init	0000000000000000  Base        _init</p>
<p>0000000000400760 g    DF .text	0000000000000002  Base        __libc_csu_fini</p>
<p>0000000000400838 g    DF .fini	0000000000000000  Base        _fini</p>
<p>000000000040072a g    DF .text	0000000000000006  Base        baz</p>
<p>4，-rdynamic选项不产生任何调试信息，因此在一般情况下，新增的附加信息比-g选项要少得多。除非是完全的静态连接，否则即便是没有加-rdynamic选项，程序使用到的外部动态符号，比如前面示例里的printf，也会被自动加入到.dynsym表。</p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-Linux%E7%AE%A1%E7%90%86"><span class="toc-text">第 1 章 Linux管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4"><span class="toc-text">1.1 Linux基本指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-addr2line"><span class="toc-text">1.1.1 addr2line</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-alias"><span class="toc-text">1.1.2 alias</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-ar"><span class="toc-text">1.1.3 ar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-Arp"><span class="toc-text">1.1.4 Arp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-5-arping"><span class="toc-text">1.1.5 arping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-6-awk"><span class="toc-text">1.1.6 awk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-7-basename"><span class="toc-text">1.1.7 basename</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-8-cat"><span class="toc-text">1.1.8 cat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-9-cd"><span class="toc-text">1.1.9 cd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-10-chown-x2F-chgrp-x2F-chmod"><span class="toc-text">1.1.10 chown&#x2F;chgrp&#x2F;chmod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-11-chroot"><span class="toc-text">1.1.11 chroot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-12-cp"><span class="toc-text">1.1.12 cp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-13-cut"><span class="toc-text">1.1.13 cut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-14-df%E5%92%8Cdu"><span class="toc-text">1.1.14 df和du</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-15-dos2unix"><span class="toc-text">1.1.15 dos2unix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-16-echo"><span class="toc-text">1.1.16 echo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-17-env"><span class="toc-text">1.1.17 env</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-17-1-%E5%90%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%84%8F%E4%B9%89"><span class="toc-text">1.1.17.1 各环境变量意义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-18-ethtool"><span class="toc-text">1.1.18 ethtool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-19-file"><span class="toc-text">1.1.19 file</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-20-fdisk-l"><span class="toc-text">1.1.20 fdisk -l</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-21-find"><span class="toc-text">1.1.21 find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-22-free"><span class="toc-text">1.1.22 free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-23-fuser"><span class="toc-text">1.1.23 fuser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-24-getconf"><span class="toc-text">1.1.24 getconf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-25-gzip"><span class="toc-text">1.1.25 gzip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-26-grep"><span class="toc-text">1.1.26 grep</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-26-1-%E9%80%89%E9%A1%B9"><span class="toc-text">1.1.26.1 选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-26-2-grep%E5%91%BD%E4%BB%A4%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="toc-text">1.1.26.2 grep命令常见用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-27-head"><span class="toc-text">1.1.27 head</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-28-help"><span class="toc-text">1.1.28 help</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-29-id"><span class="toc-text">1.1.29 id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-30-ifconfig"><span class="toc-text">1.1.30 ifconfig</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-31-ifstat"><span class="toc-text">1.1.31 ifstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-32-iostat"><span class="toc-text">1.1.32 iostat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-33-iotop"><span class="toc-text">1.1.33 iotop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-34-ip"><span class="toc-text">1.1.34 ip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-35-iptraf"><span class="toc-text">1.1.35 iptraf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-36-ipcs"><span class="toc-text">1.1.36 ipcs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-37-iptables"><span class="toc-text">1.1.37 iptables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-38-init"><span class="toc-text">1.1.38 init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-39-kill"><span class="toc-text">1.1.39 kill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-40-ldd"><span class="toc-text">1.1.40 ldd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-41-ln"><span class="toc-text">1.1.41 ln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-42-locate"><span class="toc-text">1.1.42 locate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-43-logger"><span class="toc-text">1.1.43 logger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-43-1-options-%E9%80%89%E9%A1%B9"><span class="toc-text">1.1.43.1 options (选项)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-43-2-messages"><span class="toc-text">1.1.43.2 messages</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-43-3-%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-text">1.1.43.3 日志级别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-44-logsave"><span class="toc-text">1.1.44 logsave</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-45-ls"><span class="toc-text">1.1.45 ls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-46-lsof-grep-deleted"><span class="toc-text">1.1.46 lsof|grep deleted</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-47-ltrace"><span class="toc-text">1.1.47 ltrace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-48-make"><span class="toc-text">1.1.48 make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-49-man"><span class="toc-text">1.1.49 man</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-50-mkdir"><span class="toc-text">1.1.50 mkdir</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-51-mount-x2F-umount"><span class="toc-text">1.1.51 mount&#x2F;umount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-52-mpstat"><span class="toc-text">1.1.52 mpstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-53-mv"><span class="toc-text">1.1.53 mv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-54-nautilus"><span class="toc-text">1.1.54 nautilus</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-55-netstat"><span class="toc-text">1.1.55 netstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-56-nm"><span class="toc-text">1.1.56 nm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-57-nohup"><span class="toc-text">1.1.57 nohup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-58-nslookup"><span class="toc-text">1.1.58 nslookup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-59-passwd"><span class="toc-text">1.1.59 passwd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-60-ping"><span class="toc-text">1.1.60 ping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-61-pmap"><span class="toc-text">1.1.61 pmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-62-prstat"><span class="toc-text">1.1.62 prstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-63-ps"><span class="toc-text">1.1.63 ps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-64-pstree"><span class="toc-text">1.1.64 pstree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-65-pstack"><span class="toc-text">1.1.65 pstack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-66-pwd"><span class="toc-text">1.1.66 pwd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-67-ranlib"><span class="toc-text">1.1.67 ranlib</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-68-read"><span class="toc-text">1.1.68 read</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-68-1-%E5%9F%BA%E6%9C%AC%E8%AF%BB%E5%8F%96"><span class="toc-text">1.1.68.1 基本读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-68-2-%E8%AE%A1%E6%97%B6%E8%BE%93%E5%85%A5"><span class="toc-text">1.1.68.2 计时输入.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-68-3-%E9%BB%98%E8%AF%BB%EF%BC%88%E8%BE%93%E5%85%A5%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8%E4%B8%8A%EF%BC%89"><span class="toc-text">1.1.68.3 默读（输入不显示在监视器上）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-68-4-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-text">1.1.68.4 读文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-69-readelf"><span class="toc-text">1.1.69 readelf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-70-rm"><span class="toc-text">1.1.70 rm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-71-rmdir"><span class="toc-text">1.1.71 rmdir</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-72-route"><span class="toc-text">1.1.72 route</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-72-1-%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1"><span class="toc-text">1.1.72.1 添加路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-72-2-%E5%88%A0%E9%99%A4%E8%B7%AF%E7%94%B1"><span class="toc-text">1.1.72.2 删除路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-72-3-%E5%A2%9E%E5%8A%A0%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1"><span class="toc-text">1.1.72.3 增加默认路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-72-4-%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B12"><span class="toc-text">1.1.72.4 添加路由2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-72-5-%E5%A2%9E%E5%8A%A0%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B12"><span class="toc-text">1.1.72.5 增加默认路由2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-72-6-%E6%9F%A5%E7%9C%8B%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF"><span class="toc-text">1.1.72.6 查看路由信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-72-7-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD-%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1"><span class="toc-text">1.1.72.7 高级功能-策略路由</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-73-rpm"><span class="toc-text">1.1.73 rpm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-73-1-%E5%BC%BA%E5%88%B6%E5%8D%B8%E8%BD%BD"><span class="toc-text">1.1.73.1 强制卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-73-2-%E8%AF%A6%E8%A7%A3"><span class="toc-text">1.1.73.2 详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-73-3-RPM%E5%AE%89%E8%A3%85"><span class="toc-text">1.1.73.3 RPM安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-74-rpmbuild"><span class="toc-text">1.1.74 rpmbuild</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-75-rpmdev-tools"><span class="toc-text">1.1.75 rpmdev-tools</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-75-1-rpmdev-newspec"><span class="toc-text">1.1.75.1 rpmdev-newspec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-75-2-rpmdev-newinit"><span class="toc-text">1.1.75.2 rpmdev-newinit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-76-sar"><span class="toc-text">1.1.76 sar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-77-scp"><span class="toc-text">1.1.77 scp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-78-sed"><span class="toc-text">1.1.78 sed</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-78-1-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-text">1.1.78.1 命令详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-78-2-%E4%B8%BE%E4%BE%8B%EF%BC%9A%EF%BC%88%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E6%9C%89%E4%B8%80%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BAab%EF%BC%89"><span class="toc-text">1.1.78.2 举例：（假设我们有一文件名为ab）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-78-2-1-%E5%88%A0%E9%99%A4%E6%9F%90%E8%A1%8C"><span class="toc-text">1.1.78.2.1 删除某行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-78-2-2-%E6%98%BE%E7%A4%BA%E6%9F%90%E8%A1%8C"><span class="toc-text">1.1.78.2.2 显示某行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-78-2-3-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.1.78.2.3 使用模式进行查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-78-2-4-%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C%E6%88%96%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">1.1.78.2.4 增加一行或多行字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-78-2-5-%E4%BB%A3%E6%9B%BF%E4%B8%80%E8%A1%8C%E6%88%96%E5%A4%9A%E8%A1%8C"><span class="toc-text">1.1.78.2.5 代替一行或多行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-78-2-6-%E6%9B%BF%E6%8D%A2%E4%B8%80%E8%A1%8C%E4%B8%AD%E7%9A%84%E6%9F%90%E9%83%A8%E5%88%86"><span class="toc-text">1.1.78.2.6 替换一行中的某部分</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-78-3-%E6%9B%BF%E6%8D%A2"><span class="toc-text">1.1.78.3  替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-78-4-sed%E5%91%BD%E4%BB%A4%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-text">1.1.78.4 sed命令的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-78-5-%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.1.78.5 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-78-6-%E6%9B%BF%E6%8D%A2%E8%B7%AF%E5%BE%84"><span class="toc-text">1.1.78.6 替换路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-78-7-%E5%BA%94%E7%94%A8"><span class="toc-text">1.1.78.7 应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-79-setup"><span class="toc-text">1.1.79 setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-80-slabtop"><span class="toc-text">1.1.80 slabtop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-81-ss"><span class="toc-text">1.1.81 ss</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-82-strace"><span class="toc-text">1.1.82 strace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-83-strings"><span class="toc-text">1.1.83 strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-84-sync"><span class="toc-text">1.1.84 sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-85-su-x2F-sudo"><span class="toc-text">1.1.85 su&#x2F;sudo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-86-tar"><span class="toc-text">1.1.86 tar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-87-time"><span class="toc-text">1.1.87 time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-88-top"><span class="toc-text">1.1.88 top</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-89-touch"><span class="toc-text">1.1.89 touch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-90-tr"><span class="toc-text">1.1.90 tr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-91-tree"><span class="toc-text">1.1.91 tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-92-wall"><span class="toc-text">1.1.92 wall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-93-write"><span class="toc-text">1.1.93 write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-94-whatis"><span class="toc-text">1.1.94 whatis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-95-which"><span class="toc-text">1.1.95 which</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-96-wc"><span class="toc-text">1.1.96 wc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-97-xxd"><span class="toc-text">1.1.97 xxd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-98-yum"><span class="toc-text">1.1.98 yum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-99-zip-x2F-uzip"><span class="toc-text">1.1.99 zip&#x2F;uzip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-100-uname"><span class="toc-text">1.1.100 uname</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-101-uptime"><span class="toc-text">1.1.101 uptime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-102-useradd"><span class="toc-text">1.1.102 useradd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-103-vmstat%E5%91%BD%E4%BB%A4"><span class="toc-text">1.1.103 vmstat命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-103-1-%E8%AF%AD%E6%B3%95"><span class="toc-text">1.1.103.1 语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-103-2-%E9%80%89%E9%A1%B9"><span class="toc-text">1.1.103.2 选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-103-3-%E5%8F%82%E6%95%B0"><span class="toc-text">1.1.103.3 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-103-4-%E5%AE%9E%E4%BE%8B"><span class="toc-text">1.1.103.4 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-103-5-%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">1.1.103.5 字段说明：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-104-%E6%8E%92%E9%99%A4%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6"><span class="toc-text">1.1.104 排除某个目录或文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-105-%E5%88%A0%E9%99%A4%E9%99%A4%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%96%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-text">1.1.105 删除除某个文件外的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-106-Linux%E5%8F%8D%E9%80%89%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%B1%87%E6%80%BB"><span class="toc-text">1.1.106 Linux反选删除文件汇总</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">1.2 Linux常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="toc-text">1.2.1 系统信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-text">1.2.2 文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2"><span class="toc-text">1.2.3 文件搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E6%8C%82%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.2.4 挂载一个文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-text">1.2.5 打包和压缩文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-6-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AELinux%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.2.6 如何设置Linux启动模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-7-linux%E4%B8%8B%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.7 linux下解决端口被占用问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-8-%E4%BF%AE%E6%94%B9core%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-text">1.2.8 修改core文件格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-9-%E9%87%8A%E6%94%BEcache%E7%BC%93%E5%AD%98"><span class="toc-text">1.2.9 释放cache缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%BE%97%E5%88%B0%E7%B3%BB%E7%BB%9Fbit%E4%BD%8D"><span class="toc-text">1.3 得到系统bit位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE"><span class="toc-text">1.4 系统设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-Linux%E9%98%B2%E7%81%AB%E5%A2%99-iptables-%E7%9A%84%E5%BC%80%E5%90%AF%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-text">1.4.1 Linux防火墙(iptables)的开启与关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-text">1.5 系统服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-rsyslog"><span class="toc-text">1.5.1 rsyslog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-crond"><span class="toc-text">1.5.2 crond</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-text">1.5.3 开机自动执行脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-4-%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4"><span class="toc-text">1.5.4 设置时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-text">1.6 系统操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">1.7 重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E5%85%B3%E4%BA%8E%E6%96%87%E6%9C%AC%E5%AF%BC%E5%87%BA"><span class="toc-text">1.8 关于文本导出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-0-1-%E5%A6%82%E4%BD%95%E6%8A%8A%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6%E5%BD%93%E4%B8%AD"><span class="toc-text">1.8.0.1 如何把命令运行的结果保存到文件当中?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-0-2-%E5%A6%82%E4%BD%95%E8%83%BD%E5%9C%A8%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF%E7%9A%84%E5%90%8C%E6%97%B6%E6%8A%8A%E4%BF%A1%E6%81%AF%E8%AE%B0%E5%BD%95%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-text">1.8.0.2 如何能在输出信息的同时把信息记录到文件中?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-0-3-%E5%90%8C%E6%97%B6%E5%9C%A8%E5%B1%8F%E5%B9%95%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E8%BE%93%E5%87%BA"><span class="toc-text">1.8.0.3 同时在屏幕和文件中输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-0-4-%E5%A4%9A%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E8%BE%93%E5%87%BA%E9%83%BD%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8script"><span class="toc-text">1.8.0.4 多个命令的输出都需要记录，可以用script</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-Linux%E6%89%93%E5%BC%80%E5%8D%95%E5%B1%82%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-text">1.9 Linux打开单层文件夹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-Linux%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8E%E9%BB%98%E8%AE%A4%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="toc-text">1.10 Linux打开文件夹后默认最大化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-Linux%E4%B8%8B%E9%87%87%E7%94%A8Cloc%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0"><span class="toc-text">1.11 Linux下采用Cloc统计代码行数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">1.11.1 使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-11-1-1-%E6%98%BE%E7%A4%BA%E5%90%84%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%9F%E8%AE%A1%E7%BB%93%E6%9E%9C"><span class="toc-text">1.11.1.1 显示各类文件统计结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-11-1-2-%E8%AF%A6%E7%BB%86%E7%BB%9F%E8%AE%A1%E5%90%84%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8F"><span class="toc-text">1.11.1.2 详细统计各个文件下的代码量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-%E6%B0%B8%E4%B9%85%E6%80%A7%E4%BF%AE%E6%94%B9hostname"><span class="toc-text">1.12 永久性修改hostname</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-%E6%9F%A5%E7%9C%8Blinux%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC"><span class="toc-text">1.13 查看linux发布版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-%E4%BF%AE%E6%94%B9ip%E5%9C%B0%E5%9D%80"><span class="toc-text">1.14 修改ip地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-%E5%8E%BB%E9%99%A4DHCP"><span class="toc-text">1.15 去除DHCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-16-telnet"><span class="toc-text">1.16 telnet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-17-%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D"><span class="toc-text">1.17 修改主机名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-1-%E6%96%B9%E6%B3%951"><span class="toc-text">1.17.1 方法1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-2-%E6%96%B9%E6%B3%952"><span class="toc-text">1.17.2 方法2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-18-linux%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-text">1.18 linux配置虚拟IP地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-19-Linux%E8%AE%BE%E5%A4%87"><span class="toc-text">1.19 Linux设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-20-Samba%E6%90%AD%E5%BB%BA"><span class="toc-text">1.20 Samba搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-21-Linux%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85"><span class="toc-text">1.21 Linux软件打包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-21-1-Linux%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6"><span class="toc-text">1.21.1 Linux打包软件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-1-1-rpmdevtools"><span class="toc-text">1.21.1.1 rpmdevtools</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-1-2-rpmbuild"><span class="toc-text">1.21.1.2 rpmbuild</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-1-3-rpmdev-newspec"><span class="toc-text">1.21.1.3 rpmdev-newspec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-1-4-rpmdev-newinit"><span class="toc-text">1.21.1.4 rpmdev-newinit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-21-2-%E6%89%93%E5%8C%85%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.21.2 打包步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-2-1-prep%E9%98%B6%E6%AE%B5"><span class="toc-text">1.21.2.1 %prep阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-2-2-build%E9%98%B6%E6%AE%B5"><span class="toc-text">1.21.2.2 %build阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-2-3-%E6%96%87%E6%A1%A3%E5%8F%8A%E6%89%8B%E5%86%8C-x2F-usr-x2F-share-x2F-man"><span class="toc-text">1.21.2.3 文档及手册&#x2F;usr&#x2F;share&#x2F;man</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-2-4-install%E9%98%B6%E6%AE%B5"><span class="toc-text">1.21.2.4 %install阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-2-5-clean%E9%98%B6%E6%AE%B5"><span class="toc-text">1.21.2.5 %clean阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-2-6-%E5%88%B6%E4%BD%9Crpm%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-text">1.21.2.6 制作rpm软件包的阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-2-7-changelog%E9%98%B6%E6%AE%B5"><span class="toc-text">1.21.2.7 %changelog阶段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-22-ping%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1.22 ping包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-23-linux-M%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-text">1.23 linux ^M格式问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-24-linux%E4%B8%8B%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">1.24 linux下解决端口被占用问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-25-%E5%88%87%E6%8D%A2%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%8B%B1%E6%96%87"><span class="toc-text">1.25 切换系统中英文</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-Linux%E8%BD%AF%E4%BB%B6"><span class="toc-text">第 2 章 Linux软件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-boa%E9%85%8D%E7%BD%AE"><span class="toc-text">2.1 boa配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-boa-conf"><span class="toc-text">2.1.1 boa.conf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Vi%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-text">2.2 Vi编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%BF%9B%E5%85%A5VI"><span class="toc-text">2.2.1 进入VI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E9%80%80%E5%87%BAVi"><span class="toc-text">2.2.2 退出Vi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E8%B0%83%E7%94%A8shell%E5%91%BD%E4%BB%A4"><span class="toc-text">2.2.3 调用shell命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text">2.2.4 编译过程四个阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-gcc%E5%B8%B8%E7%94%A8%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-text">2.2.5 gcc常用编译选项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-Linux%E5%9F%BA%E7%A1%80"><span class="toc-text">第 3 章 Linux基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Linux%E6%A0%87%E5%87%86%E7%9B%AE%E5%BD%95"><span class="toc-text">3.1 Linux标准目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Linux%E5%90%8D%E8%AF%8D"><span class="toc-text">3.2 Linux名词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-NAT"><span class="toc-text">3.2.1 NAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%91%BD%E5%90%8D"><span class="toc-text">3.2.2 命名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">3.3 快捷键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%9C%A8%E7%BB%88%E7%AB%AF%E7%95%8C%E9%9D%A2%E4%B8%8B"><span class="toc-text">3.3.1 在终端界面下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E8%AE%BE%E7%BD%AE%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">3.3.2 设置快捷键</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6"><span class="toc-text">3.4 安装软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">3.5 文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-rwx-rwx-rwx-%E6%96%87%E4%BB%B6%E6%8B%A5%E6%9C%89%E8%80%85-%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E7%BB%84-%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7"><span class="toc-text">3.5.1 -rwx rwx rwx   文件拥有者  文件所有组  其他用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E8%A1%A8%E7%A4%BA"><span class="toc-text">3.5.2 磁盘分区的文件名表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6"><span class="toc-text">3.5.3 隐藏文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-minicom"><span class="toc-text">3.6 minicom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%BC%80%E5%90%AFroot%E8%B4%A6%E6%88%B7%E6%96%B9%E6%B3%95"><span class="toc-text">3.7 开启root账户方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-fedora%E4%BB%A5root%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.8 fedora以root登录的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E9%87%8D%E5%91%BD%E5%90%8D%E9%80%BB%E8%BE%91%E5%8D%B7%E5%90%8D"><span class="toc-text">3.9 重命名逻辑卷名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-busybox"><span class="toc-text">3.10 busybox</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-linux%E7%A7%BB%E6%A4%8D"><span class="toc-text">3.11 linux移植</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-1-Linux%E5%86%85%E6%A0%B8"><span class="toc-text">3.11.1 Linux内核</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-1-arch%E7%9B%AE%E5%BD%95"><span class="toc-text">3.11.1.1 arch目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-2-block"><span class="toc-text">3.11.1.2 block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-3-drives"><span class="toc-text">3.11.1.3 drives</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-4-fs"><span class="toc-text">3.11.1.4 fs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-5-include"><span class="toc-text">3.11.1.5 include</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-6-lib"><span class="toc-text">3.11.1.6 lib</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-7-mm"><span class="toc-text">3.11.1.7 mm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-8-net"><span class="toc-text">3.11.1.8 net</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-9-usr"><span class="toc-text">3.11.1.9 usr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-2-%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%BC%96%E8%AF%91"><span class="toc-text">3.11.2 内核配置与编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-3-%E5%86%85%E6%A0%B8%E5%AE%89%E8%A3%85"><span class="toc-text">3.11.3 内核安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-4-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-text">3.11.4 内核模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-4-1-%E5%8A%A0%E8%BD%BD%E5%87%BD%E6%95%B0-module-init-hello-init"><span class="toc-text">3.11.4.1 加载函数  module_init(hello_init)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-4-2-%E5%8D%B8%E8%BD%BD%E5%87%BD%E6%95%B0-module-exit-hello-exit"><span class="toc-text">3.11.4.2 卸载函数  module_exit(hello_exit)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-4-3-%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91-makefile"><span class="toc-text">3.11.4.3 模块编译    makefile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-4-4-%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="toc-text">3.11.4.4 模块安装与卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-4-5-MODULE-LICENSE"><span class="toc-text">3.11.4.5 MODULE_LICENSE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-4-6-%E6%A8%A1%E5%9D%97%E5%8F%82%E6%95%B0"><span class="toc-text">3.11.4.6 模块参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-4-7-%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3.11.4.7 模块中的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-5-%E6%90%AD%E5%BB%BANFS%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">3.11.5 搭建NFS根文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-6-%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B"><span class="toc-text">3.11.6 基本脚本编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-7-printk"><span class="toc-text">3.11.7 printk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-12-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91"><span class="toc-text">3.12 应用程序的开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">3.12.1 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-1-1-API"><span class="toc-text">3.12.1.1 API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-2-helloworld"><span class="toc-text">3.12.2 helloworld</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-3-irqreturn-t"><span class="toc-text">3.12.3 irqreturn_t</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-4-system%E5%87%BD%E6%95%B0"><span class="toc-text">3.12.4 system函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-5-size-t-time-t"><span class="toc-text">3.12.5 size_t  time_t</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-13-Linux%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">3.13 Linux驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-1-%E7%BC%96%E5%86%99Linux%E9%A9%B1%E5%8A%A8"><span class="toc-text">3.13.1 编写Linux驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-2-%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E4%B8%AD%E5%B7%B2%E6%9C%89%E6%A8%A1%E5%9D%97"><span class="toc-text">3.13.2 加载内核中已有模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-3-%E5%87%BD%E6%95%B0"><span class="toc-text">3.13.3 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-3-1-copy-to-user"><span class="toc-text">3.13.3.1 copy_to_user</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-3-2-File-operations"><span class="toc-text">3.13.3.2 File_operations</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-14-Linux%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-text">3.14 Linux生成动态库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-1-%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-text">3.14.1 生成动态链接库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-2-linux-%E5%A2%9E%E5%8A%A0%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="toc-text">3.14.2 linux 增加动态库的搜索路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-15-%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-text">3.15 静态库的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-15-1-%E5%87%A0%E4%B8%AALinux%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">3.15.1 几个Linux文件的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-16-%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC"><span class="toc-text">3.16 启动脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-16-1-bash%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC"><span class="toc-text">3.16.1 bash启动脚本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-17-DHCP"><span class="toc-text">3.17 DHCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-18-Linux%E4%B8%8B%E6%B8%85%E7%90%86%E5%86%85%E5%AD%98%E5%92%8CCache%E6%96%B9%E6%B3%95"><span class="toc-text">3.18 Linux下清理内存和Cache方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-Shell"><span class="toc-text">第 4 章 Shell</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-shell%E8%AF%AD%E6%B3%95"><span class="toc-text">4.1 shell语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%8F%82%E6%95%B0"><span class="toc-text">4.1.1 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">4.1.2 内部命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-bash%E5%8A%9F%E8%83%BD"><span class="toc-text">4.1.3 bash功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4"><span class="toc-text">4.1.4 添加自定义命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-%E5%8F%8D%E5%BC%95%E5%8F%B7"><span class="toc-text">4.1.5 反引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.1.6 测试语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-7-if%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.1.7 if语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-8-%E6%AF%94%E8%BE%83"><span class="toc-text">4.1.8 比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#000011-1-%E5%88%A4%E6%96%AD"><span class="toc-text">000011.1 判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-9-case%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.1.9 case语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-10-until%E5%BE%AA%E7%8E%AF"><span class="toc-text">4.1.10 until循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-11-while%E5%BE%AA%E7%8E%AF"><span class="toc-text">4.1.11 while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-12-For%E5%BE%AA%E7%8E%AF"><span class="toc-text">4.1.12 For循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-13-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">4.1.13 标准输入输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Shell"><span class="toc-text">4.2 Shell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E4%BD%9C%E4%B8%BA%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-text">4.2.1 获取系统时间作为文件名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-text">4.2.2 判断某个目录是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%BB%B6%E6%97%B6"><span class="toc-text">4.2.3 延时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8Fid%E7%84%B6%E5%90%8Ekill"><span class="toc-text">4.2.4 获取程序id然后kill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E6%89%A7%E8%A1%8Cshell%E6%97%B6%EF%BC%8C%E6%98%BE%E7%A4%BA%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-text">4.2.5 执行shell时，显示源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89%E9%87%87%E7%94%A8source"><span class="toc-text">4.2.6 shell脚本中引入其他文件定义采用source</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-7-%E4%B8%80%E8%A1%8C%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4"><span class="toc-text">4.2.7 一行执行多条命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-8-%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E5%BE%97%E5%88%B0-x2F-%E5%88%86%E7%A6%BB%E5%87%BAIP%E5%9C%B0%E5%9D%80"><span class="toc-text">4.2.8 从文件中得到&#x2F;分离出IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-9-%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%82%B9"><span class="toc-text">4.2.9 替换字符串中的点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Shell%E5%8A%A0%E5%AF%86"><span class="toc-text">4.3 Shell加密</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1"><span class="toc-text">4.3.1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-shell%E4%BA%A4%E4%BA%92"><span class="toc-text">4.4 shell交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E8%87%AA%E5%8A%A8%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">4.4.1 自动交互方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E8%87%AA%E5%8A%A8%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-text">4.4.2 自动交互方法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E8%87%AA%E5%8A%A8%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95%E4%B8%89"><span class="toc-text">4.4.3 自动交互方法三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-4-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">4.4.4 方法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Shell%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">4.5 Shell函数返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-return%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.5.1 return语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-echo-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">4.5.2 echo 返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-iptables"><span class="toc-text">4.6 iptables</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E5%89%8D%E8%A8%80"><span class="toc-text">4.6.1 前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E6%80%BB%E7%BB%93"><span class="toc-text">4.6.2 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-shell%E8%B0%83%E8%AF%95"><span class="toc-text">4.7 shell调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E4%BD%BF%E7%94%A8trap"><span class="toc-text">4.7.1 使用trap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-1-0-1-%E4%BF%A1%E5%8F%B7"><span class="toc-text">4.7.1.0.1 信号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E4%BD%BF%E7%94%A8tee%E5%91%BD%E4%BB%A4"><span class="toc-text">4.7.2 使用tee命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E4%BD%BF%E7%94%A8%E8%B0%83%E8%AF%95%E5%87%BD%E6%95%B0"><span class="toc-text">4.7.3 使用调试函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-4-%E8%B0%83%E8%AF%95%E9%80%89%E9%A1%B9"><span class="toc-text">4.7.4 调试选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-5-%E5%AF%B9%E2%80%9D-x%E2%80%9D%E9%80%89%E9%A1%B9%E7%9A%84%E5%A2%9E%E5%BC%BA"><span class="toc-text">4.7.5 对”-x”选项的增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-6-%E6%80%BB%E7%BB%93"><span class="toc-text">4.7.6 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-shell%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-text">4.8 shell多行注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-1-%E6%B3%95%E4%B8%80"><span class="toc-text">4.8.1 法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-2-%E6%B3%95%E4%BA%8C"><span class="toc-text">4.8.2 法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-3-%E6%B3%95%E4%B8%89"><span class="toc-text">4.8.3 法三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-4-%E6%B3%95%E5%9B%9B"><span class="toc-text">4.8.4 法四</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-expect"><span class="toc-text">4.9 expect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-1-warning"><span class="toc-text">4.9.1 warning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-2-expect%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.9.2 expect实例详解****</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-Bash%E5%86%85%E5%BB%BA%E5%8F%98%E9%87%8F"><span class="toc-text">4.10 Bash内建变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-1-BASH"><span class="toc-text">4.10.1 $BASH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-2-BASH-ENV"><span class="toc-text">4.10.2 $BASH_ENV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-3-BASH-SUBSHELL"><span class="toc-text">4.10.3 $BASH_SUBSHELL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-4-BASH-VERSINFO-n"><span class="toc-text">4.10.4  $BASH_VERSINFO[n]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-5-BASH-VERSION"><span class="toc-text">4.10.5 $BASH_VERSION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-6-DIRSTACK"><span class="toc-text">4.10.6 $DIRSTACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-7-EDITOR"><span class="toc-text">4.10.7 $EDITOR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-8-EUID"><span class="toc-text">4.10.8 $EUID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-9-FUNCNAME"><span class="toc-text">4.10.9 $FUNCNAME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-10-GLOBIGNORE"><span class="toc-text">4.10.10 $GLOBIGNORE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-11-GROUPS"><span class="toc-text">4.10.11 $GROUPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-12-HOME"><span class="toc-text">4.10.12 $HOME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-13-HOSTNAME"><span class="toc-text">4.10.13 $HOSTNAME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-14-HOSTTYPE"><span class="toc-text">4.10.14 $HOSTTYPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-15-IFS"><span class="toc-text">4.10.15 $IFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-16-IGNOREEOF"><span class="toc-text">4.10.16 $IGNOREEOF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-17-LC-COLLATE"><span class="toc-text">4.10.17 $LC_COLLATE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-18-LC-CTYPE"><span class="toc-text">4.10.18 $LC_CTYPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-19-LINENO"><span class="toc-text">4.10.19 $LINENO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-20-MACHTYPE"><span class="toc-text">4.10.20 $MACHTYPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-21-OLDPWD"><span class="toc-text">4.10.21 $OLDPWD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-22-OSTYPE"><span class="toc-text">4.10.22 $OSTYPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-23-PATH"><span class="toc-text">4.10.23 $PATH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-24-PIPESTATUS"><span class="toc-text">4.10.24  $PIPESTATUS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-25-PPID"><span class="toc-text">4.10.25 $PPID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-26-PROMPT-COMMAND"><span class="toc-text">4.10.26 $PROMPT_COMMAND</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-27-PS1"><span class="toc-text">4.10.27 $PS1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-28-PS2"><span class="toc-text">4.10.28 $PS2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-29-PS3"><span class="toc-text">4.10.29 $PS3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-30-PS4"><span class="toc-text">4.10.30 $PS4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-31-PWD"><span class="toc-text">4.10.31 $PWD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-32-REPLY"><span class="toc-text">4.10.32 $REPLY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-33-SECONDS"><span class="toc-text">4.10.33 $SECONDS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-34-SHELLOPTS"><span class="toc-text">4.10.34 $SHELLOPTS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-35-SHLVL"><span class="toc-text">4.10.35 $SHLVL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-36-TMOUT"><span class="toc-text">4.10.36  $TMOUT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-37-%E5%85%B6%E4%BB%96"><span class="toc-text">4.10.37 其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2"><span class="toc-text">4.11 字体颜色</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-makefile"><span class="toc-text">第 5 章 makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">5.1 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-makefile%E8%A7%84%E5%88%99"><span class="toc-text">5.1.1 makefile规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%8F%98%E9%87%8F"><span class="toc-text">5.1.2 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E5%87%BD%E6%95%B0"><span class="toc-text">5.1.3 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-%E4%BC%AA%E7%9B%AE%E6%A0%87-x2F-%E8%99%9A%E7%9B%AE%E6%A0%87"><span class="toc-text">5.1.4 伪目标&#x2F;虚目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5-makefile%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF"><span class="toc-text">5.1.5 makefile常见语法错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-6-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%B0%83%E8%AF%95"><span class="toc-text">5.1.6 命令行的使用和调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-7-%E5%88%B6%E4%BD%9C%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E7%9A%84makefile"><span class="toc-text">5.1.7 制作工程文件的makefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-8-%E5%B5%8C%E5%A5%97%E6%89%A7%E8%A1%8Cmake"><span class="toc-text">5.1.8 嵌套执行make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-9-%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99"><span class="toc-text">5.1.9 命令出错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-10-%E6%9D%82%E9%A1%B9"><span class="toc-text">5.1.10 杂项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%85%B6%E4%BB%96"><span class="toc-text">5.2 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-text">5.2.1 定义宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E5%8F%96%E6%B6%88%E5%AE%8F"><span class="toc-text">5.2.2 取消宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E6%B3%A8%E6%84%8FTAB%E4%B8%8D%E8%83%BD%E7%94%A84%E4%B8%AA%E7%A9%BA%E6%A0%BC%E4%BB%A3%E6%9B%BF"><span class="toc-text">5.2.3 注意TAB不能用4个空格代替</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-if%E8%AF%AD%E5%8F%A5"><span class="toc-text">5.2.4 if语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-%E5%BE%97%E5%88%B0%E5%B7%B2%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8F"><span class="toc-text">5.2.5 得到已定义的宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BAMake-Automake-CMake"><span class="toc-text">5.3 项目构建Make,Automake,CMake</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-Automake"><span class="toc-text">5.3.1 Automake</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-CMake"><span class="toc-text">5.3.2 CMake</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-1-CMakeLists-txt"><span class="toc-text">5.3.2.1 CMakeLists.txt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-2-cmakes"><span class="toc-text">5.3.2.2 cmakes</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E9%99%84%EF%BC%9A%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">5.3.3 附：参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-CMake%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B"><span class="toc-text">5.3.4 CMake快速使用教程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-1-%E5%AE%9E%E4%BE%8BHelloWorld"><span class="toc-text">5.3.4.1 实例HelloWorld</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-4-1-1-%E5%BA%93%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="toc-text">5.3.4.1.1 库的构建与安装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5-Automake%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-text">5.3.5 Automake快速上手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-5-1-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90makefile%E6%B5%81%E7%A8%8B"><span class="toc-text">5.3.5.1 自动生成makefile流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-5-2-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90makefile%E4%BE%8B%E5%AD%90"><span class="toc-text">5.3.5.2 自动生成makefile例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-6-Myself-tool"><span class="toc-text">5.3.6 Myself tool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Makefile%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-text">5.4 Makefile调试方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E6%89%A7%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-text">5.4.1 执行选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-echo%E6%98%BE%E7%A4%BA"><span class="toc-text">5.4.2 echo显示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E9%99%84%E4%BB%B6"><span class="toc-text">5.5 附件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-Linux%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91"><span class="toc-text">第 6 章 Linux应用程序开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-text">6.1 Linux文件编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE"><span class="toc-text">6.1.1 系统调用文件访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-1-%E5%88%9B%E5%BB%BA"><span class="toc-text">6.1.1.1 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-2-%E6%89%93%E5%BC%80"><span class="toc-text">6.1.1.2 打开</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-3-%E5%85%B3%E9%97%AD"><span class="toc-text">6.1.1.3 关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-4-%E8%AF%BB"><span class="toc-text">6.1.1.4 读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-5-%E5%86%99"><span class="toc-text">6.1.1.5 写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-6-read-%E4%B8%8E-fread-%E7%9A%84%E5%8C%BA%E5%88%AB%E7%9A%84%E8%AF%AF%E8%A7%A3"><span class="toc-text">6.1.1.6  read 与 fread 的区别的误解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-7-%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">6.1.1.7 读写二进制文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-8-%E5%AE%9A%E4%BD%8D"><span class="toc-text">6.1.1.8 定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-9-%E6%96%87%E4%BB%B6%E9%94%81%E5%AE%9A"><span class="toc-text">6.1.1.9 文件锁定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-9-1-flock%EF%BC%88%EF%BC%89"><span class="toc-text">6.1.1.9.1 flock（）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-9-2-fcntl"><span class="toc-text">6.1.1.9.2 fcntl()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-9-3-lockf"><span class="toc-text">6.1.1.9.3 lockf()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-10-%E6%96%87%E4%BB%B6%E7%9A%84%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">6.1.1.10 文件的移动与复制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-10-1-%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B61"><span class="toc-text">6.1.1.10.1 文件复制1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-10-2-%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B62"><span class="toc-text">6.1.1.10.2 文件复制2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-11-%E5%90%8C%E4%B8%80%E5%88%86%E5%8C%BA%E4%B8%AD%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%87%BD%E6%95%B0rename"><span class="toc-text">6.1.1.11  同一分区中文件移动函数rename</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-12-%E8%AE%BF%E9%97%AE%E5%88%A4%E6%96%AD"><span class="toc-text">6.1.1.12 访问判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%BA%93%E5%87%BD%E6%95%B0-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE"><span class="toc-text">6.1.2 库函数-文件访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%89%93%E5%BC%80"><span class="toc-text">6.1.2.1 创建和打开</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-2-%E8%AF%BB"><span class="toc-text">6.1.2.2 读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-3-%E5%86%99"><span class="toc-text">6.1.2.3 写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-4-%E5%BA%93%E5%87%BD%E6%95%B0-%E8%AF%BB%E5%AD%97%E7%AC%A6"><span class="toc-text">6.1.2.4 库函数-读字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-5-%E5%BA%93%E5%87%BD%E6%95%B0-%E5%86%99%E5%AD%97%E7%AC%A6"><span class="toc-text">6.1.2.5 库函数-写字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-6-%E5%BA%93%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6"><span class="toc-text">6.1.2.6 库函数进行文件复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-7-%E5%BA%93%E5%87%BD%E6%95%B0-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB"><span class="toc-text">6.1.2.7 库函数-格式化读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-8-%E5%BA%93%E5%87%BD%E6%95%B0-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%86%99"><span class="toc-text">6.1.2.8 库函数-格式化写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-9-%E5%BA%93%E5%87%BD%E6%95%B0-%E5%AE%9A%E4%BD%8D"><span class="toc-text">6.1.2.9 库函数-定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-10-%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96"><span class="toc-text">6.1.2.10 路径获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-11-%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-text">6.1.2.11 创建目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-12-linux%E4%B8%8B%E6%B8%85%E7%A9%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">6.1.2.12 linux下清空文件内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-13-ftell%E5%87%BD%E6%95%B0"><span class="toc-text">6.1.2.13 ftell函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-14-bzero"><span class="toc-text">6.1.2.14 bzero</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-IO%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.1.3 IO处理模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">6.1.4 多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-4-1-select"><span class="toc-text">6.1.4.1 select()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-4-2-pool%EF%BC%88%EF%BC%89"><span class="toc-text">6.1.4.2 pool（）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-4-3-epool"><span class="toc-text">6.1.4.3 epool</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-struct-stat%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">6.1.5 struct stat结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Linux%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B"><span class="toc-text">6.2 Linux时间编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E8%BF%94%E5%9B%9E%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0time"><span class="toc-text">6.2.1 返回时间函数time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0gmtime"><span class="toc-text">6.2.2 当前时间函数gmtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0localtime"><span class="toc-text">6.2.3 本地时间函数localtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-localtime-r"><span class="toc-text">6.2.4 localtime_r</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0ctime"><span class="toc-text">6.2.5 字符串格式时间函数ctime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0asctime"><span class="toc-text">6.2.6 字符串格式时间函数asctime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-7-%E5%B0%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E7%A7%92%E6%95%B0%E5%87%BD%E6%95%B0mktime"><span class="toc-text">6.2.7 将时间转换成秒数函数mktime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-8-%E5%8F%96%E5%BE%97%E5%BD%93%E5%89%8D%E7%9A%84%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0gettimeofday"><span class="toc-text">6.2.8 取得当前的时间函数gettimeofday</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-9-%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0settimeofday"><span class="toc-text">6.2.9 设置当前时间函数settimeofday</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-10-tm%E7%BB%93%E6%9E%84"><span class="toc-text">6.2.10 tm结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-11-%E6%97%B6%E9%97%B4%E6%98%BE%E7%A4%BA"><span class="toc-text">6.2.11 时间显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-12-%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-text">6.2.12 获取时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-13-%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6"><span class="toc-text">6.2.13 计算程序执行耗时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-14-%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="toc-text">6.2.14 延时执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-15-%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%BE%E7%A4%BA"><span class="toc-text">6.2.15 获取本地时间，以字符串显示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-15-1-%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.15.1 第一种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-15-2-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.15.2 第二种方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-16-%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4"><span class="toc-text">6.2.16 设置系统时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6"><span class="toc-text">6.3 目录与文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">6.3.1 错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95"><span class="toc-text">6.3.2 创建与删除目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-1-%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%E5%87%BD%E6%95%B0mkdir"><span class="toc-text">6.3.2.1 创建目录函数mkdir()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-2-%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95"><span class="toc-text">6.3.2.2 删除目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-text">6.3.3 创建文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-4-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-text">6.3.4 删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-5-%E5%BB%BA%E7%AB%8B%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%87%BD%E6%95%B0mkstemp"><span class="toc-text">6.3.5 建立临时文件函数mkstemp()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-6-%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E8%A7%81%E5%89%8D%E9%9D%A2"><span class="toc-text">6.3.6 文件打开关闭见前面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-text">6.4 串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E8%AE%BE%E7%BD%AE"><span class="toc-text">6.4.1 虚拟机虚拟串口设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-%E4%B8%B2%E5%8F%A3%E8%AE%BE%E7%BD%AE"><span class="toc-text">6.4.2 串口设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.5 Linux进程控制程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-text">6.5.1 系统调用函数列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">6.5.2 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-1-%E8%BF%9B%E7%A8%8B"><span class="toc-text">6.5.2.1 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-2-%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-text">6.5.2.2 临界资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-3-%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text">6.5.2.3 临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-4-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">6.5.2.4 进程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-5-%E6%AD%BB%E9%94%81"><span class="toc-text">6.5.2.5 死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-3-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">6.5.3 进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-3-1-%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">6.5.3.1 调度方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-3-2-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">6.5.3.2 调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-4-%E8%8E%B7%E5%8F%96ID"><span class="toc-text">6.5.4 获取ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-5-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA-fork"><span class="toc-text">6.5.5 进程创建-fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-6-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA-vfork"><span class="toc-text">6.5.6 进程创建-vfork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-7-fork-x2F-vfork%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">6.5.7 fork&#x2F; vfork区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-8-exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-text">6.5.8 exec函数族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-9-%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85"><span class="toc-text">6.5.9 进程等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-10-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-text">6.5.10 进程终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-11-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">6.5.11 守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-11-1-%E6%AD%A5%E9%AA%A4"><span class="toc-text">6.5.11.1 步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-11-2-%E5%AE%9E%E4%BE%8B"><span class="toc-text">6.5.11.2 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-11-3-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%87%BA%E9%94%99%E5%A4%84%E7%90%86"><span class="toc-text">6.5.11.3 守护进程的出错处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.6 Linux进程间通信程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%9C%80%E8%A6%81%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-text">6.6.1 为什么进程间需要通信？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2-Linux%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-text">6.6.2 Linux使用的进程间通信方式包括：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3-%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-text">6.6.3 管道通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-1-%E7%AE%A1%E9%81%93%E5%88%9B%E5%BB%BA"><span class="toc-text">6.6.3.1 管道创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-2-%E7%AE%A1%E9%81%93%E5%85%B3%E9%97%AD"><span class="toc-text">6.6.3.2 管道关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-3-%E7%AE%A1%E9%81%93%E8%AF%BB%E5%86%99"><span class="toc-text">6.6.3.3 管道读写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-4-%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%88FIFO%EF%BC%89"><span class="toc-text">6.6.4 命名管道（FIFO）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-1-%E5%88%9B%E5%BB%BA"><span class="toc-text">6.6.4.1 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-2-%E6%93%8D%E4%BD%9C"><span class="toc-text">6.6.4.2 操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-5-%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1"><span class="toc-text">6.6.5 信号通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-5-1-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-text">6.6.5.1 信号处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-5-2-%E4%BF%A1%E5%8F%B7%E5%8F%91%E9%80%81"><span class="toc-text">6.6.5.2 信号发送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-5-3-Alarm"><span class="toc-text">6.6.5.3 Alarm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-5-4-pause"><span class="toc-text">6.6.5.4 pause</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-5-5-%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">6.6.5.5 信号的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-5-5-1-signal"><span class="toc-text">6.6.5.5.1 signal</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-6-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">6.6.6 共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-6-1-%E5%88%9B%E5%BB%BA"><span class="toc-text">6.6.6.1 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-6-2-%E6%98%A0%E5%B0%84"><span class="toc-text">6.6.6.2 映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-7-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">6.6.7 消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-7-1-%E9%94%AE%E5%80%BC"><span class="toc-text">6.6.7.1 键值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-7-2-%E6%89%93%E5%BC%80-x2F-%E5%88%9B%E5%BB%BA"><span class="toc-text">6.6.7.2 打开&#x2F;创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-7-3-%E5%88%9B%E5%BB%BA"><span class="toc-text">6.6.7.3 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-7-4-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-text">6.6.7.4 发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-7-5-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="toc-text">6.6.7.5 接收消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-8-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">6.6.8 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-8-1-%E5%88%86%E7%B1%BB"><span class="toc-text">6.6.8.1 分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-8-2-%E5%88%9B%E5%BB%BA-x2F-%E6%89%93%E5%BC%80"><span class="toc-text">6.6.8.2 创建&#x2F;打开</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-8-3-%E6%93%8D%E4%BD%9C"><span class="toc-text">6.6.8.3 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-8-4-Linux-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E2%80%94-%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1"><span class="toc-text">6.6.8.4 Linux 进程间通信 — 信号通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-8-4-1-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-text">6.6.8.4.1 信号处理：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-8-4-2-%E4%BF%A1%E5%8F%B7%E5%8F%91%E9%80%81-kill-%E5%92%8C-raise-%EF%BC%9A"><span class="toc-text">6.6.8.4.2 信号发送  -  kill 和 raise ：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-8-4-3-Alarm%E4%BF%A1%E5%8F%B7%E9%97%B9%E9%92%9F-unsigned-int-alarm%EF%BC%9A"><span class="toc-text">6.6.8.4.3 Alarm信号闹钟  unsigned int alarm：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-8-4-4-pause%E5%87%BD%E6%95%B0"><span class="toc-text">6.6.8.4.4 pause函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-8-4-5-signal-%E5%87%BD%E6%95%B0"><span class="toc-text">6.6.8.4.5 signal 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">6.6.9 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-9-1-%E4%BC%98%E7%82%B9"><span class="toc-text">6.6.9.1 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-9-2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">6.6.9.2 创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-9-3-%E7%BC%96%E8%AF%91"><span class="toc-text">6.6.9.3 编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-9-4-%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">6.6.9.4 终止线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-9-5-%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="toc-text">6.6.9.5 线程退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-9-6-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85"><span class="toc-text">6.6.9.6 线程等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-9-7-%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="toc-text">6.6.9.7 线程标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-9-8-%E6%B8%85%E9%99%A4"><span class="toc-text">6.6.9.8 清除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-9-9-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">6.6.9.9 线程同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-10-%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-text">6.6.10 互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-10-1-%E5%88%9B%E5%BB%BA"><span class="toc-text">6.6.10.1 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-10-2-%E5%8A%A0%E9%94%81"><span class="toc-text">6.6.10.2 加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-10-3-%E8%A7%A3%E9%94%81"><span class="toc-text">6.6.10.3 解锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-10-4-%E4%BA%92%E6%96%A5%E9%87%8FPK%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">6.6.10.4 互斥量PK信号量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-Linux%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.7 Linux网络应用程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-1-%E7%AB%AF%E5%8F%A3"><span class="toc-text">6.7.1 端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-2-TCP-x2F-IP"><span class="toc-text">6.7.2 TCP&#x2F;IP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-1-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.7.2.1 网络模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-2-TCP-x2F-IP4%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.7.2.2 TCP&#x2F;IP4层模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-3-TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-text">6.7.2.3 TCP&#x2F;IP协议族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-4-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">6.7.2.4 网络层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-5-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-text">6.7.2.5 传输层协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-6-%E5%BA%94%E7%94%A8%E5%8D%8F%E8%AE%AE"><span class="toc-text">6.7.2.6 应用协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-7-IP%E5%8D%8F%E8%AE%AE"><span class="toc-text">6.7.2.7 IP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-8-TCP%E5%8D%8F%E8%AE%AE"><span class="toc-text">6.7.2.8 TCP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-9-UDP%E5%8D%8F%E8%AE%AE"><span class="toc-text">6.7.2.9 UDP协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-3-linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">6.7.3 linux网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-1-%E5%A5%97%E6%8E%A5%E5%AD%97socket%E6%9C%89%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">6.7.3.1 套接字socket有三种类型：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-2-%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-text">6.7.3.2 地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-3-%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">6.7.3.3 字节序转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-4-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A0%BC%E5%BC%8F"><span class="toc-text">6.7.3.4 如何判断大小端格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-5-%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A6%82%E5%BF%B5"><span class="toc-text">6.7.3.5 大小端概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-5-1-Byte%E7%B1%BB%E5%9E%8B-8bits"><span class="toc-text">6.7.3.5.1 Byte类型(8bits)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-5-2-Short%E7%B1%BB%E5%9E%8B-16bits"><span class="toc-text">6.7.3.5.2 Short类型(16bits)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-5-3-Long%E7%B1%BB%E5%9E%8B-32bits"><span class="toc-text">6.7.3.5.3 Long类型(32bits)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-5-4-%E4%BD%8D%E5%9F%9F%E7%9A%84%E6%83%85%E5%86%B5-%E8%BE%B9%E7%95%8C%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98-%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98-%EF%BC%9A"><span class="toc-text">6.7.3.5.4 位域的情况(边界对齐问题+大小端问题)：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-6-IP%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%90%8D"><span class="toc-text">6.7.3.6 IP与主机名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-7-%E5%90%8D%E5%AD%97%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-text">6.7.3.7 名字地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-8-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-text">6.7.3.8 地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-9-%E5%87%BD%E6%95%B0"><span class="toc-text">6.7.3.9 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-10-%E5%9F%BA%E4%BA%8ETCP-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">6.7.3.10 基于TCP-服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-11-%E5%9F%BA%E4%BA%8ETCP-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">6.7.3.11 基于TCP-客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-12-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-text">6.7.3.12 网络地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-12-1-%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F"><span class="toc-text">6.7.3.12.1 网络字节顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-12-2-%E6%9C%89%E5%85%B3%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-text">6.7.3.12.2 有关的转换函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-12-3-inet-ntoa"><span class="toc-text">6.7.3.12.3 inet_ntoa()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-13-%E5%90%84%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95"><span class="toc-text">6.7.3.13 各函数语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-13-1-socket"><span class="toc-text">6.7.3.13.1 socket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-13-2-bind"><span class="toc-text">6.7.3.13.2 bind</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-13-3-listen"><span class="toc-text">6.7.3.13.3 listen</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-13-4-accept"><span class="toc-text">6.7.3.13.4 accept</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-13-5-inet-pton"><span class="toc-text">6.7.3.13.5 inet_pton</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-13-6-setsockopt"><span class="toc-text">6.7.3.13.6 setsockopt</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-13-7-sockaddr-ll%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">6.7.3.13.7 sockaddr_ll结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-13-8-Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%9A%84send%E5%92%8Crecv%E5%87%BD%E6%95%B0"><span class="toc-text">6.7.3.13.8 Linux学习笔记之网络的send和recv函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-4-inet-pton"><span class="toc-text">6.7.4 inet_pton</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0"><span class="toc-text">6.8 其他系统函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="toc-text">6.8.1 字符串处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-1-1-char-strcasestr-const-char-haystack-const-char-needle"><span class="toc-text">6.8.1.1 char *strcasestr(const char *haystack,const char *needle)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-1-2-char-strtok-char-str-const-char-delimiters"><span class="toc-text">6.8.1.2 char *strtok(char *str,const char *delimiters)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-2-getrlimit-%E4%B8%8Esetrlimit-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-text">6.8.2 getrlimit()与setrlimit()函数详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-3-signal-%E5%87%BD%E6%95%B0"><span class="toc-text">6.8.3 signal()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-4-WIFEXITED-x2F-WEXITSTATUS-x2F-WIFSIGNALED"><span class="toc-text">6.8.4 WIFEXITED&#x2F;WEXITSTATUS&#x2F;WIFSIGNALED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-5-Linux%E4%B8%8Bsend%E3%80%81sendto%E3%80%81sendmsg%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">6.8.5 Linux下send、sendto、sendmsg函数分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-6-Makecontext-x2F-getcontext-x2F-swapcontext%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B"><span class="toc-text">6.8.6 Makecontext&#x2F;getcontext&#x2F;swapcontext实现用户线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-6-1-ucontext-t"><span class="toc-text">6.8.6.1 ucontext_t</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-6-2-Ucontext-1"><span class="toc-text">6.8.6.2 Ucontext 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-6-3-ucontext%E6%9C%BA%E5%88%B62"><span class="toc-text">6.8.6.3 ucontext机制2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-6-4-Ucontext%E5%8D%8F%E7%A8%8B%E7%90%86%E8%A7%A33"><span class="toc-text">6.8.6.4 Ucontext协程理解3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-7-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8popen-%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4"><span class="toc-text">6.8.7 Linux下使用popen()执行shell命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-new"><span class="toc-text">第 7 章 new</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-gcc%E9%80%89%E9%A1%B9-g%E4%B8%8E-rdynamic%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">7.1 gcc选项-g与-rdynamic的异同</span></a></li></ol></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
<div class="share" style="width: 100%;">
  <!-- <img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-10-qrcode_for_gh_ffacf5722095_258.jpg" alt="Running Geek" style="margin: auto; display: block;"/> -->

  <!-- <div style="margin: auto; text-align: center; font-size: 0.8em; color: grey;">老铁们关注走一走，不迷路</div> -->
  
</div>

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/posts/8cd77be.html" rel="next" title="深入解析Linux 常用命令--top">
          深入解析Linux 常用命令--top
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/posts/6d977824.html" rel="prev" title="Mobaxterm工具">
            Mobaxterm工具
          </a>
          <span>〉</span>
        
      </div>
    </div>
  
<script src="https://giscus.app/client.js"
        data-repo="juyin/giscus"
        data-repo-id="R_kgDOJlIAiA"
        data-category="Announcements"
        data-category-id="DIC_kwDOJlIAiM4CWmzd"
        data-mapping="title"
        data-strict="1"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="https://cdn.jsdelivr.net/gh/fooying/hexo-theme-xoxo-plus@master/source/css/light_tritanopia_xoxo.min.css"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>


    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="http://helloeuler.cn">首页</a> |
<!--    <a class="bottom-item" href="http://helloeuler.cn" target="_blank">主站</a> |  -->
<!--    <a class="bottom-item" href="https://github.com/juyin" target="_blank">GitHub</a> |  -->
        <a class="bottom-item" href="https://hexo.io" target="_blank">Hexo</a> 
<!--    <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a> -->
		
			</br>
			<!-- 不蒜子统计 -->
<!--		<span class="post-meta-divider">&nbsp;|&nbsp;</span> -->
			<span id="busuanzi_container_site_pv"> 总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			<span class="post-meta-divider"> &nbsp;|&nbsp; </span>
			<span id="busuanzi_container_site_uv" style='display:none'>访客数<span id="busuanzi_value_site_uv"></span>人</span>
			<script async src="/busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
		

    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



</body>
</html>
